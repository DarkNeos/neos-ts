/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 3.21.5
 * source: idl/ocgcore.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as pb_1 from "google-protobuf";
export namespace ygopro {
    export enum HandType {
        UNKNOWN = 0,
        SCISSORS = 1,
        ROCK = 2,
        PAPER = 3
    }
    export enum CardZone {
        DECK = 0,
        HAND = 1,
        MZONE = 2,
        SZONE = 3,
        GRAVE = 4,
        REMOVED = 5,
        EXTRA = 6,
        ONFIELD = 7,
        FZONE = 8,
        PZONE = 9,
        TZONE = 10
    }
    export enum CardPosition {
        FACEUP_ATTACK = 0,
        FACEDOWN_ATTACK = 1,
        FACEUP_DEFENSE = 2,
        FACEDOWN_DEFENSE = 3,
        FACEUP = 4,
        FACEDOWN = 5,
        ATTACK = 6,
        DEFENSE = 7
    }
    export class CardInfo extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            code?: number;
            controller?: number;
            location?: CardZone;
            sequence?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("code" in data && data.code != undefined) {
                    this.code = data.code;
                }
                if ("controller" in data && data.controller != undefined) {
                    this.controller = data.controller;
                }
                if ("location" in data && data.location != undefined) {
                    this.location = data.location;
                }
                if ("sequence" in data && data.sequence != undefined) {
                    this.sequence = data.sequence;
                }
            }
        }
        get code() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set code(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get controller() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set controller(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get location() {
            return pb_1.Message.getFieldWithDefault(this, 3, CardZone.DECK) as CardZone;
        }
        set location(value: CardZone) {
            pb_1.Message.setField(this, 3, value);
        }
        get sequence() {
            return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
        }
        set sequence(value: number) {
            pb_1.Message.setField(this, 4, value);
        }
        static fromObject(data: {
            code?: number;
            controller?: number;
            location?: CardZone;
            sequence?: number;
        }): CardInfo {
            const message = new CardInfo({});
            if (data.code != null) {
                message.code = data.code;
            }
            if (data.controller != null) {
                message.controller = data.controller;
            }
            if (data.location != null) {
                message.location = data.location;
            }
            if (data.sequence != null) {
                message.sequence = data.sequence;
            }
            return message;
        }
        toObject() {
            const data: {
                code?: number;
                controller?: number;
                location?: CardZone;
                sequence?: number;
            } = {};
            if (this.code != null) {
                data.code = this.code;
            }
            if (this.controller != null) {
                data.controller = this.controller;
            }
            if (this.location != null) {
                data.location = this.location;
            }
            if (this.sequence != null) {
                data.sequence = this.sequence;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.code != 0)
                writer.writeInt32(1, this.code);
            if (this.controller != 0)
                writer.writeInt32(2, this.controller);
            if (this.location != CardZone.DECK)
                writer.writeEnum(3, this.location);
            if (this.sequence != 0)
                writer.writeInt32(4, this.sequence);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): CardInfo {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new CardInfo();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.code = reader.readInt32();
                        break;
                    case 2:
                        message.controller = reader.readInt32();
                        break;
                    case 3:
                        message.location = reader.readEnum();
                        break;
                    case 4:
                        message.sequence = reader.readInt32();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): CardInfo {
            return CardInfo.deserialize(bytes);
        }
    }
    export class CardLocation extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            controller?: number;
            zone?: CardZone;
            sequence?: number;
            position?: CardPosition;
            is_overlay?: boolean;
            overlay_sequence?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("controller" in data && data.controller != undefined) {
                    this.controller = data.controller;
                }
                if ("zone" in data && data.zone != undefined) {
                    this.zone = data.zone;
                }
                if ("sequence" in data && data.sequence != undefined) {
                    this.sequence = data.sequence;
                }
                if ("position" in data && data.position != undefined) {
                    this.position = data.position;
                }
                if ("is_overlay" in data && data.is_overlay != undefined) {
                    this.is_overlay = data.is_overlay;
                }
                if ("overlay_sequence" in data && data.overlay_sequence != undefined) {
                    this.overlay_sequence = data.overlay_sequence;
                }
            }
        }
        get controller() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set controller(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get zone() {
            return pb_1.Message.getFieldWithDefault(this, 2, CardZone.DECK) as CardZone;
        }
        set zone(value: CardZone) {
            pb_1.Message.setField(this, 2, value);
        }
        get sequence() {
            return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
        }
        set sequence(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        get position() {
            return pb_1.Message.getFieldWithDefault(this, 4, CardPosition.FACEUP_ATTACK) as CardPosition;
        }
        set position(value: CardPosition) {
            pb_1.Message.setField(this, 4, value);
        }
        get is_overlay() {
            return pb_1.Message.getFieldWithDefault(this, 5, false) as boolean;
        }
        set is_overlay(value: boolean) {
            pb_1.Message.setField(this, 5, value);
        }
        get overlay_sequence() {
            return pb_1.Message.getFieldWithDefault(this, 6, 0) as number;
        }
        set overlay_sequence(value: number) {
            pb_1.Message.setField(this, 6, value);
        }
        static fromObject(data: {
            controller?: number;
            zone?: CardZone;
            sequence?: number;
            position?: CardPosition;
            is_overlay?: boolean;
            overlay_sequence?: number;
        }): CardLocation {
            const message = new CardLocation({});
            if (data.controller != null) {
                message.controller = data.controller;
            }
            if (data.zone != null) {
                message.zone = data.zone;
            }
            if (data.sequence != null) {
                message.sequence = data.sequence;
            }
            if (data.position != null) {
                message.position = data.position;
            }
            if (data.is_overlay != null) {
                message.is_overlay = data.is_overlay;
            }
            if (data.overlay_sequence != null) {
                message.overlay_sequence = data.overlay_sequence;
            }
            return message;
        }
        toObject() {
            const data: {
                controller?: number;
                zone?: CardZone;
                sequence?: number;
                position?: CardPosition;
                is_overlay?: boolean;
                overlay_sequence?: number;
            } = {};
            if (this.controller != null) {
                data.controller = this.controller;
            }
            if (this.zone != null) {
                data.zone = this.zone;
            }
            if (this.sequence != null) {
                data.sequence = this.sequence;
            }
            if (this.position != null) {
                data.position = this.position;
            }
            if (this.is_overlay != null) {
                data.is_overlay = this.is_overlay;
            }
            if (this.overlay_sequence != null) {
                data.overlay_sequence = this.overlay_sequence;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.controller != 0)
                writer.writeInt32(1, this.controller);
            if (this.zone != CardZone.DECK)
                writer.writeEnum(2, this.zone);
            if (this.sequence != 0)
                writer.writeInt32(3, this.sequence);
            if (this.position != CardPosition.FACEUP_ATTACK)
                writer.writeEnum(4, this.position);
            if (this.is_overlay != false)
                writer.writeBool(5, this.is_overlay);
            if (this.overlay_sequence != 0)
                writer.writeInt32(6, this.overlay_sequence);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): CardLocation {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new CardLocation();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.controller = reader.readInt32();
                        break;
                    case 2:
                        message.zone = reader.readEnum();
                        break;
                    case 3:
                        message.sequence = reader.readInt32();
                        break;
                    case 4:
                        message.position = reader.readEnum();
                        break;
                    case 5:
                        message.is_overlay = reader.readBool();
                        break;
                    case 6:
                        message.overlay_sequence = reader.readInt32();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): CardLocation {
            return CardLocation.deserialize(bytes);
        }
    }
    export class YgoCtosMsg extends pb_1.Message {
        #one_of_decls: number[][] = [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]];
        constructor(data?: any[] | ({} & (({
            ctos_player_info?: CtosPlayerInfo;
            ctos_join_game?: never;
            ctos_update_deck?: never;
            ctos_hs_ready?: never;
            ctos_hs_start?: never;
            ctos_hs_not_ready?: never;
            ctos_hand_result?: never;
            ctos_tp_result?: never;
            ctos_time_confirm?: never;
            ctos_response?: never;
            ctos_chat?: never;
            ctos_surrender?: never;
            ctos_hs_to_observer?: never;
            ctos_hs_to_duel_list?: never;
        } | {
            ctos_player_info?: never;
            ctos_join_game?: CtosJoinGame;
            ctos_update_deck?: never;
            ctos_hs_ready?: never;
            ctos_hs_start?: never;
            ctos_hs_not_ready?: never;
            ctos_hand_result?: never;
            ctos_tp_result?: never;
            ctos_time_confirm?: never;
            ctos_response?: never;
            ctos_chat?: never;
            ctos_surrender?: never;
            ctos_hs_to_observer?: never;
            ctos_hs_to_duel_list?: never;
        } | {
            ctos_player_info?: never;
            ctos_join_game?: never;
            ctos_update_deck?: CtosUpdateDeck;
            ctos_hs_ready?: never;
            ctos_hs_start?: never;
            ctos_hs_not_ready?: never;
            ctos_hand_result?: never;
            ctos_tp_result?: never;
            ctos_time_confirm?: never;
            ctos_response?: never;
            ctos_chat?: never;
            ctos_surrender?: never;
            ctos_hs_to_observer?: never;
            ctos_hs_to_duel_list?: never;
        } | {
            ctos_player_info?: never;
            ctos_join_game?: never;
            ctos_update_deck?: never;
            ctos_hs_ready?: CtosHsReady;
            ctos_hs_start?: never;
            ctos_hs_not_ready?: never;
            ctos_hand_result?: never;
            ctos_tp_result?: never;
            ctos_time_confirm?: never;
            ctos_response?: never;
            ctos_chat?: never;
            ctos_surrender?: never;
            ctos_hs_to_observer?: never;
            ctos_hs_to_duel_list?: never;
        } | {
            ctos_player_info?: never;
            ctos_join_game?: never;
            ctos_update_deck?: never;
            ctos_hs_ready?: never;
            ctos_hs_start?: CtosHsStart;
            ctos_hs_not_ready?: never;
            ctos_hand_result?: never;
            ctos_tp_result?: never;
            ctos_time_confirm?: never;
            ctos_response?: never;
            ctos_chat?: never;
            ctos_surrender?: never;
            ctos_hs_to_observer?: never;
            ctos_hs_to_duel_list?: never;
        } | {
            ctos_player_info?: never;
            ctos_join_game?: never;
            ctos_update_deck?: never;
            ctos_hs_ready?: never;
            ctos_hs_start?: never;
            ctos_hs_not_ready?: CtosHsNotReady;
            ctos_hand_result?: never;
            ctos_tp_result?: never;
            ctos_time_confirm?: never;
            ctos_response?: never;
            ctos_chat?: never;
            ctos_surrender?: never;
            ctos_hs_to_observer?: never;
            ctos_hs_to_duel_list?: never;
        } | {
            ctos_player_info?: never;
            ctos_join_game?: never;
            ctos_update_deck?: never;
            ctos_hs_ready?: never;
            ctos_hs_start?: never;
            ctos_hs_not_ready?: never;
            ctos_hand_result?: CtosHandResult;
            ctos_tp_result?: never;
            ctos_time_confirm?: never;
            ctos_response?: never;
            ctos_chat?: never;
            ctos_surrender?: never;
            ctos_hs_to_observer?: never;
            ctos_hs_to_duel_list?: never;
        } | {
            ctos_player_info?: never;
            ctos_join_game?: never;
            ctos_update_deck?: never;
            ctos_hs_ready?: never;
            ctos_hs_start?: never;
            ctos_hs_not_ready?: never;
            ctos_hand_result?: never;
            ctos_tp_result?: CtosTpResult;
            ctos_time_confirm?: never;
            ctos_response?: never;
            ctos_chat?: never;
            ctos_surrender?: never;
            ctos_hs_to_observer?: never;
            ctos_hs_to_duel_list?: never;
        } | {
            ctos_player_info?: never;
            ctos_join_game?: never;
            ctos_update_deck?: never;
            ctos_hs_ready?: never;
            ctos_hs_start?: never;
            ctos_hs_not_ready?: never;
            ctos_hand_result?: never;
            ctos_tp_result?: never;
            ctos_time_confirm?: CtosTimeConfirm;
            ctos_response?: never;
            ctos_chat?: never;
            ctos_surrender?: never;
            ctos_hs_to_observer?: never;
            ctos_hs_to_duel_list?: never;
        } | {
            ctos_player_info?: never;
            ctos_join_game?: never;
            ctos_update_deck?: never;
            ctos_hs_ready?: never;
            ctos_hs_start?: never;
            ctos_hs_not_ready?: never;
            ctos_hand_result?: never;
            ctos_tp_result?: never;
            ctos_time_confirm?: never;
            ctos_response?: CtosGameMsgResponse;
            ctos_chat?: never;
            ctos_surrender?: never;
            ctos_hs_to_observer?: never;
            ctos_hs_to_duel_list?: never;
        } | {
            ctos_player_info?: never;
            ctos_join_game?: never;
            ctos_update_deck?: never;
            ctos_hs_ready?: never;
            ctos_hs_start?: never;
            ctos_hs_not_ready?: never;
            ctos_hand_result?: never;
            ctos_tp_result?: never;
            ctos_time_confirm?: never;
            ctos_response?: never;
            ctos_chat?: CtosChat;
            ctos_surrender?: never;
            ctos_hs_to_observer?: never;
            ctos_hs_to_duel_list?: never;
        } | {
            ctos_player_info?: never;
            ctos_join_game?: never;
            ctos_update_deck?: never;
            ctos_hs_ready?: never;
            ctos_hs_start?: never;
            ctos_hs_not_ready?: never;
            ctos_hand_result?: never;
            ctos_tp_result?: never;
            ctos_time_confirm?: never;
            ctos_response?: never;
            ctos_chat?: never;
            ctos_surrender?: CtosSurrender;
            ctos_hs_to_observer?: never;
            ctos_hs_to_duel_list?: never;
        } | {
            ctos_player_info?: never;
            ctos_join_game?: never;
            ctos_update_deck?: never;
            ctos_hs_ready?: never;
            ctos_hs_start?: never;
            ctos_hs_not_ready?: never;
            ctos_hand_result?: never;
            ctos_tp_result?: never;
            ctos_time_confirm?: never;
            ctos_response?: never;
            ctos_chat?: never;
            ctos_surrender?: never;
            ctos_hs_to_observer?: CtosHsToObserver;
            ctos_hs_to_duel_list?: never;
        } | {
            ctos_player_info?: never;
            ctos_join_game?: never;
            ctos_update_deck?: never;
            ctos_hs_ready?: never;
            ctos_hs_start?: never;
            ctos_hs_not_ready?: never;
            ctos_hand_result?: never;
            ctos_tp_result?: never;
            ctos_time_confirm?: never;
            ctos_response?: never;
            ctos_chat?: never;
            ctos_surrender?: never;
            ctos_hs_to_observer?: never;
            ctos_hs_to_duel_list?: CtosHsToDuelList;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("ctos_player_info" in data && data.ctos_player_info != undefined) {
                    this.ctos_player_info = data.ctos_player_info;
                }
                if ("ctos_join_game" in data && data.ctos_join_game != undefined) {
                    this.ctos_join_game = data.ctos_join_game;
                }
                if ("ctos_update_deck" in data && data.ctos_update_deck != undefined) {
                    this.ctos_update_deck = data.ctos_update_deck;
                }
                if ("ctos_hs_ready" in data && data.ctos_hs_ready != undefined) {
                    this.ctos_hs_ready = data.ctos_hs_ready;
                }
                if ("ctos_hs_start" in data && data.ctos_hs_start != undefined) {
                    this.ctos_hs_start = data.ctos_hs_start;
                }
                if ("ctos_hs_not_ready" in data && data.ctos_hs_not_ready != undefined) {
                    this.ctos_hs_not_ready = data.ctos_hs_not_ready;
                }
                if ("ctos_hand_result" in data && data.ctos_hand_result != undefined) {
                    this.ctos_hand_result = data.ctos_hand_result;
                }
                if ("ctos_tp_result" in data && data.ctos_tp_result != undefined) {
                    this.ctos_tp_result = data.ctos_tp_result;
                }
                if ("ctos_time_confirm" in data && data.ctos_time_confirm != undefined) {
                    this.ctos_time_confirm = data.ctos_time_confirm;
                }
                if ("ctos_response" in data && data.ctos_response != undefined) {
                    this.ctos_response = data.ctos_response;
                }
                if ("ctos_chat" in data && data.ctos_chat != undefined) {
                    this.ctos_chat = data.ctos_chat;
                }
                if ("ctos_surrender" in data && data.ctos_surrender != undefined) {
                    this.ctos_surrender = data.ctos_surrender;
                }
                if ("ctos_hs_to_observer" in data && data.ctos_hs_to_observer != undefined) {
                    this.ctos_hs_to_observer = data.ctos_hs_to_observer;
                }
                if ("ctos_hs_to_duel_list" in data && data.ctos_hs_to_duel_list != undefined) {
                    this.ctos_hs_to_duel_list = data.ctos_hs_to_duel_list;
                }
            }
        }
        get ctos_player_info() {
            return pb_1.Message.getWrapperField(this, CtosPlayerInfo, 1) as CtosPlayerInfo;
        }
        set ctos_player_info(value: CtosPlayerInfo) {
            pb_1.Message.setOneofWrapperField(this, 1, this.#one_of_decls[0], value);
        }
        get has_ctos_player_info() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get ctos_join_game() {
            return pb_1.Message.getWrapperField(this, CtosJoinGame, 2) as CtosJoinGame;
        }
        set ctos_join_game(value: CtosJoinGame) {
            pb_1.Message.setOneofWrapperField(this, 2, this.#one_of_decls[0], value);
        }
        get has_ctos_join_game() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get ctos_update_deck() {
            return pb_1.Message.getWrapperField(this, CtosUpdateDeck, 3) as CtosUpdateDeck;
        }
        set ctos_update_deck(value: CtosUpdateDeck) {
            pb_1.Message.setOneofWrapperField(this, 3, this.#one_of_decls[0], value);
        }
        get has_ctos_update_deck() {
            return pb_1.Message.getField(this, 3) != null;
        }
        get ctos_hs_ready() {
            return pb_1.Message.getWrapperField(this, CtosHsReady, 4) as CtosHsReady;
        }
        set ctos_hs_ready(value: CtosHsReady) {
            pb_1.Message.setOneofWrapperField(this, 4, this.#one_of_decls[0], value);
        }
        get has_ctos_hs_ready() {
            return pb_1.Message.getField(this, 4) != null;
        }
        get ctos_hs_start() {
            return pb_1.Message.getWrapperField(this, CtosHsStart, 5) as CtosHsStart;
        }
        set ctos_hs_start(value: CtosHsStart) {
            pb_1.Message.setOneofWrapperField(this, 5, this.#one_of_decls[0], value);
        }
        get has_ctos_hs_start() {
            return pb_1.Message.getField(this, 5) != null;
        }
        get ctos_hs_not_ready() {
            return pb_1.Message.getWrapperField(this, CtosHsNotReady, 6) as CtosHsNotReady;
        }
        set ctos_hs_not_ready(value: CtosHsNotReady) {
            pb_1.Message.setOneofWrapperField(this, 6, this.#one_of_decls[0], value);
        }
        get has_ctos_hs_not_ready() {
            return pb_1.Message.getField(this, 6) != null;
        }
        get ctos_hand_result() {
            return pb_1.Message.getWrapperField(this, CtosHandResult, 7) as CtosHandResult;
        }
        set ctos_hand_result(value: CtosHandResult) {
            pb_1.Message.setOneofWrapperField(this, 7, this.#one_of_decls[0], value);
        }
        get has_ctos_hand_result() {
            return pb_1.Message.getField(this, 7) != null;
        }
        get ctos_tp_result() {
            return pb_1.Message.getWrapperField(this, CtosTpResult, 8) as CtosTpResult;
        }
        set ctos_tp_result(value: CtosTpResult) {
            pb_1.Message.setOneofWrapperField(this, 8, this.#one_of_decls[0], value);
        }
        get has_ctos_tp_result() {
            return pb_1.Message.getField(this, 8) != null;
        }
        get ctos_time_confirm() {
            return pb_1.Message.getWrapperField(this, CtosTimeConfirm, 9) as CtosTimeConfirm;
        }
        set ctos_time_confirm(value: CtosTimeConfirm) {
            pb_1.Message.setOneofWrapperField(this, 9, this.#one_of_decls[0], value);
        }
        get has_ctos_time_confirm() {
            return pb_1.Message.getField(this, 9) != null;
        }
        get ctos_response() {
            return pb_1.Message.getWrapperField(this, CtosGameMsgResponse, 10) as CtosGameMsgResponse;
        }
        set ctos_response(value: CtosGameMsgResponse) {
            pb_1.Message.setOneofWrapperField(this, 10, this.#one_of_decls[0], value);
        }
        get has_ctos_response() {
            return pb_1.Message.getField(this, 10) != null;
        }
        get ctos_chat() {
            return pb_1.Message.getWrapperField(this, CtosChat, 11) as CtosChat;
        }
        set ctos_chat(value: CtosChat) {
            pb_1.Message.setOneofWrapperField(this, 11, this.#one_of_decls[0], value);
        }
        get has_ctos_chat() {
            return pb_1.Message.getField(this, 11) != null;
        }
        get ctos_surrender() {
            return pb_1.Message.getWrapperField(this, CtosSurrender, 12) as CtosSurrender;
        }
        set ctos_surrender(value: CtosSurrender) {
            pb_1.Message.setOneofWrapperField(this, 12, this.#one_of_decls[0], value);
        }
        get has_ctos_surrender() {
            return pb_1.Message.getField(this, 12) != null;
        }
        get ctos_hs_to_observer() {
            return pb_1.Message.getWrapperField(this, CtosHsToObserver, 13) as CtosHsToObserver;
        }
        set ctos_hs_to_observer(value: CtosHsToObserver) {
            pb_1.Message.setOneofWrapperField(this, 13, this.#one_of_decls[0], value);
        }
        get has_ctos_hs_to_observer() {
            return pb_1.Message.getField(this, 13) != null;
        }
        get ctos_hs_to_duel_list() {
            return pb_1.Message.getWrapperField(this, CtosHsToDuelList, 14) as CtosHsToDuelList;
        }
        set ctos_hs_to_duel_list(value: CtosHsToDuelList) {
            pb_1.Message.setOneofWrapperField(this, 14, this.#one_of_decls[0], value);
        }
        get has_ctos_hs_to_duel_list() {
            return pb_1.Message.getField(this, 14) != null;
        }
        get msg() {
            const cases: {
                [index: number]: "none" | "ctos_player_info" | "ctos_join_game" | "ctos_update_deck" | "ctos_hs_ready" | "ctos_hs_start" | "ctos_hs_not_ready" | "ctos_hand_result" | "ctos_tp_result" | "ctos_time_confirm" | "ctos_response" | "ctos_chat" | "ctos_surrender" | "ctos_hs_to_observer" | "ctos_hs_to_duel_list";
            } = {
                0: "none",
                1: "ctos_player_info",
                2: "ctos_join_game",
                3: "ctos_update_deck",
                4: "ctos_hs_ready",
                5: "ctos_hs_start",
                6: "ctos_hs_not_ready",
                7: "ctos_hand_result",
                8: "ctos_tp_result",
                9: "ctos_time_confirm",
                10: "ctos_response",
                11: "ctos_chat",
                12: "ctos_surrender",
                13: "ctos_hs_to_observer",
                14: "ctos_hs_to_duel_list"
            };
            return cases[pb_1.Message.computeOneofCase(this, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14])];
        }
        static fromObject(data: {
            ctos_player_info?: ReturnType<typeof CtosPlayerInfo.prototype.toObject>;
            ctos_join_game?: ReturnType<typeof CtosJoinGame.prototype.toObject>;
            ctos_update_deck?: ReturnType<typeof CtosUpdateDeck.prototype.toObject>;
            ctos_hs_ready?: ReturnType<typeof CtosHsReady.prototype.toObject>;
            ctos_hs_start?: ReturnType<typeof CtosHsStart.prototype.toObject>;
            ctos_hs_not_ready?: ReturnType<typeof CtosHsNotReady.prototype.toObject>;
            ctos_hand_result?: ReturnType<typeof CtosHandResult.prototype.toObject>;
            ctos_tp_result?: ReturnType<typeof CtosTpResult.prototype.toObject>;
            ctos_time_confirm?: ReturnType<typeof CtosTimeConfirm.prototype.toObject>;
            ctos_response?: ReturnType<typeof CtosGameMsgResponse.prototype.toObject>;
            ctos_chat?: ReturnType<typeof CtosChat.prototype.toObject>;
            ctos_surrender?: ReturnType<typeof CtosSurrender.prototype.toObject>;
            ctos_hs_to_observer?: ReturnType<typeof CtosHsToObserver.prototype.toObject>;
            ctos_hs_to_duel_list?: ReturnType<typeof CtosHsToDuelList.prototype.toObject>;
        }): YgoCtosMsg {
            const message = new YgoCtosMsg({});
            if (data.ctos_player_info != null) {
                message.ctos_player_info = CtosPlayerInfo.fromObject(data.ctos_player_info);
            }
            if (data.ctos_join_game != null) {
                message.ctos_join_game = CtosJoinGame.fromObject(data.ctos_join_game);
            }
            if (data.ctos_update_deck != null) {
                message.ctos_update_deck = CtosUpdateDeck.fromObject(data.ctos_update_deck);
            }
            if (data.ctos_hs_ready != null) {
                message.ctos_hs_ready = CtosHsReady.fromObject(data.ctos_hs_ready);
            }
            if (data.ctos_hs_start != null) {
                message.ctos_hs_start = CtosHsStart.fromObject(data.ctos_hs_start);
            }
            if (data.ctos_hs_not_ready != null) {
                message.ctos_hs_not_ready = CtosHsNotReady.fromObject(data.ctos_hs_not_ready);
            }
            if (data.ctos_hand_result != null) {
                message.ctos_hand_result = CtosHandResult.fromObject(data.ctos_hand_result);
            }
            if (data.ctos_tp_result != null) {
                message.ctos_tp_result = CtosTpResult.fromObject(data.ctos_tp_result);
            }
            if (data.ctos_time_confirm != null) {
                message.ctos_time_confirm = CtosTimeConfirm.fromObject(data.ctos_time_confirm);
            }
            if (data.ctos_response != null) {
                message.ctos_response = CtosGameMsgResponse.fromObject(data.ctos_response);
            }
            if (data.ctos_chat != null) {
                message.ctos_chat = CtosChat.fromObject(data.ctos_chat);
            }
            if (data.ctos_surrender != null) {
                message.ctos_surrender = CtosSurrender.fromObject(data.ctos_surrender);
            }
            if (data.ctos_hs_to_observer != null) {
                message.ctos_hs_to_observer = CtosHsToObserver.fromObject(data.ctos_hs_to_observer);
            }
            if (data.ctos_hs_to_duel_list != null) {
                message.ctos_hs_to_duel_list = CtosHsToDuelList.fromObject(data.ctos_hs_to_duel_list);
            }
            return message;
        }
        toObject() {
            const data: {
                ctos_player_info?: ReturnType<typeof CtosPlayerInfo.prototype.toObject>;
                ctos_join_game?: ReturnType<typeof CtosJoinGame.prototype.toObject>;
                ctos_update_deck?: ReturnType<typeof CtosUpdateDeck.prototype.toObject>;
                ctos_hs_ready?: ReturnType<typeof CtosHsReady.prototype.toObject>;
                ctos_hs_start?: ReturnType<typeof CtosHsStart.prototype.toObject>;
                ctos_hs_not_ready?: ReturnType<typeof CtosHsNotReady.prototype.toObject>;
                ctos_hand_result?: ReturnType<typeof CtosHandResult.prototype.toObject>;
                ctos_tp_result?: ReturnType<typeof CtosTpResult.prototype.toObject>;
                ctos_time_confirm?: ReturnType<typeof CtosTimeConfirm.prototype.toObject>;
                ctos_response?: ReturnType<typeof CtosGameMsgResponse.prototype.toObject>;
                ctos_chat?: ReturnType<typeof CtosChat.prototype.toObject>;
                ctos_surrender?: ReturnType<typeof CtosSurrender.prototype.toObject>;
                ctos_hs_to_observer?: ReturnType<typeof CtosHsToObserver.prototype.toObject>;
                ctos_hs_to_duel_list?: ReturnType<typeof CtosHsToDuelList.prototype.toObject>;
            } = {};
            if (this.ctos_player_info != null) {
                data.ctos_player_info = this.ctos_player_info.toObject();
            }
            if (this.ctos_join_game != null) {
                data.ctos_join_game = this.ctos_join_game.toObject();
            }
            if (this.ctos_update_deck != null) {
                data.ctos_update_deck = this.ctos_update_deck.toObject();
            }
            if (this.ctos_hs_ready != null) {
                data.ctos_hs_ready = this.ctos_hs_ready.toObject();
            }
            if (this.ctos_hs_start != null) {
                data.ctos_hs_start = this.ctos_hs_start.toObject();
            }
            if (this.ctos_hs_not_ready != null) {
                data.ctos_hs_not_ready = this.ctos_hs_not_ready.toObject();
            }
            if (this.ctos_hand_result != null) {
                data.ctos_hand_result = this.ctos_hand_result.toObject();
            }
            if (this.ctos_tp_result != null) {
                data.ctos_tp_result = this.ctos_tp_result.toObject();
            }
            if (this.ctos_time_confirm != null) {
                data.ctos_time_confirm = this.ctos_time_confirm.toObject();
            }
            if (this.ctos_response != null) {
                data.ctos_response = this.ctos_response.toObject();
            }
            if (this.ctos_chat != null) {
                data.ctos_chat = this.ctos_chat.toObject();
            }
            if (this.ctos_surrender != null) {
                data.ctos_surrender = this.ctos_surrender.toObject();
            }
            if (this.ctos_hs_to_observer != null) {
                data.ctos_hs_to_observer = this.ctos_hs_to_observer.toObject();
            }
            if (this.ctos_hs_to_duel_list != null) {
                data.ctos_hs_to_duel_list = this.ctos_hs_to_duel_list.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_ctos_player_info)
                writer.writeMessage(1, this.ctos_player_info, () => this.ctos_player_info.serialize(writer));
            if (this.has_ctos_join_game)
                writer.writeMessage(2, this.ctos_join_game, () => this.ctos_join_game.serialize(writer));
            if (this.has_ctos_update_deck)
                writer.writeMessage(3, this.ctos_update_deck, () => this.ctos_update_deck.serialize(writer));
            if (this.has_ctos_hs_ready)
                writer.writeMessage(4, this.ctos_hs_ready, () => this.ctos_hs_ready.serialize(writer));
            if (this.has_ctos_hs_start)
                writer.writeMessage(5, this.ctos_hs_start, () => this.ctos_hs_start.serialize(writer));
            if (this.has_ctos_hs_not_ready)
                writer.writeMessage(6, this.ctos_hs_not_ready, () => this.ctos_hs_not_ready.serialize(writer));
            if (this.has_ctos_hand_result)
                writer.writeMessage(7, this.ctos_hand_result, () => this.ctos_hand_result.serialize(writer));
            if (this.has_ctos_tp_result)
                writer.writeMessage(8, this.ctos_tp_result, () => this.ctos_tp_result.serialize(writer));
            if (this.has_ctos_time_confirm)
                writer.writeMessage(9, this.ctos_time_confirm, () => this.ctos_time_confirm.serialize(writer));
            if (this.has_ctos_response)
                writer.writeMessage(10, this.ctos_response, () => this.ctos_response.serialize(writer));
            if (this.has_ctos_chat)
                writer.writeMessage(11, this.ctos_chat, () => this.ctos_chat.serialize(writer));
            if (this.has_ctos_surrender)
                writer.writeMessage(12, this.ctos_surrender, () => this.ctos_surrender.serialize(writer));
            if (this.has_ctos_hs_to_observer)
                writer.writeMessage(13, this.ctos_hs_to_observer, () => this.ctos_hs_to_observer.serialize(writer));
            if (this.has_ctos_hs_to_duel_list)
                writer.writeMessage(14, this.ctos_hs_to_duel_list, () => this.ctos_hs_to_duel_list.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): YgoCtosMsg {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new YgoCtosMsg();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.ctos_player_info, () => message.ctos_player_info = CtosPlayerInfo.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message.ctos_join_game, () => message.ctos_join_game = CtosJoinGame.deserialize(reader));
                        break;
                    case 3:
                        reader.readMessage(message.ctos_update_deck, () => message.ctos_update_deck = CtosUpdateDeck.deserialize(reader));
                        break;
                    case 4:
                        reader.readMessage(message.ctos_hs_ready, () => message.ctos_hs_ready = CtosHsReady.deserialize(reader));
                        break;
                    case 5:
                        reader.readMessage(message.ctos_hs_start, () => message.ctos_hs_start = CtosHsStart.deserialize(reader));
                        break;
                    case 6:
                        reader.readMessage(message.ctos_hs_not_ready, () => message.ctos_hs_not_ready = CtosHsNotReady.deserialize(reader));
                        break;
                    case 7:
                        reader.readMessage(message.ctos_hand_result, () => message.ctos_hand_result = CtosHandResult.deserialize(reader));
                        break;
                    case 8:
                        reader.readMessage(message.ctos_tp_result, () => message.ctos_tp_result = CtosTpResult.deserialize(reader));
                        break;
                    case 9:
                        reader.readMessage(message.ctos_time_confirm, () => message.ctos_time_confirm = CtosTimeConfirm.deserialize(reader));
                        break;
                    case 10:
                        reader.readMessage(message.ctos_response, () => message.ctos_response = CtosGameMsgResponse.deserialize(reader));
                        break;
                    case 11:
                        reader.readMessage(message.ctos_chat, () => message.ctos_chat = CtosChat.deserialize(reader));
                        break;
                    case 12:
                        reader.readMessage(message.ctos_surrender, () => message.ctos_surrender = CtosSurrender.deserialize(reader));
                        break;
                    case 13:
                        reader.readMessage(message.ctos_hs_to_observer, () => message.ctos_hs_to_observer = CtosHsToObserver.deserialize(reader));
                        break;
                    case 14:
                        reader.readMessage(message.ctos_hs_to_duel_list, () => message.ctos_hs_to_duel_list = CtosHsToDuelList.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): YgoCtosMsg {
            return YgoCtosMsg.deserialize(bytes);
        }
    }
    export class YgoStocMsg extends pb_1.Message {
        #one_of_decls: number[][] = [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17]];
        constructor(data?: any[] | ({} & (({
            stoc_join_game?: StocJoinGame;
            stoc_chat?: never;
            stoc_hs_player_enter?: never;
            stoc_type_change?: never;
            stoc_hs_player_change?: never;
            stoc_hs_watch_change?: never;
            stoc_select_hand?: never;
            stoc_hand_result?: never;
            stoc_select_tp?: never;
            stoc_deck_count?: never;
            stoc_duel_start?: never;
            stoc_game_msg?: never;
            stoc_time_limit?: never;
            stoc_error_msg?: never;
            stoc_change_side?: never;
            stoc_waiting_side?: never;
            stoc_duel_end?: never;
        } | {
            stoc_join_game?: never;
            stoc_chat?: StocChat;
            stoc_hs_player_enter?: never;
            stoc_type_change?: never;
            stoc_hs_player_change?: never;
            stoc_hs_watch_change?: never;
            stoc_select_hand?: never;
            stoc_hand_result?: never;
            stoc_select_tp?: never;
            stoc_deck_count?: never;
            stoc_duel_start?: never;
            stoc_game_msg?: never;
            stoc_time_limit?: never;
            stoc_error_msg?: never;
            stoc_change_side?: never;
            stoc_waiting_side?: never;
            stoc_duel_end?: never;
        } | {
            stoc_join_game?: never;
            stoc_chat?: never;
            stoc_hs_player_enter?: StocHsPlayerEnter;
            stoc_type_change?: never;
            stoc_hs_player_change?: never;
            stoc_hs_watch_change?: never;
            stoc_select_hand?: never;
            stoc_hand_result?: never;
            stoc_select_tp?: never;
            stoc_deck_count?: never;
            stoc_duel_start?: never;
            stoc_game_msg?: never;
            stoc_time_limit?: never;
            stoc_error_msg?: never;
            stoc_change_side?: never;
            stoc_waiting_side?: never;
            stoc_duel_end?: never;
        } | {
            stoc_join_game?: never;
            stoc_chat?: never;
            stoc_hs_player_enter?: never;
            stoc_type_change?: StocTypeChange;
            stoc_hs_player_change?: never;
            stoc_hs_watch_change?: never;
            stoc_select_hand?: never;
            stoc_hand_result?: never;
            stoc_select_tp?: never;
            stoc_deck_count?: never;
            stoc_duel_start?: never;
            stoc_game_msg?: never;
            stoc_time_limit?: never;
            stoc_error_msg?: never;
            stoc_change_side?: never;
            stoc_waiting_side?: never;
            stoc_duel_end?: never;
        } | {
            stoc_join_game?: never;
            stoc_chat?: never;
            stoc_hs_player_enter?: never;
            stoc_type_change?: never;
            stoc_hs_player_change?: StocHsPlayerChange;
            stoc_hs_watch_change?: never;
            stoc_select_hand?: never;
            stoc_hand_result?: never;
            stoc_select_tp?: never;
            stoc_deck_count?: never;
            stoc_duel_start?: never;
            stoc_game_msg?: never;
            stoc_time_limit?: never;
            stoc_error_msg?: never;
            stoc_change_side?: never;
            stoc_waiting_side?: never;
            stoc_duel_end?: never;
        } | {
            stoc_join_game?: never;
            stoc_chat?: never;
            stoc_hs_player_enter?: never;
            stoc_type_change?: never;
            stoc_hs_player_change?: never;
            stoc_hs_watch_change?: StocHsWatchChange;
            stoc_select_hand?: never;
            stoc_hand_result?: never;
            stoc_select_tp?: never;
            stoc_deck_count?: never;
            stoc_duel_start?: never;
            stoc_game_msg?: never;
            stoc_time_limit?: never;
            stoc_error_msg?: never;
            stoc_change_side?: never;
            stoc_waiting_side?: never;
            stoc_duel_end?: never;
        } | {
            stoc_join_game?: never;
            stoc_chat?: never;
            stoc_hs_player_enter?: never;
            stoc_type_change?: never;
            stoc_hs_player_change?: never;
            stoc_hs_watch_change?: never;
            stoc_select_hand?: StocSelectHand;
            stoc_hand_result?: never;
            stoc_select_tp?: never;
            stoc_deck_count?: never;
            stoc_duel_start?: never;
            stoc_game_msg?: never;
            stoc_time_limit?: never;
            stoc_error_msg?: never;
            stoc_change_side?: never;
            stoc_waiting_side?: never;
            stoc_duel_end?: never;
        } | {
            stoc_join_game?: never;
            stoc_chat?: never;
            stoc_hs_player_enter?: never;
            stoc_type_change?: never;
            stoc_hs_player_change?: never;
            stoc_hs_watch_change?: never;
            stoc_select_hand?: never;
            stoc_hand_result?: StocHandResult;
            stoc_select_tp?: never;
            stoc_deck_count?: never;
            stoc_duel_start?: never;
            stoc_game_msg?: never;
            stoc_time_limit?: never;
            stoc_error_msg?: never;
            stoc_change_side?: never;
            stoc_waiting_side?: never;
            stoc_duel_end?: never;
        } | {
            stoc_join_game?: never;
            stoc_chat?: never;
            stoc_hs_player_enter?: never;
            stoc_type_change?: never;
            stoc_hs_player_change?: never;
            stoc_hs_watch_change?: never;
            stoc_select_hand?: never;
            stoc_hand_result?: never;
            stoc_select_tp?: StocSelectTp;
            stoc_deck_count?: never;
            stoc_duel_start?: never;
            stoc_game_msg?: never;
            stoc_time_limit?: never;
            stoc_error_msg?: never;
            stoc_change_side?: never;
            stoc_waiting_side?: never;
            stoc_duel_end?: never;
        } | {
            stoc_join_game?: never;
            stoc_chat?: never;
            stoc_hs_player_enter?: never;
            stoc_type_change?: never;
            stoc_hs_player_change?: never;
            stoc_hs_watch_change?: never;
            stoc_select_hand?: never;
            stoc_hand_result?: never;
            stoc_select_tp?: never;
            stoc_deck_count?: StocDeckCount;
            stoc_duel_start?: never;
            stoc_game_msg?: never;
            stoc_time_limit?: never;
            stoc_error_msg?: never;
            stoc_change_side?: never;
            stoc_waiting_side?: never;
            stoc_duel_end?: never;
        } | {
            stoc_join_game?: never;
            stoc_chat?: never;
            stoc_hs_player_enter?: never;
            stoc_type_change?: never;
            stoc_hs_player_change?: never;
            stoc_hs_watch_change?: never;
            stoc_select_hand?: never;
            stoc_hand_result?: never;
            stoc_select_tp?: never;
            stoc_deck_count?: never;
            stoc_duel_start?: StocDuelStart;
            stoc_game_msg?: never;
            stoc_time_limit?: never;
            stoc_error_msg?: never;
            stoc_change_side?: never;
            stoc_waiting_side?: never;
            stoc_duel_end?: never;
        } | {
            stoc_join_game?: never;
            stoc_chat?: never;
            stoc_hs_player_enter?: never;
            stoc_type_change?: never;
            stoc_hs_player_change?: never;
            stoc_hs_watch_change?: never;
            stoc_select_hand?: never;
            stoc_hand_result?: never;
            stoc_select_tp?: never;
            stoc_deck_count?: never;
            stoc_duel_start?: never;
            stoc_game_msg?: StocGameMessage;
            stoc_time_limit?: never;
            stoc_error_msg?: never;
            stoc_change_side?: never;
            stoc_waiting_side?: never;
            stoc_duel_end?: never;
        } | {
            stoc_join_game?: never;
            stoc_chat?: never;
            stoc_hs_player_enter?: never;
            stoc_type_change?: never;
            stoc_hs_player_change?: never;
            stoc_hs_watch_change?: never;
            stoc_select_hand?: never;
            stoc_hand_result?: never;
            stoc_select_tp?: never;
            stoc_deck_count?: never;
            stoc_duel_start?: never;
            stoc_game_msg?: never;
            stoc_time_limit?: StocTimeLimit;
            stoc_error_msg?: never;
            stoc_change_side?: never;
            stoc_waiting_side?: never;
            stoc_duel_end?: never;
        } | {
            stoc_join_game?: never;
            stoc_chat?: never;
            stoc_hs_player_enter?: never;
            stoc_type_change?: never;
            stoc_hs_player_change?: never;
            stoc_hs_watch_change?: never;
            stoc_select_hand?: never;
            stoc_hand_result?: never;
            stoc_select_tp?: never;
            stoc_deck_count?: never;
            stoc_duel_start?: never;
            stoc_game_msg?: never;
            stoc_time_limit?: never;
            stoc_error_msg?: StocErrorMsg;
            stoc_change_side?: never;
            stoc_waiting_side?: never;
            stoc_duel_end?: never;
        } | {
            stoc_join_game?: never;
            stoc_chat?: never;
            stoc_hs_player_enter?: never;
            stoc_type_change?: never;
            stoc_hs_player_change?: never;
            stoc_hs_watch_change?: never;
            stoc_select_hand?: never;
            stoc_hand_result?: never;
            stoc_select_tp?: never;
            stoc_deck_count?: never;
            stoc_duel_start?: never;
            stoc_game_msg?: never;
            stoc_time_limit?: never;
            stoc_error_msg?: never;
            stoc_change_side?: StocChangeSide;
            stoc_waiting_side?: never;
            stoc_duel_end?: never;
        } | {
            stoc_join_game?: never;
            stoc_chat?: never;
            stoc_hs_player_enter?: never;
            stoc_type_change?: never;
            stoc_hs_player_change?: never;
            stoc_hs_watch_change?: never;
            stoc_select_hand?: never;
            stoc_hand_result?: never;
            stoc_select_tp?: never;
            stoc_deck_count?: never;
            stoc_duel_start?: never;
            stoc_game_msg?: never;
            stoc_time_limit?: never;
            stoc_error_msg?: never;
            stoc_change_side?: never;
            stoc_waiting_side?: StocWaitingSide;
            stoc_duel_end?: never;
        } | {
            stoc_join_game?: never;
            stoc_chat?: never;
            stoc_hs_player_enter?: never;
            stoc_type_change?: never;
            stoc_hs_player_change?: never;
            stoc_hs_watch_change?: never;
            stoc_select_hand?: never;
            stoc_hand_result?: never;
            stoc_select_tp?: never;
            stoc_deck_count?: never;
            stoc_duel_start?: never;
            stoc_game_msg?: never;
            stoc_time_limit?: never;
            stoc_error_msg?: never;
            stoc_change_side?: never;
            stoc_waiting_side?: never;
            stoc_duel_end?: StocDuelEnd;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("stoc_join_game" in data && data.stoc_join_game != undefined) {
                    this.stoc_join_game = data.stoc_join_game;
                }
                if ("stoc_chat" in data && data.stoc_chat != undefined) {
                    this.stoc_chat = data.stoc_chat;
                }
                if ("stoc_hs_player_enter" in data && data.stoc_hs_player_enter != undefined) {
                    this.stoc_hs_player_enter = data.stoc_hs_player_enter;
                }
                if ("stoc_type_change" in data && data.stoc_type_change != undefined) {
                    this.stoc_type_change = data.stoc_type_change;
                }
                if ("stoc_hs_player_change" in data && data.stoc_hs_player_change != undefined) {
                    this.stoc_hs_player_change = data.stoc_hs_player_change;
                }
                if ("stoc_hs_watch_change" in data && data.stoc_hs_watch_change != undefined) {
                    this.stoc_hs_watch_change = data.stoc_hs_watch_change;
                }
                if ("stoc_select_hand" in data && data.stoc_select_hand != undefined) {
                    this.stoc_select_hand = data.stoc_select_hand;
                }
                if ("stoc_hand_result" in data && data.stoc_hand_result != undefined) {
                    this.stoc_hand_result = data.stoc_hand_result;
                }
                if ("stoc_select_tp" in data && data.stoc_select_tp != undefined) {
                    this.stoc_select_tp = data.stoc_select_tp;
                }
                if ("stoc_deck_count" in data && data.stoc_deck_count != undefined) {
                    this.stoc_deck_count = data.stoc_deck_count;
                }
                if ("stoc_duel_start" in data && data.stoc_duel_start != undefined) {
                    this.stoc_duel_start = data.stoc_duel_start;
                }
                if ("stoc_game_msg" in data && data.stoc_game_msg != undefined) {
                    this.stoc_game_msg = data.stoc_game_msg;
                }
                if ("stoc_time_limit" in data && data.stoc_time_limit != undefined) {
                    this.stoc_time_limit = data.stoc_time_limit;
                }
                if ("stoc_error_msg" in data && data.stoc_error_msg != undefined) {
                    this.stoc_error_msg = data.stoc_error_msg;
                }
                if ("stoc_change_side" in data && data.stoc_change_side != undefined) {
                    this.stoc_change_side = data.stoc_change_side;
                }
                if ("stoc_waiting_side" in data && data.stoc_waiting_side != undefined) {
                    this.stoc_waiting_side = data.stoc_waiting_side;
                }
                if ("stoc_duel_end" in data && data.stoc_duel_end != undefined) {
                    this.stoc_duel_end = data.stoc_duel_end;
                }
            }
        }
        get stoc_join_game() {
            return pb_1.Message.getWrapperField(this, StocJoinGame, 1) as StocJoinGame;
        }
        set stoc_join_game(value: StocJoinGame) {
            pb_1.Message.setOneofWrapperField(this, 1, this.#one_of_decls[0], value);
        }
        get has_stoc_join_game() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get stoc_chat() {
            return pb_1.Message.getWrapperField(this, StocChat, 2) as StocChat;
        }
        set stoc_chat(value: StocChat) {
            pb_1.Message.setOneofWrapperField(this, 2, this.#one_of_decls[0], value);
        }
        get has_stoc_chat() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get stoc_hs_player_enter() {
            return pb_1.Message.getWrapperField(this, StocHsPlayerEnter, 3) as StocHsPlayerEnter;
        }
        set stoc_hs_player_enter(value: StocHsPlayerEnter) {
            pb_1.Message.setOneofWrapperField(this, 3, this.#one_of_decls[0], value);
        }
        get has_stoc_hs_player_enter() {
            return pb_1.Message.getField(this, 3) != null;
        }
        get stoc_type_change() {
            return pb_1.Message.getWrapperField(this, StocTypeChange, 4) as StocTypeChange;
        }
        set stoc_type_change(value: StocTypeChange) {
            pb_1.Message.setOneofWrapperField(this, 4, this.#one_of_decls[0], value);
        }
        get has_stoc_type_change() {
            return pb_1.Message.getField(this, 4) != null;
        }
        get stoc_hs_player_change() {
            return pb_1.Message.getWrapperField(this, StocHsPlayerChange, 5) as StocHsPlayerChange;
        }
        set stoc_hs_player_change(value: StocHsPlayerChange) {
            pb_1.Message.setOneofWrapperField(this, 5, this.#one_of_decls[0], value);
        }
        get has_stoc_hs_player_change() {
            return pb_1.Message.getField(this, 5) != null;
        }
        get stoc_hs_watch_change() {
            return pb_1.Message.getWrapperField(this, StocHsWatchChange, 6) as StocHsWatchChange;
        }
        set stoc_hs_watch_change(value: StocHsWatchChange) {
            pb_1.Message.setOneofWrapperField(this, 6, this.#one_of_decls[0], value);
        }
        get has_stoc_hs_watch_change() {
            return pb_1.Message.getField(this, 6) != null;
        }
        get stoc_select_hand() {
            return pb_1.Message.getWrapperField(this, StocSelectHand, 7) as StocSelectHand;
        }
        set stoc_select_hand(value: StocSelectHand) {
            pb_1.Message.setOneofWrapperField(this, 7, this.#one_of_decls[0], value);
        }
        get has_stoc_select_hand() {
            return pb_1.Message.getField(this, 7) != null;
        }
        get stoc_hand_result() {
            return pb_1.Message.getWrapperField(this, StocHandResult, 8) as StocHandResult;
        }
        set stoc_hand_result(value: StocHandResult) {
            pb_1.Message.setOneofWrapperField(this, 8, this.#one_of_decls[0], value);
        }
        get has_stoc_hand_result() {
            return pb_1.Message.getField(this, 8) != null;
        }
        get stoc_select_tp() {
            return pb_1.Message.getWrapperField(this, StocSelectTp, 9) as StocSelectTp;
        }
        set stoc_select_tp(value: StocSelectTp) {
            pb_1.Message.setOneofWrapperField(this, 9, this.#one_of_decls[0], value);
        }
        get has_stoc_select_tp() {
            return pb_1.Message.getField(this, 9) != null;
        }
        get stoc_deck_count() {
            return pb_1.Message.getWrapperField(this, StocDeckCount, 10) as StocDeckCount;
        }
        set stoc_deck_count(value: StocDeckCount) {
            pb_1.Message.setOneofWrapperField(this, 10, this.#one_of_decls[0], value);
        }
        get has_stoc_deck_count() {
            return pb_1.Message.getField(this, 10) != null;
        }
        get stoc_duel_start() {
            return pb_1.Message.getWrapperField(this, StocDuelStart, 11) as StocDuelStart;
        }
        set stoc_duel_start(value: StocDuelStart) {
            pb_1.Message.setOneofWrapperField(this, 11, this.#one_of_decls[0], value);
        }
        get has_stoc_duel_start() {
            return pb_1.Message.getField(this, 11) != null;
        }
        get stoc_game_msg() {
            return pb_1.Message.getWrapperField(this, StocGameMessage, 12) as StocGameMessage;
        }
        set stoc_game_msg(value: StocGameMessage) {
            pb_1.Message.setOneofWrapperField(this, 12, this.#one_of_decls[0], value);
        }
        get has_stoc_game_msg() {
            return pb_1.Message.getField(this, 12) != null;
        }
        get stoc_time_limit() {
            return pb_1.Message.getWrapperField(this, StocTimeLimit, 13) as StocTimeLimit;
        }
        set stoc_time_limit(value: StocTimeLimit) {
            pb_1.Message.setOneofWrapperField(this, 13, this.#one_of_decls[0], value);
        }
        get has_stoc_time_limit() {
            return pb_1.Message.getField(this, 13) != null;
        }
        get stoc_error_msg() {
            return pb_1.Message.getWrapperField(this, StocErrorMsg, 14) as StocErrorMsg;
        }
        set stoc_error_msg(value: StocErrorMsg) {
            pb_1.Message.setOneofWrapperField(this, 14, this.#one_of_decls[0], value);
        }
        get has_stoc_error_msg() {
            return pb_1.Message.getField(this, 14) != null;
        }
        get stoc_change_side() {
            return pb_1.Message.getWrapperField(this, StocChangeSide, 15) as StocChangeSide;
        }
        set stoc_change_side(value: StocChangeSide) {
            pb_1.Message.setOneofWrapperField(this, 15, this.#one_of_decls[0], value);
        }
        get has_stoc_change_side() {
            return pb_1.Message.getField(this, 15) != null;
        }
        get stoc_waiting_side() {
            return pb_1.Message.getWrapperField(this, StocWaitingSide, 16) as StocWaitingSide;
        }
        set stoc_waiting_side(value: StocWaitingSide) {
            pb_1.Message.setOneofWrapperField(this, 16, this.#one_of_decls[0], value);
        }
        get has_stoc_waiting_side() {
            return pb_1.Message.getField(this, 16) != null;
        }
        get stoc_duel_end() {
            return pb_1.Message.getWrapperField(this, StocDuelEnd, 17) as StocDuelEnd;
        }
        set stoc_duel_end(value: StocDuelEnd) {
            pb_1.Message.setOneofWrapperField(this, 17, this.#one_of_decls[0], value);
        }
        get has_stoc_duel_end() {
            return pb_1.Message.getField(this, 17) != null;
        }
        get msg() {
            const cases: {
                [index: number]: "none" | "stoc_join_game" | "stoc_chat" | "stoc_hs_player_enter" | "stoc_type_change" | "stoc_hs_player_change" | "stoc_hs_watch_change" | "stoc_select_hand" | "stoc_hand_result" | "stoc_select_tp" | "stoc_deck_count" | "stoc_duel_start" | "stoc_game_msg" | "stoc_time_limit" | "stoc_error_msg" | "stoc_change_side" | "stoc_waiting_side" | "stoc_duel_end";
            } = {
                0: "none",
                1: "stoc_join_game",
                2: "stoc_chat",
                3: "stoc_hs_player_enter",
                4: "stoc_type_change",
                5: "stoc_hs_player_change",
                6: "stoc_hs_watch_change",
                7: "stoc_select_hand",
                8: "stoc_hand_result",
                9: "stoc_select_tp",
                10: "stoc_deck_count",
                11: "stoc_duel_start",
                12: "stoc_game_msg",
                13: "stoc_time_limit",
                14: "stoc_error_msg",
                15: "stoc_change_side",
                16: "stoc_waiting_side",
                17: "stoc_duel_end"
            };
            return cases[pb_1.Message.computeOneofCase(this, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17])];
        }
        static fromObject(data: {
            stoc_join_game?: ReturnType<typeof StocJoinGame.prototype.toObject>;
            stoc_chat?: ReturnType<typeof StocChat.prototype.toObject>;
            stoc_hs_player_enter?: ReturnType<typeof StocHsPlayerEnter.prototype.toObject>;
            stoc_type_change?: ReturnType<typeof StocTypeChange.prototype.toObject>;
            stoc_hs_player_change?: ReturnType<typeof StocHsPlayerChange.prototype.toObject>;
            stoc_hs_watch_change?: ReturnType<typeof StocHsWatchChange.prototype.toObject>;
            stoc_select_hand?: ReturnType<typeof StocSelectHand.prototype.toObject>;
            stoc_hand_result?: ReturnType<typeof StocHandResult.prototype.toObject>;
            stoc_select_tp?: ReturnType<typeof StocSelectTp.prototype.toObject>;
            stoc_deck_count?: ReturnType<typeof StocDeckCount.prototype.toObject>;
            stoc_duel_start?: ReturnType<typeof StocDuelStart.prototype.toObject>;
            stoc_game_msg?: ReturnType<typeof StocGameMessage.prototype.toObject>;
            stoc_time_limit?: ReturnType<typeof StocTimeLimit.prototype.toObject>;
            stoc_error_msg?: ReturnType<typeof StocErrorMsg.prototype.toObject>;
            stoc_change_side?: ReturnType<typeof StocChangeSide.prototype.toObject>;
            stoc_waiting_side?: ReturnType<typeof StocWaitingSide.prototype.toObject>;
            stoc_duel_end?: ReturnType<typeof StocDuelEnd.prototype.toObject>;
        }): YgoStocMsg {
            const message = new YgoStocMsg({});
            if (data.stoc_join_game != null) {
                message.stoc_join_game = StocJoinGame.fromObject(data.stoc_join_game);
            }
            if (data.stoc_chat != null) {
                message.stoc_chat = StocChat.fromObject(data.stoc_chat);
            }
            if (data.stoc_hs_player_enter != null) {
                message.stoc_hs_player_enter = StocHsPlayerEnter.fromObject(data.stoc_hs_player_enter);
            }
            if (data.stoc_type_change != null) {
                message.stoc_type_change = StocTypeChange.fromObject(data.stoc_type_change);
            }
            if (data.stoc_hs_player_change != null) {
                message.stoc_hs_player_change = StocHsPlayerChange.fromObject(data.stoc_hs_player_change);
            }
            if (data.stoc_hs_watch_change != null) {
                message.stoc_hs_watch_change = StocHsWatchChange.fromObject(data.stoc_hs_watch_change);
            }
            if (data.stoc_select_hand != null) {
                message.stoc_select_hand = StocSelectHand.fromObject(data.stoc_select_hand);
            }
            if (data.stoc_hand_result != null) {
                message.stoc_hand_result = StocHandResult.fromObject(data.stoc_hand_result);
            }
            if (data.stoc_select_tp != null) {
                message.stoc_select_tp = StocSelectTp.fromObject(data.stoc_select_tp);
            }
            if (data.stoc_deck_count != null) {
                message.stoc_deck_count = StocDeckCount.fromObject(data.stoc_deck_count);
            }
            if (data.stoc_duel_start != null) {
                message.stoc_duel_start = StocDuelStart.fromObject(data.stoc_duel_start);
            }
            if (data.stoc_game_msg != null) {
                message.stoc_game_msg = StocGameMessage.fromObject(data.stoc_game_msg);
            }
            if (data.stoc_time_limit != null) {
                message.stoc_time_limit = StocTimeLimit.fromObject(data.stoc_time_limit);
            }
            if (data.stoc_error_msg != null) {
                message.stoc_error_msg = StocErrorMsg.fromObject(data.stoc_error_msg);
            }
            if (data.stoc_change_side != null) {
                message.stoc_change_side = StocChangeSide.fromObject(data.stoc_change_side);
            }
            if (data.stoc_waiting_side != null) {
                message.stoc_waiting_side = StocWaitingSide.fromObject(data.stoc_waiting_side);
            }
            if (data.stoc_duel_end != null) {
                message.stoc_duel_end = StocDuelEnd.fromObject(data.stoc_duel_end);
            }
            return message;
        }
        toObject() {
            const data: {
                stoc_join_game?: ReturnType<typeof StocJoinGame.prototype.toObject>;
                stoc_chat?: ReturnType<typeof StocChat.prototype.toObject>;
                stoc_hs_player_enter?: ReturnType<typeof StocHsPlayerEnter.prototype.toObject>;
                stoc_type_change?: ReturnType<typeof StocTypeChange.prototype.toObject>;
                stoc_hs_player_change?: ReturnType<typeof StocHsPlayerChange.prototype.toObject>;
                stoc_hs_watch_change?: ReturnType<typeof StocHsWatchChange.prototype.toObject>;
                stoc_select_hand?: ReturnType<typeof StocSelectHand.prototype.toObject>;
                stoc_hand_result?: ReturnType<typeof StocHandResult.prototype.toObject>;
                stoc_select_tp?: ReturnType<typeof StocSelectTp.prototype.toObject>;
                stoc_deck_count?: ReturnType<typeof StocDeckCount.prototype.toObject>;
                stoc_duel_start?: ReturnType<typeof StocDuelStart.prototype.toObject>;
                stoc_game_msg?: ReturnType<typeof StocGameMessage.prototype.toObject>;
                stoc_time_limit?: ReturnType<typeof StocTimeLimit.prototype.toObject>;
                stoc_error_msg?: ReturnType<typeof StocErrorMsg.prototype.toObject>;
                stoc_change_side?: ReturnType<typeof StocChangeSide.prototype.toObject>;
                stoc_waiting_side?: ReturnType<typeof StocWaitingSide.prototype.toObject>;
                stoc_duel_end?: ReturnType<typeof StocDuelEnd.prototype.toObject>;
            } = {};
            if (this.stoc_join_game != null) {
                data.stoc_join_game = this.stoc_join_game.toObject();
            }
            if (this.stoc_chat != null) {
                data.stoc_chat = this.stoc_chat.toObject();
            }
            if (this.stoc_hs_player_enter != null) {
                data.stoc_hs_player_enter = this.stoc_hs_player_enter.toObject();
            }
            if (this.stoc_type_change != null) {
                data.stoc_type_change = this.stoc_type_change.toObject();
            }
            if (this.stoc_hs_player_change != null) {
                data.stoc_hs_player_change = this.stoc_hs_player_change.toObject();
            }
            if (this.stoc_hs_watch_change != null) {
                data.stoc_hs_watch_change = this.stoc_hs_watch_change.toObject();
            }
            if (this.stoc_select_hand != null) {
                data.stoc_select_hand = this.stoc_select_hand.toObject();
            }
            if (this.stoc_hand_result != null) {
                data.stoc_hand_result = this.stoc_hand_result.toObject();
            }
            if (this.stoc_select_tp != null) {
                data.stoc_select_tp = this.stoc_select_tp.toObject();
            }
            if (this.stoc_deck_count != null) {
                data.stoc_deck_count = this.stoc_deck_count.toObject();
            }
            if (this.stoc_duel_start != null) {
                data.stoc_duel_start = this.stoc_duel_start.toObject();
            }
            if (this.stoc_game_msg != null) {
                data.stoc_game_msg = this.stoc_game_msg.toObject();
            }
            if (this.stoc_time_limit != null) {
                data.stoc_time_limit = this.stoc_time_limit.toObject();
            }
            if (this.stoc_error_msg != null) {
                data.stoc_error_msg = this.stoc_error_msg.toObject();
            }
            if (this.stoc_change_side != null) {
                data.stoc_change_side = this.stoc_change_side.toObject();
            }
            if (this.stoc_waiting_side != null) {
                data.stoc_waiting_side = this.stoc_waiting_side.toObject();
            }
            if (this.stoc_duel_end != null) {
                data.stoc_duel_end = this.stoc_duel_end.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_stoc_join_game)
                writer.writeMessage(1, this.stoc_join_game, () => this.stoc_join_game.serialize(writer));
            if (this.has_stoc_chat)
                writer.writeMessage(2, this.stoc_chat, () => this.stoc_chat.serialize(writer));
            if (this.has_stoc_hs_player_enter)
                writer.writeMessage(3, this.stoc_hs_player_enter, () => this.stoc_hs_player_enter.serialize(writer));
            if (this.has_stoc_type_change)
                writer.writeMessage(4, this.stoc_type_change, () => this.stoc_type_change.serialize(writer));
            if (this.has_stoc_hs_player_change)
                writer.writeMessage(5, this.stoc_hs_player_change, () => this.stoc_hs_player_change.serialize(writer));
            if (this.has_stoc_hs_watch_change)
                writer.writeMessage(6, this.stoc_hs_watch_change, () => this.stoc_hs_watch_change.serialize(writer));
            if (this.has_stoc_select_hand)
                writer.writeMessage(7, this.stoc_select_hand, () => this.stoc_select_hand.serialize(writer));
            if (this.has_stoc_hand_result)
                writer.writeMessage(8, this.stoc_hand_result, () => this.stoc_hand_result.serialize(writer));
            if (this.has_stoc_select_tp)
                writer.writeMessage(9, this.stoc_select_tp, () => this.stoc_select_tp.serialize(writer));
            if (this.has_stoc_deck_count)
                writer.writeMessage(10, this.stoc_deck_count, () => this.stoc_deck_count.serialize(writer));
            if (this.has_stoc_duel_start)
                writer.writeMessage(11, this.stoc_duel_start, () => this.stoc_duel_start.serialize(writer));
            if (this.has_stoc_game_msg)
                writer.writeMessage(12, this.stoc_game_msg, () => this.stoc_game_msg.serialize(writer));
            if (this.has_stoc_time_limit)
                writer.writeMessage(13, this.stoc_time_limit, () => this.stoc_time_limit.serialize(writer));
            if (this.has_stoc_error_msg)
                writer.writeMessage(14, this.stoc_error_msg, () => this.stoc_error_msg.serialize(writer));
            if (this.has_stoc_change_side)
                writer.writeMessage(15, this.stoc_change_side, () => this.stoc_change_side.serialize(writer));
            if (this.has_stoc_waiting_side)
                writer.writeMessage(16, this.stoc_waiting_side, () => this.stoc_waiting_side.serialize(writer));
            if (this.has_stoc_duel_end)
                writer.writeMessage(17, this.stoc_duel_end, () => this.stoc_duel_end.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): YgoStocMsg {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new YgoStocMsg();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.stoc_join_game, () => message.stoc_join_game = StocJoinGame.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message.stoc_chat, () => message.stoc_chat = StocChat.deserialize(reader));
                        break;
                    case 3:
                        reader.readMessage(message.stoc_hs_player_enter, () => message.stoc_hs_player_enter = StocHsPlayerEnter.deserialize(reader));
                        break;
                    case 4:
                        reader.readMessage(message.stoc_type_change, () => message.stoc_type_change = StocTypeChange.deserialize(reader));
                        break;
                    case 5:
                        reader.readMessage(message.stoc_hs_player_change, () => message.stoc_hs_player_change = StocHsPlayerChange.deserialize(reader));
                        break;
                    case 6:
                        reader.readMessage(message.stoc_hs_watch_change, () => message.stoc_hs_watch_change = StocHsWatchChange.deserialize(reader));
                        break;
                    case 7:
                        reader.readMessage(message.stoc_select_hand, () => message.stoc_select_hand = StocSelectHand.deserialize(reader));
                        break;
                    case 8:
                        reader.readMessage(message.stoc_hand_result, () => message.stoc_hand_result = StocHandResult.deserialize(reader));
                        break;
                    case 9:
                        reader.readMessage(message.stoc_select_tp, () => message.stoc_select_tp = StocSelectTp.deserialize(reader));
                        break;
                    case 10:
                        reader.readMessage(message.stoc_deck_count, () => message.stoc_deck_count = StocDeckCount.deserialize(reader));
                        break;
                    case 11:
                        reader.readMessage(message.stoc_duel_start, () => message.stoc_duel_start = StocDuelStart.deserialize(reader));
                        break;
                    case 12:
                        reader.readMessage(message.stoc_game_msg, () => message.stoc_game_msg = StocGameMessage.deserialize(reader));
                        break;
                    case 13:
                        reader.readMessage(message.stoc_time_limit, () => message.stoc_time_limit = StocTimeLimit.deserialize(reader));
                        break;
                    case 14:
                        reader.readMessage(message.stoc_error_msg, () => message.stoc_error_msg = StocErrorMsg.deserialize(reader));
                        break;
                    case 15:
                        reader.readMessage(message.stoc_change_side, () => message.stoc_change_side = StocChangeSide.deserialize(reader));
                        break;
                    case 16:
                        reader.readMessage(message.stoc_waiting_side, () => message.stoc_waiting_side = StocWaitingSide.deserialize(reader));
                        break;
                    case 17:
                        reader.readMessage(message.stoc_duel_end, () => message.stoc_duel_end = StocDuelEnd.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): YgoStocMsg {
            return YgoStocMsg.deserialize(bytes);
        }
    }
    export class CtosPlayerInfo extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            name?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("name" in data && data.name != undefined) {
                    this.name = data.name;
                }
            }
        }
        get name() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set name(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            name?: string;
        }): CtosPlayerInfo {
            const message = new CtosPlayerInfo({});
            if (data.name != null) {
                message.name = data.name;
            }
            return message;
        }
        toObject() {
            const data: {
                name?: string;
            } = {};
            if (this.name != null) {
                data.name = this.name;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.name.length)
                writer.writeString(1, this.name);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): CtosPlayerInfo {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new CtosPlayerInfo();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.name = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): CtosPlayerInfo {
            return CtosPlayerInfo.deserialize(bytes);
        }
    }
    export class CtosJoinGame extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            version?: number;
            gameid?: number;
            passwd?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("version" in data && data.version != undefined) {
                    this.version = data.version;
                }
                if ("gameid" in data && data.gameid != undefined) {
                    this.gameid = data.gameid;
                }
                if ("passwd" in data && data.passwd != undefined) {
                    this.passwd = data.passwd;
                }
            }
        }
        get version() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set version(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get gameid() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set gameid(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get passwd() {
            return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
        }
        set passwd(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            version?: number;
            gameid?: number;
            passwd?: string;
        }): CtosJoinGame {
            const message = new CtosJoinGame({});
            if (data.version != null) {
                message.version = data.version;
            }
            if (data.gameid != null) {
                message.gameid = data.gameid;
            }
            if (data.passwd != null) {
                message.passwd = data.passwd;
            }
            return message;
        }
        toObject() {
            const data: {
                version?: number;
                gameid?: number;
                passwd?: string;
            } = {};
            if (this.version != null) {
                data.version = this.version;
            }
            if (this.gameid != null) {
                data.gameid = this.gameid;
            }
            if (this.passwd != null) {
                data.passwd = this.passwd;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.version != 0)
                writer.writeInt32(1, this.version);
            if (this.gameid != 0)
                writer.writeInt32(2, this.gameid);
            if (this.passwd.length)
                writer.writeString(3, this.passwd);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): CtosJoinGame {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new CtosJoinGame();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.version = reader.readInt32();
                        break;
                    case 2:
                        message.gameid = reader.readInt32();
                        break;
                    case 3:
                        message.passwd = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): CtosJoinGame {
            return CtosJoinGame.deserialize(bytes);
        }
    }
    export class CtosUpdateDeck extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            main?: number[];
            extra?: number[];
            side?: number[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1, 2, 3], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("main" in data && data.main != undefined) {
                    this.main = data.main;
                }
                if ("extra" in data && data.extra != undefined) {
                    this.extra = data.extra;
                }
                if ("side" in data && data.side != undefined) {
                    this.side = data.side;
                }
            }
        }
        get main() {
            return pb_1.Message.getFieldWithDefault(this, 1, []) as number[];
        }
        set main(value: number[]) {
            pb_1.Message.setField(this, 1, value);
        }
        get extra() {
            return pb_1.Message.getFieldWithDefault(this, 2, []) as number[];
        }
        set extra(value: number[]) {
            pb_1.Message.setField(this, 2, value);
        }
        get side() {
            return pb_1.Message.getFieldWithDefault(this, 3, []) as number[];
        }
        set side(value: number[]) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            main?: number[];
            extra?: number[];
            side?: number[];
        }): CtosUpdateDeck {
            const message = new CtosUpdateDeck({});
            if (data.main != null) {
                message.main = data.main;
            }
            if (data.extra != null) {
                message.extra = data.extra;
            }
            if (data.side != null) {
                message.side = data.side;
            }
            return message;
        }
        toObject() {
            const data: {
                main?: number[];
                extra?: number[];
                side?: number[];
            } = {};
            if (this.main != null) {
                data.main = this.main;
            }
            if (this.extra != null) {
                data.extra = this.extra;
            }
            if (this.side != null) {
                data.side = this.side;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.main.length)
                writer.writePackedInt32(1, this.main);
            if (this.extra.length)
                writer.writePackedInt32(2, this.extra);
            if (this.side.length)
                writer.writePackedInt32(3, this.side);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): CtosUpdateDeck {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new CtosUpdateDeck();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.main = reader.readPackedInt32();
                        break;
                    case 2:
                        message.extra = reader.readPackedInt32();
                        break;
                    case 3:
                        message.side = reader.readPackedInt32();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): CtosUpdateDeck {
            return CtosUpdateDeck.deserialize(bytes);
        }
    }
    export class CtosHsReady extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {}) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") { }
        }
        static fromObject(data: {}): CtosHsReady {
            const message = new CtosHsReady({});
            return message;
        }
        toObject() {
            const data: {} = {};
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): CtosHsReady {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new CtosHsReady();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): CtosHsReady {
            return CtosHsReady.deserialize(bytes);
        }
    }
    export class CtosHsNotReady extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {}) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") { }
        }
        static fromObject(data: {}): CtosHsNotReady {
            const message = new CtosHsNotReady({});
            return message;
        }
        toObject() {
            const data: {} = {};
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): CtosHsNotReady {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new CtosHsNotReady();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): CtosHsNotReady {
            return CtosHsNotReady.deserialize(bytes);
        }
    }
    export class CtosHsToObserver extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {}) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") { }
        }
        static fromObject(data: {}): CtosHsToObserver {
            const message = new CtosHsToObserver({});
            return message;
        }
        toObject() {
            const data: {} = {};
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): CtosHsToObserver {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new CtosHsToObserver();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): CtosHsToObserver {
            return CtosHsToObserver.deserialize(bytes);
        }
    }
    export class CtosHsToDuelList extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {}) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") { }
        }
        static fromObject(data: {}): CtosHsToDuelList {
            const message = new CtosHsToDuelList({});
            return message;
        }
        toObject() {
            const data: {} = {};
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): CtosHsToDuelList {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new CtosHsToDuelList();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): CtosHsToDuelList {
            return CtosHsToDuelList.deserialize(bytes);
        }
    }
    export class CtosHsStart extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {}) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") { }
        }
        static fromObject(data: {}): CtosHsStart {
            const message = new CtosHsStart({});
            return message;
        }
        toObject() {
            const data: {} = {};
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): CtosHsStart {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new CtosHsStart();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): CtosHsStart {
            return CtosHsStart.deserialize(bytes);
        }
    }
    export class CtosHandResult extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            hand?: HandType;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("hand" in data && data.hand != undefined) {
                    this.hand = data.hand;
                }
            }
        }
        get hand() {
            return pb_1.Message.getFieldWithDefault(this, 1, HandType.UNKNOWN) as HandType;
        }
        set hand(value: HandType) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            hand?: HandType;
        }): CtosHandResult {
            const message = new CtosHandResult({});
            if (data.hand != null) {
                message.hand = data.hand;
            }
            return message;
        }
        toObject() {
            const data: {
                hand?: HandType;
            } = {};
            if (this.hand != null) {
                data.hand = this.hand;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.hand != HandType.UNKNOWN)
                writer.writeEnum(1, this.hand);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): CtosHandResult {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new CtosHandResult();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.hand = reader.readEnum();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): CtosHandResult {
            return CtosHandResult.deserialize(bytes);
        }
    }
    export class CtosTpResult extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            tp?: CtosTpResult.TpType;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("tp" in data && data.tp != undefined) {
                    this.tp = data.tp;
                }
            }
        }
        get tp() {
            return pb_1.Message.getFieldWithDefault(this, 1, CtosTpResult.TpType.UNKNOWN) as CtosTpResult.TpType;
        }
        set tp(value: CtosTpResult.TpType) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            tp?: CtosTpResult.TpType;
        }): CtosTpResult {
            const message = new CtosTpResult({});
            if (data.tp != null) {
                message.tp = data.tp;
            }
            return message;
        }
        toObject() {
            const data: {
                tp?: CtosTpResult.TpType;
            } = {};
            if (this.tp != null) {
                data.tp = this.tp;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.tp != CtosTpResult.TpType.UNKNOWN)
                writer.writeEnum(1, this.tp);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): CtosTpResult {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new CtosTpResult();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.tp = reader.readEnum();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): CtosTpResult {
            return CtosTpResult.deserialize(bytes);
        }
    }
    export namespace CtosTpResult {
        export enum TpType {
            UNKNOWN = 0,
            FIRST = 1,
            SECOND = 2
        }
    }
    export class CtosTimeConfirm extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {}) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") { }
        }
        static fromObject(data: {}): CtosTimeConfirm {
            const message = new CtosTimeConfirm({});
            return message;
        }
        toObject() {
            const data: {} = {};
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): CtosTimeConfirm {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new CtosTimeConfirm();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): CtosTimeConfirm {
            return CtosTimeConfirm.deserialize(bytes);
        }
    }
    export class CtosChat extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            message?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("message" in data && data.message != undefined) {
                    this.message = data.message;
                }
            }
        }
        get message() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set message(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            message?: string;
        }): CtosChat {
            const message = new CtosChat({});
            if (data.message != null) {
                message.message = data.message;
            }
            return message;
        }
        toObject() {
            const data: {
                message?: string;
            } = {};
            if (this.message != null) {
                data.message = this.message;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.message.length)
                writer.writeString(1, this.message);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): CtosChat {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new CtosChat();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.message = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): CtosChat {
            return CtosChat.deserialize(bytes);
        }
    }
    export class CtosSurrender extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {}) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") { }
        }
        static fromObject(data: {}): CtosSurrender {
            const message = new CtosSurrender({});
            return message;
        }
        toObject() {
            const data: {} = {};
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): CtosSurrender {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new CtosSurrender();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): CtosSurrender {
            return CtosSurrender.deserialize(bytes);
        }
    }
    export class CtosGameMsgResponse extends pb_1.Message {
        #one_of_decls: number[][] = [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]];
        constructor(data?: any[] | ({} & (({
            select_idle_cmd?: CtosGameMsgResponse.SelectIdleCmdResponse;
            select_place?: never;
            select_multi?: never;
            select_single?: never;
            select_effect_yn?: never;
            select_position?: never;
            select_option?: never;
            select_battle_cmd?: never;
            select_counter_response?: never;
            sort_card?: never;
        } | {
            select_idle_cmd?: never;
            select_place?: CtosGameMsgResponse.SelectPlaceResponse;
            select_multi?: never;
            select_single?: never;
            select_effect_yn?: never;
            select_position?: never;
            select_option?: never;
            select_battle_cmd?: never;
            select_counter_response?: never;
            sort_card?: never;
        } | {
            select_idle_cmd?: never;
            select_place?: never;
            select_multi?: CtosGameMsgResponse.SelectMultiResponse;
            select_single?: never;
            select_effect_yn?: never;
            select_position?: never;
            select_option?: never;
            select_battle_cmd?: never;
            select_counter_response?: never;
            sort_card?: never;
        } | {
            select_idle_cmd?: never;
            select_place?: never;
            select_multi?: never;
            select_single?: CtosGameMsgResponse.SelectSingleResponse;
            select_effect_yn?: never;
            select_position?: never;
            select_option?: never;
            select_battle_cmd?: never;
            select_counter_response?: never;
            sort_card?: never;
        } | {
            select_idle_cmd?: never;
            select_place?: never;
            select_multi?: never;
            select_single?: never;
            select_effect_yn?: CtosGameMsgResponse.SelectEffectYnResponse;
            select_position?: never;
            select_option?: never;
            select_battle_cmd?: never;
            select_counter_response?: never;
            sort_card?: never;
        } | {
            select_idle_cmd?: never;
            select_place?: never;
            select_multi?: never;
            select_single?: never;
            select_effect_yn?: never;
            select_position?: CtosGameMsgResponse.SelectPositionResponse;
            select_option?: never;
            select_battle_cmd?: never;
            select_counter_response?: never;
            sort_card?: never;
        } | {
            select_idle_cmd?: never;
            select_place?: never;
            select_multi?: never;
            select_single?: never;
            select_effect_yn?: never;
            select_position?: never;
            select_option?: CtosGameMsgResponse.SelectOptionResponse;
            select_battle_cmd?: never;
            select_counter_response?: never;
            sort_card?: never;
        } | {
            select_idle_cmd?: never;
            select_place?: never;
            select_multi?: never;
            select_single?: never;
            select_effect_yn?: never;
            select_position?: never;
            select_option?: never;
            select_battle_cmd?: CtosGameMsgResponse.SelectBattleCmdResponse;
            select_counter_response?: never;
            sort_card?: never;
        } | {
            select_idle_cmd?: never;
            select_place?: never;
            select_multi?: never;
            select_single?: never;
            select_effect_yn?: never;
            select_position?: never;
            select_option?: never;
            select_battle_cmd?: never;
            select_counter_response?: CtosGameMsgResponse.SelectCounterResponse;
            sort_card?: never;
        } | {
            select_idle_cmd?: never;
            select_place?: never;
            select_multi?: never;
            select_single?: never;
            select_effect_yn?: never;
            select_position?: never;
            select_option?: never;
            select_battle_cmd?: never;
            select_counter_response?: never;
            sort_card?: CtosGameMsgResponse.SortCardResponse;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("select_idle_cmd" in data && data.select_idle_cmd != undefined) {
                    this.select_idle_cmd = data.select_idle_cmd;
                }
                if ("select_place" in data && data.select_place != undefined) {
                    this.select_place = data.select_place;
                }
                if ("select_multi" in data && data.select_multi != undefined) {
                    this.select_multi = data.select_multi;
                }
                if ("select_single" in data && data.select_single != undefined) {
                    this.select_single = data.select_single;
                }
                if ("select_effect_yn" in data && data.select_effect_yn != undefined) {
                    this.select_effect_yn = data.select_effect_yn;
                }
                if ("select_position" in data && data.select_position != undefined) {
                    this.select_position = data.select_position;
                }
                if ("select_option" in data && data.select_option != undefined) {
                    this.select_option = data.select_option;
                }
                if ("select_battle_cmd" in data && data.select_battle_cmd != undefined) {
                    this.select_battle_cmd = data.select_battle_cmd;
                }
                if ("select_counter_response" in data && data.select_counter_response != undefined) {
                    this.select_counter_response = data.select_counter_response;
                }
                if ("sort_card" in data && data.sort_card != undefined) {
                    this.sort_card = data.sort_card;
                }
            }
        }
        get select_idle_cmd() {
            return pb_1.Message.getWrapperField(this, CtosGameMsgResponse.SelectIdleCmdResponse, 1) as CtosGameMsgResponse.SelectIdleCmdResponse;
        }
        set select_idle_cmd(value: CtosGameMsgResponse.SelectIdleCmdResponse) {
            pb_1.Message.setOneofWrapperField(this, 1, this.#one_of_decls[0], value);
        }
        get has_select_idle_cmd() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get select_place() {
            return pb_1.Message.getWrapperField(this, CtosGameMsgResponse.SelectPlaceResponse, 2) as CtosGameMsgResponse.SelectPlaceResponse;
        }
        set select_place(value: CtosGameMsgResponse.SelectPlaceResponse) {
            pb_1.Message.setOneofWrapperField(this, 2, this.#one_of_decls[0], value);
        }
        get has_select_place() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get select_multi() {
            return pb_1.Message.getWrapperField(this, CtosGameMsgResponse.SelectMultiResponse, 3) as CtosGameMsgResponse.SelectMultiResponse;
        }
        set select_multi(value: CtosGameMsgResponse.SelectMultiResponse) {
            pb_1.Message.setOneofWrapperField(this, 3, this.#one_of_decls[0], value);
        }
        get has_select_multi() {
            return pb_1.Message.getField(this, 3) != null;
        }
        get select_single() {
            return pb_1.Message.getWrapperField(this, CtosGameMsgResponse.SelectSingleResponse, 4) as CtosGameMsgResponse.SelectSingleResponse;
        }
        set select_single(value: CtosGameMsgResponse.SelectSingleResponse) {
            pb_1.Message.setOneofWrapperField(this, 4, this.#one_of_decls[0], value);
        }
        get has_select_single() {
            return pb_1.Message.getField(this, 4) != null;
        }
        get select_effect_yn() {
            return pb_1.Message.getWrapperField(this, CtosGameMsgResponse.SelectEffectYnResponse, 5) as CtosGameMsgResponse.SelectEffectYnResponse;
        }
        set select_effect_yn(value: CtosGameMsgResponse.SelectEffectYnResponse) {
            pb_1.Message.setOneofWrapperField(this, 5, this.#one_of_decls[0], value);
        }
        get has_select_effect_yn() {
            return pb_1.Message.getField(this, 5) != null;
        }
        get select_position() {
            return pb_1.Message.getWrapperField(this, CtosGameMsgResponse.SelectPositionResponse, 6) as CtosGameMsgResponse.SelectPositionResponse;
        }
        set select_position(value: CtosGameMsgResponse.SelectPositionResponse) {
            pb_1.Message.setOneofWrapperField(this, 6, this.#one_of_decls[0], value);
        }
        get has_select_position() {
            return pb_1.Message.getField(this, 6) != null;
        }
        get select_option() {
            return pb_1.Message.getWrapperField(this, CtosGameMsgResponse.SelectOptionResponse, 7) as CtosGameMsgResponse.SelectOptionResponse;
        }
        set select_option(value: CtosGameMsgResponse.SelectOptionResponse) {
            pb_1.Message.setOneofWrapperField(this, 7, this.#one_of_decls[0], value);
        }
        get has_select_option() {
            return pb_1.Message.getField(this, 7) != null;
        }
        get select_battle_cmd() {
            return pb_1.Message.getWrapperField(this, CtosGameMsgResponse.SelectBattleCmdResponse, 8) as CtosGameMsgResponse.SelectBattleCmdResponse;
        }
        set select_battle_cmd(value: CtosGameMsgResponse.SelectBattleCmdResponse) {
            pb_1.Message.setOneofWrapperField(this, 8, this.#one_of_decls[0], value);
        }
        get has_select_battle_cmd() {
            return pb_1.Message.getField(this, 8) != null;
        }
        get select_counter_response() {
            return pb_1.Message.getWrapperField(this, CtosGameMsgResponse.SelectCounterResponse, 9) as CtosGameMsgResponse.SelectCounterResponse;
        }
        set select_counter_response(value: CtosGameMsgResponse.SelectCounterResponse) {
            pb_1.Message.setOneofWrapperField(this, 9, this.#one_of_decls[0], value);
        }
        get has_select_counter_response() {
            return pb_1.Message.getField(this, 9) != null;
        }
        get sort_card() {
            return pb_1.Message.getWrapperField(this, CtosGameMsgResponse.SortCardResponse, 10) as CtosGameMsgResponse.SortCardResponse;
        }
        set sort_card(value: CtosGameMsgResponse.SortCardResponse) {
            pb_1.Message.setOneofWrapperField(this, 10, this.#one_of_decls[0], value);
        }
        get has_sort_card() {
            return pb_1.Message.getField(this, 10) != null;
        }
        get gameMsgResponse() {
            const cases: {
                [index: number]: "none" | "select_idle_cmd" | "select_place" | "select_multi" | "select_single" | "select_effect_yn" | "select_position" | "select_option" | "select_battle_cmd" | "select_counter_response" | "sort_card";
            } = {
                0: "none",
                1: "select_idle_cmd",
                2: "select_place",
                3: "select_multi",
                4: "select_single",
                5: "select_effect_yn",
                6: "select_position",
                7: "select_option",
                8: "select_battle_cmd",
                9: "select_counter_response",
                10: "sort_card"
            };
            return cases[pb_1.Message.computeOneofCase(this, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])];
        }
        static fromObject(data: {
            select_idle_cmd?: ReturnType<typeof CtosGameMsgResponse.SelectIdleCmdResponse.prototype.toObject>;
            select_place?: ReturnType<typeof CtosGameMsgResponse.SelectPlaceResponse.prototype.toObject>;
            select_multi?: ReturnType<typeof CtosGameMsgResponse.SelectMultiResponse.prototype.toObject>;
            select_single?: ReturnType<typeof CtosGameMsgResponse.SelectSingleResponse.prototype.toObject>;
            select_effect_yn?: ReturnType<typeof CtosGameMsgResponse.SelectEffectYnResponse.prototype.toObject>;
            select_position?: ReturnType<typeof CtosGameMsgResponse.SelectPositionResponse.prototype.toObject>;
            select_option?: ReturnType<typeof CtosGameMsgResponse.SelectOptionResponse.prototype.toObject>;
            select_battle_cmd?: ReturnType<typeof CtosGameMsgResponse.SelectBattleCmdResponse.prototype.toObject>;
            select_counter_response?: ReturnType<typeof CtosGameMsgResponse.SelectCounterResponse.prototype.toObject>;
            sort_card?: ReturnType<typeof CtosGameMsgResponse.SortCardResponse.prototype.toObject>;
        }): CtosGameMsgResponse {
            const message = new CtosGameMsgResponse({});
            if (data.select_idle_cmd != null) {
                message.select_idle_cmd = CtosGameMsgResponse.SelectIdleCmdResponse.fromObject(data.select_idle_cmd);
            }
            if (data.select_place != null) {
                message.select_place = CtosGameMsgResponse.SelectPlaceResponse.fromObject(data.select_place);
            }
            if (data.select_multi != null) {
                message.select_multi = CtosGameMsgResponse.SelectMultiResponse.fromObject(data.select_multi);
            }
            if (data.select_single != null) {
                message.select_single = CtosGameMsgResponse.SelectSingleResponse.fromObject(data.select_single);
            }
            if (data.select_effect_yn != null) {
                message.select_effect_yn = CtosGameMsgResponse.SelectEffectYnResponse.fromObject(data.select_effect_yn);
            }
            if (data.select_position != null) {
                message.select_position = CtosGameMsgResponse.SelectPositionResponse.fromObject(data.select_position);
            }
            if (data.select_option != null) {
                message.select_option = CtosGameMsgResponse.SelectOptionResponse.fromObject(data.select_option);
            }
            if (data.select_battle_cmd != null) {
                message.select_battle_cmd = CtosGameMsgResponse.SelectBattleCmdResponse.fromObject(data.select_battle_cmd);
            }
            if (data.select_counter_response != null) {
                message.select_counter_response = CtosGameMsgResponse.SelectCounterResponse.fromObject(data.select_counter_response);
            }
            if (data.sort_card != null) {
                message.sort_card = CtosGameMsgResponse.SortCardResponse.fromObject(data.sort_card);
            }
            return message;
        }
        toObject() {
            const data: {
                select_idle_cmd?: ReturnType<typeof CtosGameMsgResponse.SelectIdleCmdResponse.prototype.toObject>;
                select_place?: ReturnType<typeof CtosGameMsgResponse.SelectPlaceResponse.prototype.toObject>;
                select_multi?: ReturnType<typeof CtosGameMsgResponse.SelectMultiResponse.prototype.toObject>;
                select_single?: ReturnType<typeof CtosGameMsgResponse.SelectSingleResponse.prototype.toObject>;
                select_effect_yn?: ReturnType<typeof CtosGameMsgResponse.SelectEffectYnResponse.prototype.toObject>;
                select_position?: ReturnType<typeof CtosGameMsgResponse.SelectPositionResponse.prototype.toObject>;
                select_option?: ReturnType<typeof CtosGameMsgResponse.SelectOptionResponse.prototype.toObject>;
                select_battle_cmd?: ReturnType<typeof CtosGameMsgResponse.SelectBattleCmdResponse.prototype.toObject>;
                select_counter_response?: ReturnType<typeof CtosGameMsgResponse.SelectCounterResponse.prototype.toObject>;
                sort_card?: ReturnType<typeof CtosGameMsgResponse.SortCardResponse.prototype.toObject>;
            } = {};
            if (this.select_idle_cmd != null) {
                data.select_idle_cmd = this.select_idle_cmd.toObject();
            }
            if (this.select_place != null) {
                data.select_place = this.select_place.toObject();
            }
            if (this.select_multi != null) {
                data.select_multi = this.select_multi.toObject();
            }
            if (this.select_single != null) {
                data.select_single = this.select_single.toObject();
            }
            if (this.select_effect_yn != null) {
                data.select_effect_yn = this.select_effect_yn.toObject();
            }
            if (this.select_position != null) {
                data.select_position = this.select_position.toObject();
            }
            if (this.select_option != null) {
                data.select_option = this.select_option.toObject();
            }
            if (this.select_battle_cmd != null) {
                data.select_battle_cmd = this.select_battle_cmd.toObject();
            }
            if (this.select_counter_response != null) {
                data.select_counter_response = this.select_counter_response.toObject();
            }
            if (this.sort_card != null) {
                data.sort_card = this.sort_card.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_select_idle_cmd)
                writer.writeMessage(1, this.select_idle_cmd, () => this.select_idle_cmd.serialize(writer));
            if (this.has_select_place)
                writer.writeMessage(2, this.select_place, () => this.select_place.serialize(writer));
            if (this.has_select_multi)
                writer.writeMessage(3, this.select_multi, () => this.select_multi.serialize(writer));
            if (this.has_select_single)
                writer.writeMessage(4, this.select_single, () => this.select_single.serialize(writer));
            if (this.has_select_effect_yn)
                writer.writeMessage(5, this.select_effect_yn, () => this.select_effect_yn.serialize(writer));
            if (this.has_select_position)
                writer.writeMessage(6, this.select_position, () => this.select_position.serialize(writer));
            if (this.has_select_option)
                writer.writeMessage(7, this.select_option, () => this.select_option.serialize(writer));
            if (this.has_select_battle_cmd)
                writer.writeMessage(8, this.select_battle_cmd, () => this.select_battle_cmd.serialize(writer));
            if (this.has_select_counter_response)
                writer.writeMessage(9, this.select_counter_response, () => this.select_counter_response.serialize(writer));
            if (this.has_sort_card)
                writer.writeMessage(10, this.sort_card, () => this.sort_card.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): CtosGameMsgResponse {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new CtosGameMsgResponse();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.select_idle_cmd, () => message.select_idle_cmd = CtosGameMsgResponse.SelectIdleCmdResponse.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message.select_place, () => message.select_place = CtosGameMsgResponse.SelectPlaceResponse.deserialize(reader));
                        break;
                    case 3:
                        reader.readMessage(message.select_multi, () => message.select_multi = CtosGameMsgResponse.SelectMultiResponse.deserialize(reader));
                        break;
                    case 4:
                        reader.readMessage(message.select_single, () => message.select_single = CtosGameMsgResponse.SelectSingleResponse.deserialize(reader));
                        break;
                    case 5:
                        reader.readMessage(message.select_effect_yn, () => message.select_effect_yn = CtosGameMsgResponse.SelectEffectYnResponse.deserialize(reader));
                        break;
                    case 6:
                        reader.readMessage(message.select_position, () => message.select_position = CtosGameMsgResponse.SelectPositionResponse.deserialize(reader));
                        break;
                    case 7:
                        reader.readMessage(message.select_option, () => message.select_option = CtosGameMsgResponse.SelectOptionResponse.deserialize(reader));
                        break;
                    case 8:
                        reader.readMessage(message.select_battle_cmd, () => message.select_battle_cmd = CtosGameMsgResponse.SelectBattleCmdResponse.deserialize(reader));
                        break;
                    case 9:
                        reader.readMessage(message.select_counter_response, () => message.select_counter_response = CtosGameMsgResponse.SelectCounterResponse.deserialize(reader));
                        break;
                    case 10:
                        reader.readMessage(message.sort_card, () => message.sort_card = CtosGameMsgResponse.SortCardResponse.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): CtosGameMsgResponse {
            return CtosGameMsgResponse.deserialize(bytes);
        }
    }
    export namespace CtosGameMsgResponse {
        export class SelectIdleCmdResponse extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                code?: number;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("code" in data && data.code != undefined) {
                        this.code = data.code;
                    }
                }
            }
            get code() {
                return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
            }
            set code(value: number) {
                pb_1.Message.setField(this, 1, value);
            }
            static fromObject(data: {
                code?: number;
            }): SelectIdleCmdResponse {
                const message = new SelectIdleCmdResponse({});
                if (data.code != null) {
                    message.code = data.code;
                }
                return message;
            }
            toObject() {
                const data: {
                    code?: number;
                } = {};
                if (this.code != null) {
                    data.code = this.code;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.code != 0)
                    writer.writeInt32(1, this.code);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SelectIdleCmdResponse {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SelectIdleCmdResponse();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.code = reader.readInt32();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): SelectIdleCmdResponse {
                return SelectIdleCmdResponse.deserialize(bytes);
            }
        }
        export class SelectPlaceResponse extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                player?: number;
                zone?: CardZone;
                sequence?: number;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("player" in data && data.player != undefined) {
                        this.player = data.player;
                    }
                    if ("zone" in data && data.zone != undefined) {
                        this.zone = data.zone;
                    }
                    if ("sequence" in data && data.sequence != undefined) {
                        this.sequence = data.sequence;
                    }
                }
            }
            get player() {
                return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
            }
            set player(value: number) {
                pb_1.Message.setField(this, 1, value);
            }
            get zone() {
                return pb_1.Message.getFieldWithDefault(this, 2, CardZone.DECK) as CardZone;
            }
            set zone(value: CardZone) {
                pb_1.Message.setField(this, 2, value);
            }
            get sequence() {
                return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
            }
            set sequence(value: number) {
                pb_1.Message.setField(this, 3, value);
            }
            static fromObject(data: {
                player?: number;
                zone?: CardZone;
                sequence?: number;
            }): SelectPlaceResponse {
                const message = new SelectPlaceResponse({});
                if (data.player != null) {
                    message.player = data.player;
                }
                if (data.zone != null) {
                    message.zone = data.zone;
                }
                if (data.sequence != null) {
                    message.sequence = data.sequence;
                }
                return message;
            }
            toObject() {
                const data: {
                    player?: number;
                    zone?: CardZone;
                    sequence?: number;
                } = {};
                if (this.player != null) {
                    data.player = this.player;
                }
                if (this.zone != null) {
                    data.zone = this.zone;
                }
                if (this.sequence != null) {
                    data.sequence = this.sequence;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.player != 0)
                    writer.writeInt32(1, this.player);
                if (this.zone != CardZone.DECK)
                    writer.writeEnum(2, this.zone);
                if (this.sequence != 0)
                    writer.writeInt32(3, this.sequence);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SelectPlaceResponse {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SelectPlaceResponse();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.player = reader.readInt32();
                            break;
                        case 2:
                            message.zone = reader.readEnum();
                            break;
                        case 3:
                            message.sequence = reader.readInt32();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): SelectPlaceResponse {
                return SelectPlaceResponse.deserialize(bytes);
            }
        }
        export class SelectMultiResponse extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                selected_ptrs?: number[];
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("selected_ptrs" in data && data.selected_ptrs != undefined) {
                        this.selected_ptrs = data.selected_ptrs;
                    }
                }
            }
            get selected_ptrs() {
                return pb_1.Message.getFieldWithDefault(this, 1, []) as number[];
            }
            set selected_ptrs(value: number[]) {
                pb_1.Message.setField(this, 1, value);
            }
            static fromObject(data: {
                selected_ptrs?: number[];
            }): SelectMultiResponse {
                const message = new SelectMultiResponse({});
                if (data.selected_ptrs != null) {
                    message.selected_ptrs = data.selected_ptrs;
                }
                return message;
            }
            toObject() {
                const data: {
                    selected_ptrs?: number[];
                } = {};
                if (this.selected_ptrs != null) {
                    data.selected_ptrs = this.selected_ptrs;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.selected_ptrs.length)
                    writer.writePackedInt32(1, this.selected_ptrs);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SelectMultiResponse {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SelectMultiResponse();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.selected_ptrs = reader.readPackedInt32();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): SelectMultiResponse {
                return SelectMultiResponse.deserialize(bytes);
            }
        }
        export class SelectSingleResponse extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                selected_ptr?: number;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("selected_ptr" in data && data.selected_ptr != undefined) {
                        this.selected_ptr = data.selected_ptr;
                    }
                }
            }
            get selected_ptr() {
                return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
            }
            set selected_ptr(value: number) {
                pb_1.Message.setField(this, 1, value);
            }
            static fromObject(data: {
                selected_ptr?: number;
            }): SelectSingleResponse {
                const message = new SelectSingleResponse({});
                if (data.selected_ptr != null) {
                    message.selected_ptr = data.selected_ptr;
                }
                return message;
            }
            toObject() {
                const data: {
                    selected_ptr?: number;
                } = {};
                if (this.selected_ptr != null) {
                    data.selected_ptr = this.selected_ptr;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.selected_ptr != 0)
                    writer.writeInt32(1, this.selected_ptr);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SelectSingleResponse {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SelectSingleResponse();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.selected_ptr = reader.readInt32();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): SelectSingleResponse {
                return SelectSingleResponse.deserialize(bytes);
            }
        }
        export class SelectEffectYnResponse extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                selected?: boolean;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("selected" in data && data.selected != undefined) {
                        this.selected = data.selected;
                    }
                }
            }
            get selected() {
                return pb_1.Message.getFieldWithDefault(this, 1, false) as boolean;
            }
            set selected(value: boolean) {
                pb_1.Message.setField(this, 1, value);
            }
            static fromObject(data: {
                selected?: boolean;
            }): SelectEffectYnResponse {
                const message = new SelectEffectYnResponse({});
                if (data.selected != null) {
                    message.selected = data.selected;
                }
                return message;
            }
            toObject() {
                const data: {
                    selected?: boolean;
                } = {};
                if (this.selected != null) {
                    data.selected = this.selected;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.selected != false)
                    writer.writeBool(1, this.selected);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SelectEffectYnResponse {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SelectEffectYnResponse();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.selected = reader.readBool();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): SelectEffectYnResponse {
                return SelectEffectYnResponse.deserialize(bytes);
            }
        }
        export class SelectPositionResponse extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                position?: CardPosition;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("position" in data && data.position != undefined) {
                        this.position = data.position;
                    }
                }
            }
            get position() {
                return pb_1.Message.getFieldWithDefault(this, 1, CardPosition.FACEUP_ATTACK) as CardPosition;
            }
            set position(value: CardPosition) {
                pb_1.Message.setField(this, 1, value);
            }
            static fromObject(data: {
                position?: CardPosition;
            }): SelectPositionResponse {
                const message = new SelectPositionResponse({});
                if (data.position != null) {
                    message.position = data.position;
                }
                return message;
            }
            toObject() {
                const data: {
                    position?: CardPosition;
                } = {};
                if (this.position != null) {
                    data.position = this.position;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.position != CardPosition.FACEUP_ATTACK)
                    writer.writeEnum(1, this.position);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SelectPositionResponse {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SelectPositionResponse();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.position = reader.readEnum();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): SelectPositionResponse {
                return SelectPositionResponse.deserialize(bytes);
            }
        }
        export class SelectOptionResponse extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                code?: number;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("code" in data && data.code != undefined) {
                        this.code = data.code;
                    }
                }
            }
            get code() {
                return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
            }
            set code(value: number) {
                pb_1.Message.setField(this, 1, value);
            }
            static fromObject(data: {
                code?: number;
            }): SelectOptionResponse {
                const message = new SelectOptionResponse({});
                if (data.code != null) {
                    message.code = data.code;
                }
                return message;
            }
            toObject() {
                const data: {
                    code?: number;
                } = {};
                if (this.code != null) {
                    data.code = this.code;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.code != 0)
                    writer.writeInt32(1, this.code);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SelectOptionResponse {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SelectOptionResponse();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.code = reader.readInt32();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): SelectOptionResponse {
                return SelectOptionResponse.deserialize(bytes);
            }
        }
        export class SelectBattleCmdResponse extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                selected_cmd?: number;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("selected_cmd" in data && data.selected_cmd != undefined) {
                        this.selected_cmd = data.selected_cmd;
                    }
                }
            }
            get selected_cmd() {
                return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
            }
            set selected_cmd(value: number) {
                pb_1.Message.setField(this, 1, value);
            }
            static fromObject(data: {
                selected_cmd?: number;
            }): SelectBattleCmdResponse {
                const message = new SelectBattleCmdResponse({});
                if (data.selected_cmd != null) {
                    message.selected_cmd = data.selected_cmd;
                }
                return message;
            }
            toObject() {
                const data: {
                    selected_cmd?: number;
                } = {};
                if (this.selected_cmd != null) {
                    data.selected_cmd = this.selected_cmd;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.selected_cmd != 0)
                    writer.writeInt32(1, this.selected_cmd);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SelectBattleCmdResponse {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SelectBattleCmdResponse();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.selected_cmd = reader.readInt32();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): SelectBattleCmdResponse {
                return SelectBattleCmdResponse.deserialize(bytes);
            }
        }
        export class SelectCounterResponse extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                selected_count?: number[];
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("selected_count" in data && data.selected_count != undefined) {
                        this.selected_count = data.selected_count;
                    }
                }
            }
            get selected_count() {
                return pb_1.Message.getFieldWithDefault(this, 1, []) as number[];
            }
            set selected_count(value: number[]) {
                pb_1.Message.setField(this, 1, value);
            }
            static fromObject(data: {
                selected_count?: number[];
            }): SelectCounterResponse {
                const message = new SelectCounterResponse({});
                if (data.selected_count != null) {
                    message.selected_count = data.selected_count;
                }
                return message;
            }
            toObject() {
                const data: {
                    selected_count?: number[];
                } = {};
                if (this.selected_count != null) {
                    data.selected_count = this.selected_count;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.selected_count.length)
                    writer.writePackedInt32(1, this.selected_count);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SelectCounterResponse {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SelectCounterResponse();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.selected_count = reader.readPackedInt32();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): SelectCounterResponse {
                return SelectCounterResponse.deserialize(bytes);
            }
        }
        export class SortCardResponse extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                sorted_index?: number[];
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("sorted_index" in data && data.sorted_index != undefined) {
                        this.sorted_index = data.sorted_index;
                    }
                }
            }
            get sorted_index() {
                return pb_1.Message.getFieldWithDefault(this, 1, []) as number[];
            }
            set sorted_index(value: number[]) {
                pb_1.Message.setField(this, 1, value);
            }
            static fromObject(data: {
                sorted_index?: number[];
            }): SortCardResponse {
                const message = new SortCardResponse({});
                if (data.sorted_index != null) {
                    message.sorted_index = data.sorted_index;
                }
                return message;
            }
            toObject() {
                const data: {
                    sorted_index?: number[];
                } = {};
                if (this.sorted_index != null) {
                    data.sorted_index = this.sorted_index;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.sorted_index.length)
                    writer.writePackedInt32(1, this.sorted_index);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SortCardResponse {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SortCardResponse();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.sorted_index = reader.readPackedInt32();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): SortCardResponse {
                return SortCardResponse.deserialize(bytes);
            }
        }
    }
    export class StocJoinGame extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            lflist?: number;
            rule?: number;
            mode?: number;
            duel_rule?: number;
            no_check_deck?: boolean;
            no_shuffle_deck?: boolean;
            start_lp?: number;
            start_hand?: number;
            draw_count?: number;
            time_limit?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("lflist" in data && data.lflist != undefined) {
                    this.lflist = data.lflist;
                }
                if ("rule" in data && data.rule != undefined) {
                    this.rule = data.rule;
                }
                if ("mode" in data && data.mode != undefined) {
                    this.mode = data.mode;
                }
                if ("duel_rule" in data && data.duel_rule != undefined) {
                    this.duel_rule = data.duel_rule;
                }
                if ("no_check_deck" in data && data.no_check_deck != undefined) {
                    this.no_check_deck = data.no_check_deck;
                }
                if ("no_shuffle_deck" in data && data.no_shuffle_deck != undefined) {
                    this.no_shuffle_deck = data.no_shuffle_deck;
                }
                if ("start_lp" in data && data.start_lp != undefined) {
                    this.start_lp = data.start_lp;
                }
                if ("start_hand" in data && data.start_hand != undefined) {
                    this.start_hand = data.start_hand;
                }
                if ("draw_count" in data && data.draw_count != undefined) {
                    this.draw_count = data.draw_count;
                }
                if ("time_limit" in data && data.time_limit != undefined) {
                    this.time_limit = data.time_limit;
                }
            }
        }
        get lflist() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set lflist(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get rule() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set rule(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get mode() {
            return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
        }
        set mode(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        get duel_rule() {
            return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
        }
        set duel_rule(value: number) {
            pb_1.Message.setField(this, 4, value);
        }
        get no_check_deck() {
            return pb_1.Message.getFieldWithDefault(this, 5, false) as boolean;
        }
        set no_check_deck(value: boolean) {
            pb_1.Message.setField(this, 5, value);
        }
        get no_shuffle_deck() {
            return pb_1.Message.getFieldWithDefault(this, 6, false) as boolean;
        }
        set no_shuffle_deck(value: boolean) {
            pb_1.Message.setField(this, 6, value);
        }
        get start_lp() {
            return pb_1.Message.getFieldWithDefault(this, 7, 0) as number;
        }
        set start_lp(value: number) {
            pb_1.Message.setField(this, 7, value);
        }
        get start_hand() {
            return pb_1.Message.getFieldWithDefault(this, 8, 0) as number;
        }
        set start_hand(value: number) {
            pb_1.Message.setField(this, 8, value);
        }
        get draw_count() {
            return pb_1.Message.getFieldWithDefault(this, 9, 0) as number;
        }
        set draw_count(value: number) {
            pb_1.Message.setField(this, 9, value);
        }
        get time_limit() {
            return pb_1.Message.getFieldWithDefault(this, 10, 0) as number;
        }
        set time_limit(value: number) {
            pb_1.Message.setField(this, 10, value);
        }
        static fromObject(data: {
            lflist?: number;
            rule?: number;
            mode?: number;
            duel_rule?: number;
            no_check_deck?: boolean;
            no_shuffle_deck?: boolean;
            start_lp?: number;
            start_hand?: number;
            draw_count?: number;
            time_limit?: number;
        }): StocJoinGame {
            const message = new StocJoinGame({});
            if (data.lflist != null) {
                message.lflist = data.lflist;
            }
            if (data.rule != null) {
                message.rule = data.rule;
            }
            if (data.mode != null) {
                message.mode = data.mode;
            }
            if (data.duel_rule != null) {
                message.duel_rule = data.duel_rule;
            }
            if (data.no_check_deck != null) {
                message.no_check_deck = data.no_check_deck;
            }
            if (data.no_shuffle_deck != null) {
                message.no_shuffle_deck = data.no_shuffle_deck;
            }
            if (data.start_lp != null) {
                message.start_lp = data.start_lp;
            }
            if (data.start_hand != null) {
                message.start_hand = data.start_hand;
            }
            if (data.draw_count != null) {
                message.draw_count = data.draw_count;
            }
            if (data.time_limit != null) {
                message.time_limit = data.time_limit;
            }
            return message;
        }
        toObject() {
            const data: {
                lflist?: number;
                rule?: number;
                mode?: number;
                duel_rule?: number;
                no_check_deck?: boolean;
                no_shuffle_deck?: boolean;
                start_lp?: number;
                start_hand?: number;
                draw_count?: number;
                time_limit?: number;
            } = {};
            if (this.lflist != null) {
                data.lflist = this.lflist;
            }
            if (this.rule != null) {
                data.rule = this.rule;
            }
            if (this.mode != null) {
                data.mode = this.mode;
            }
            if (this.duel_rule != null) {
                data.duel_rule = this.duel_rule;
            }
            if (this.no_check_deck != null) {
                data.no_check_deck = this.no_check_deck;
            }
            if (this.no_shuffle_deck != null) {
                data.no_shuffle_deck = this.no_shuffle_deck;
            }
            if (this.start_lp != null) {
                data.start_lp = this.start_lp;
            }
            if (this.start_hand != null) {
                data.start_hand = this.start_hand;
            }
            if (this.draw_count != null) {
                data.draw_count = this.draw_count;
            }
            if (this.time_limit != null) {
                data.time_limit = this.time_limit;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.lflist != 0)
                writer.writeInt32(1, this.lflist);
            if (this.rule != 0)
                writer.writeInt32(2, this.rule);
            if (this.mode != 0)
                writer.writeInt32(3, this.mode);
            if (this.duel_rule != 0)
                writer.writeInt32(4, this.duel_rule);
            if (this.no_check_deck != false)
                writer.writeBool(5, this.no_check_deck);
            if (this.no_shuffle_deck != false)
                writer.writeBool(6, this.no_shuffle_deck);
            if (this.start_lp != 0)
                writer.writeInt32(7, this.start_lp);
            if (this.start_hand != 0)
                writer.writeInt32(8, this.start_hand);
            if (this.draw_count != 0)
                writer.writeInt32(9, this.draw_count);
            if (this.time_limit != 0)
                writer.writeInt32(10, this.time_limit);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): StocJoinGame {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new StocJoinGame();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.lflist = reader.readInt32();
                        break;
                    case 2:
                        message.rule = reader.readInt32();
                        break;
                    case 3:
                        message.mode = reader.readInt32();
                        break;
                    case 4:
                        message.duel_rule = reader.readInt32();
                        break;
                    case 5:
                        message.no_check_deck = reader.readBool();
                        break;
                    case 6:
                        message.no_shuffle_deck = reader.readBool();
                        break;
                    case 7:
                        message.start_lp = reader.readInt32();
                        break;
                    case 8:
                        message.start_hand = reader.readInt32();
                        break;
                    case 9:
                        message.draw_count = reader.readInt32();
                        break;
                    case 10:
                        message.time_limit = reader.readInt32();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): StocJoinGame {
            return StocJoinGame.deserialize(bytes);
        }
    }
    export class StocChat extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            player?: number;
            msg?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("player" in data && data.player != undefined) {
                    this.player = data.player;
                }
                if ("msg" in data && data.msg != undefined) {
                    this.msg = data.msg;
                }
            }
        }
        get player() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set player(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get msg() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set msg(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            player?: number;
            msg?: string;
        }): StocChat {
            const message = new StocChat({});
            if (data.player != null) {
                message.player = data.player;
            }
            if (data.msg != null) {
                message.msg = data.msg;
            }
            return message;
        }
        toObject() {
            const data: {
                player?: number;
                msg?: string;
            } = {};
            if (this.player != null) {
                data.player = this.player;
            }
            if (this.msg != null) {
                data.msg = this.msg;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.player != 0)
                writer.writeInt32(1, this.player);
            if (this.msg.length)
                writer.writeString(2, this.msg);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): StocChat {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new StocChat();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.player = reader.readInt32();
                        break;
                    case 2:
                        message.msg = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): StocChat {
            return StocChat.deserialize(bytes);
        }
    }
    export class StocErrorMsg extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            error_type?: StocErrorMsg.ErrorType;
            error_code?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("error_type" in data && data.error_type != undefined) {
                    this.error_type = data.error_type;
                }
                if ("error_code" in data && data.error_code != undefined) {
                    this.error_code = data.error_code;
                }
            }
        }
        get error_type() {
            return pb_1.Message.getFieldWithDefault(this, 1, StocErrorMsg.ErrorType.UNKNOWN) as StocErrorMsg.ErrorType;
        }
        set error_type(value: StocErrorMsg.ErrorType) {
            pb_1.Message.setField(this, 1, value);
        }
        get error_code() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set error_code(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            error_type?: StocErrorMsg.ErrorType;
            error_code?: number;
        }): StocErrorMsg {
            const message = new StocErrorMsg({});
            if (data.error_type != null) {
                message.error_type = data.error_type;
            }
            if (data.error_code != null) {
                message.error_code = data.error_code;
            }
            return message;
        }
        toObject() {
            const data: {
                error_type?: StocErrorMsg.ErrorType;
                error_code?: number;
            } = {};
            if (this.error_type != null) {
                data.error_type = this.error_type;
            }
            if (this.error_code != null) {
                data.error_code = this.error_code;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.error_type != StocErrorMsg.ErrorType.UNKNOWN)
                writer.writeEnum(1, this.error_type);
            if (this.error_code != 0)
                writer.writeInt32(2, this.error_code);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): StocErrorMsg {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new StocErrorMsg();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.error_type = reader.readEnum();
                        break;
                    case 2:
                        message.error_code = reader.readInt32();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): StocErrorMsg {
            return StocErrorMsg.deserialize(bytes);
        }
    }
    export namespace StocErrorMsg {
        export enum ErrorType {
            UNKNOWN = 0,
            JOINERROR = 1,
            DECKERROR = 2,
            SIDEERROR = 3,
            VERSIONERROR = 4
        }
    }
    export class StocHsPlayerEnter extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            name?: string;
            pos?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("name" in data && data.name != undefined) {
                    this.name = data.name;
                }
                if ("pos" in data && data.pos != undefined) {
                    this.pos = data.pos;
                }
            }
        }
        get name() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set name(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get pos() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set pos(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            name?: string;
            pos?: number;
        }): StocHsPlayerEnter {
            const message = new StocHsPlayerEnter({});
            if (data.name != null) {
                message.name = data.name;
            }
            if (data.pos != null) {
                message.pos = data.pos;
            }
            return message;
        }
        toObject() {
            const data: {
                name?: string;
                pos?: number;
            } = {};
            if (this.name != null) {
                data.name = this.name;
            }
            if (this.pos != null) {
                data.pos = this.pos;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.name.length)
                writer.writeString(1, this.name);
            if (this.pos != 0)
                writer.writeInt32(2, this.pos);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): StocHsPlayerEnter {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new StocHsPlayerEnter();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.name = reader.readString();
                        break;
                    case 2:
                        message.pos = reader.readInt32();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): StocHsPlayerEnter {
            return StocHsPlayerEnter.deserialize(bytes);
        }
    }
    export class StocTypeChange extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            self_type?: StocTypeChange.SelfType;
            is_host?: boolean;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("self_type" in data && data.self_type != undefined) {
                    this.self_type = data.self_type;
                }
                if ("is_host" in data && data.is_host != undefined) {
                    this.is_host = data.is_host;
                }
            }
        }
        get self_type() {
            return pb_1.Message.getFieldWithDefault(this, 1, StocTypeChange.SelfType.UNKNOWN) as StocTypeChange.SelfType;
        }
        set self_type(value: StocTypeChange.SelfType) {
            pb_1.Message.setField(this, 1, value);
        }
        get is_host() {
            return pb_1.Message.getFieldWithDefault(this, 2, false) as boolean;
        }
        set is_host(value: boolean) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            self_type?: StocTypeChange.SelfType;
            is_host?: boolean;
        }): StocTypeChange {
            const message = new StocTypeChange({});
            if (data.self_type != null) {
                message.self_type = data.self_type;
            }
            if (data.is_host != null) {
                message.is_host = data.is_host;
            }
            return message;
        }
        toObject() {
            const data: {
                self_type?: StocTypeChange.SelfType;
                is_host?: boolean;
            } = {};
            if (this.self_type != null) {
                data.self_type = this.self_type;
            }
            if (this.is_host != null) {
                data.is_host = this.is_host;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.self_type != StocTypeChange.SelfType.UNKNOWN)
                writer.writeEnum(1, this.self_type);
            if (this.is_host != false)
                writer.writeBool(2, this.is_host);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): StocTypeChange {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new StocTypeChange();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.self_type = reader.readEnum();
                        break;
                    case 2:
                        message.is_host = reader.readBool();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): StocTypeChange {
            return StocTypeChange.deserialize(bytes);
        }
    }
    export namespace StocTypeChange {
        export enum SelfType {
            UNKNOWN = 0,
            PLAYER1 = 1,
            PLAYER2 = 2,
            PLAYER3 = 3,
            PLAYER4 = 4,
            PLAYER5 = 5,
            PLAYER6 = 6,
            OBSERVER = 100
        }
    }
    export class StocHsPlayerChange extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            state?: StocHsPlayerChange.State;
            pos?: number;
            moved_pos?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("state" in data && data.state != undefined) {
                    this.state = data.state;
                }
                if ("pos" in data && data.pos != undefined) {
                    this.pos = data.pos;
                }
                if ("moved_pos" in data && data.moved_pos != undefined) {
                    this.moved_pos = data.moved_pos;
                }
            }
        }
        get state() {
            return pb_1.Message.getFieldWithDefault(this, 1, StocHsPlayerChange.State.UNKNOWN) as StocHsPlayerChange.State;
        }
        set state(value: StocHsPlayerChange.State) {
            pb_1.Message.setField(this, 1, value);
        }
        get pos() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set pos(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get moved_pos() {
            return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
        }
        set moved_pos(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            state?: StocHsPlayerChange.State;
            pos?: number;
            moved_pos?: number;
        }): StocHsPlayerChange {
            const message = new StocHsPlayerChange({});
            if (data.state != null) {
                message.state = data.state;
            }
            if (data.pos != null) {
                message.pos = data.pos;
            }
            if (data.moved_pos != null) {
                message.moved_pos = data.moved_pos;
            }
            return message;
        }
        toObject() {
            const data: {
                state?: StocHsPlayerChange.State;
                pos?: number;
                moved_pos?: number;
            } = {};
            if (this.state != null) {
                data.state = this.state;
            }
            if (this.pos != null) {
                data.pos = this.pos;
            }
            if (this.moved_pos != null) {
                data.moved_pos = this.moved_pos;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.state != StocHsPlayerChange.State.UNKNOWN)
                writer.writeEnum(1, this.state);
            if (this.pos != 0)
                writer.writeInt32(2, this.pos);
            if (this.moved_pos != 0)
                writer.writeInt32(3, this.moved_pos);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): StocHsPlayerChange {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new StocHsPlayerChange();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.state = reader.readEnum();
                        break;
                    case 2:
                        message.pos = reader.readInt32();
                        break;
                    case 3:
                        message.moved_pos = reader.readInt32();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): StocHsPlayerChange {
            return StocHsPlayerChange.deserialize(bytes);
        }
    }
    export namespace StocHsPlayerChange {
        export enum State {
            UNKNOWN = 0,
            MOVE = 1,
            READY = 2,
            NO_READY = 3,
            LEAVE = 4,
            TO_OBSERVER = 5
        }
    }
    export class StocHsWatchChange extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            count?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("count" in data && data.count != undefined) {
                    this.count = data.count;
                }
            }
        }
        get count() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set count(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            count?: number;
        }): StocHsWatchChange {
            const message = new StocHsWatchChange({});
            if (data.count != null) {
                message.count = data.count;
            }
            return message;
        }
        toObject() {
            const data: {
                count?: number;
            } = {};
            if (this.count != null) {
                data.count = this.count;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.count != 0)
                writer.writeInt32(1, this.count);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): StocHsWatchChange {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new StocHsWatchChange();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.count = reader.readInt32();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): StocHsWatchChange {
            return StocHsWatchChange.deserialize(bytes);
        }
    }
    export class StocSelectHand extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {}) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") { }
        }
        static fromObject(data: {}): StocSelectHand {
            const message = new StocSelectHand({});
            return message;
        }
        toObject() {
            const data: {} = {};
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): StocSelectHand {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new StocSelectHand();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): StocSelectHand {
            return StocSelectHand.deserialize(bytes);
        }
    }
    export class StocHandResult extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            meResult?: HandType;
            opResult?: HandType;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("meResult" in data && data.meResult != undefined) {
                    this.meResult = data.meResult;
                }
                if ("opResult" in data && data.opResult != undefined) {
                    this.opResult = data.opResult;
                }
            }
        }
        get meResult() {
            return pb_1.Message.getFieldWithDefault(this, 1, HandType.UNKNOWN) as HandType;
        }
        set meResult(value: HandType) {
            pb_1.Message.setField(this, 1, value);
        }
        get opResult() {
            return pb_1.Message.getFieldWithDefault(this, 2, HandType.UNKNOWN) as HandType;
        }
        set opResult(value: HandType) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            meResult?: HandType;
            opResult?: HandType;
        }): StocHandResult {
            const message = new StocHandResult({});
            if (data.meResult != null) {
                message.meResult = data.meResult;
            }
            if (data.opResult != null) {
                message.opResult = data.opResult;
            }
            return message;
        }
        toObject() {
            const data: {
                meResult?: HandType;
                opResult?: HandType;
            } = {};
            if (this.meResult != null) {
                data.meResult = this.meResult;
            }
            if (this.opResult != null) {
                data.opResult = this.opResult;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.meResult != HandType.UNKNOWN)
                writer.writeEnum(1, this.meResult);
            if (this.opResult != HandType.UNKNOWN)
                writer.writeEnum(2, this.opResult);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): StocHandResult {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new StocHandResult();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.meResult = reader.readEnum();
                        break;
                    case 2:
                        message.opResult = reader.readEnum();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): StocHandResult {
            return StocHandResult.deserialize(bytes);
        }
    }
    export class StocSelectTp extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {}) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") { }
        }
        static fromObject(data: {}): StocSelectTp {
            const message = new StocSelectTp({});
            return message;
        }
        toObject() {
            const data: {} = {};
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): StocSelectTp {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new StocSelectTp();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): StocSelectTp {
            return StocSelectTp.deserialize(bytes);
        }
    }
    export class StocDeckCount extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            meMain?: number;
            meExtra?: number;
            meSide?: number;
            opMain?: number;
            opExtra?: number;
            opSide?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("meMain" in data && data.meMain != undefined) {
                    this.meMain = data.meMain;
                }
                if ("meExtra" in data && data.meExtra != undefined) {
                    this.meExtra = data.meExtra;
                }
                if ("meSide" in data && data.meSide != undefined) {
                    this.meSide = data.meSide;
                }
                if ("opMain" in data && data.opMain != undefined) {
                    this.opMain = data.opMain;
                }
                if ("opExtra" in data && data.opExtra != undefined) {
                    this.opExtra = data.opExtra;
                }
                if ("opSide" in data && data.opSide != undefined) {
                    this.opSide = data.opSide;
                }
            }
        }
        get meMain() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set meMain(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get meExtra() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set meExtra(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get meSide() {
            return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
        }
        set meSide(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        get opMain() {
            return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
        }
        set opMain(value: number) {
            pb_1.Message.setField(this, 4, value);
        }
        get opExtra() {
            return pb_1.Message.getFieldWithDefault(this, 5, 0) as number;
        }
        set opExtra(value: number) {
            pb_1.Message.setField(this, 5, value);
        }
        get opSide() {
            return pb_1.Message.getFieldWithDefault(this, 6, 0) as number;
        }
        set opSide(value: number) {
            pb_1.Message.setField(this, 6, value);
        }
        static fromObject(data: {
            meMain?: number;
            meExtra?: number;
            meSide?: number;
            opMain?: number;
            opExtra?: number;
            opSide?: number;
        }): StocDeckCount {
            const message = new StocDeckCount({});
            if (data.meMain != null) {
                message.meMain = data.meMain;
            }
            if (data.meExtra != null) {
                message.meExtra = data.meExtra;
            }
            if (data.meSide != null) {
                message.meSide = data.meSide;
            }
            if (data.opMain != null) {
                message.opMain = data.opMain;
            }
            if (data.opExtra != null) {
                message.opExtra = data.opExtra;
            }
            if (data.opSide != null) {
                message.opSide = data.opSide;
            }
            return message;
        }
        toObject() {
            const data: {
                meMain?: number;
                meExtra?: number;
                meSide?: number;
                opMain?: number;
                opExtra?: number;
                opSide?: number;
            } = {};
            if (this.meMain != null) {
                data.meMain = this.meMain;
            }
            if (this.meExtra != null) {
                data.meExtra = this.meExtra;
            }
            if (this.meSide != null) {
                data.meSide = this.meSide;
            }
            if (this.opMain != null) {
                data.opMain = this.opMain;
            }
            if (this.opExtra != null) {
                data.opExtra = this.opExtra;
            }
            if (this.opSide != null) {
                data.opSide = this.opSide;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.meMain != 0)
                writer.writeInt32(1, this.meMain);
            if (this.meExtra != 0)
                writer.writeInt32(2, this.meExtra);
            if (this.meSide != 0)
                writer.writeInt32(3, this.meSide);
            if (this.opMain != 0)
                writer.writeInt32(4, this.opMain);
            if (this.opExtra != 0)
                writer.writeInt32(5, this.opExtra);
            if (this.opSide != 0)
                writer.writeInt32(6, this.opSide);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): StocDeckCount {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new StocDeckCount();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.meMain = reader.readInt32();
                        break;
                    case 2:
                        message.meExtra = reader.readInt32();
                        break;
                    case 3:
                        message.meSide = reader.readInt32();
                        break;
                    case 4:
                        message.opMain = reader.readInt32();
                        break;
                    case 5:
                        message.opExtra = reader.readInt32();
                        break;
                    case 6:
                        message.opSide = reader.readInt32();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): StocDeckCount {
            return StocDeckCount.deserialize(bytes);
        }
    }
    export class StocChangeSide extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {}) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") { }
        }
        static fromObject(data: {}): StocChangeSide {
            const message = new StocChangeSide({});
            return message;
        }
        toObject() {
            const data: {} = {};
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): StocChangeSide {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new StocChangeSide();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): StocChangeSide {
            return StocChangeSide.deserialize(bytes);
        }
    }
    export class StocWaitingSide extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {}) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") { }
        }
        static fromObject(data: {}): StocWaitingSide {
            const message = new StocWaitingSide({});
            return message;
        }
        toObject() {
            const data: {} = {};
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): StocWaitingSide {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new StocWaitingSide();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): StocWaitingSide {
            return StocWaitingSide.deserialize(bytes);
        }
    }
    export class StocDuelStart extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {}) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") { }
        }
        static fromObject(data: {}): StocDuelStart {
            const message = new StocDuelStart({});
            return message;
        }
        toObject() {
            const data: {} = {};
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): StocDuelStart {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new StocDuelStart();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): StocDuelStart {
            return StocDuelStart.deserialize(bytes);
        }
    }
    export class StocDuelEnd extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {}) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") { }
        }
        static fromObject(data: {}): StocDuelEnd {
            const message = new StocDuelEnd({});
            return message;
        }
        toObject() {
            const data: {} = {};
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): StocDuelEnd {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new StocDuelEnd();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): StocDuelEnd {
            return StocDuelEnd.deserialize(bytes);
        }
    }
    export class StocTimeLimit extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            player?: number;
            left_time?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("player" in data && data.player != undefined) {
                    this.player = data.player;
                }
                if ("left_time" in data && data.left_time != undefined) {
                    this.left_time = data.left_time;
                }
            }
        }
        get player() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set player(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get left_time() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set left_time(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            player?: number;
            left_time?: number;
        }): StocTimeLimit {
            const message = new StocTimeLimit({});
            if (data.player != null) {
                message.player = data.player;
            }
            if (data.left_time != null) {
                message.left_time = data.left_time;
            }
            return message;
        }
        toObject() {
            const data: {
                player?: number;
                left_time?: number;
            } = {};
            if (this.player != null) {
                data.player = this.player;
            }
            if (this.left_time != null) {
                data.left_time = this.left_time;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.player != 0)
                writer.writeInt32(1, this.player);
            if (this.left_time != 0)
                writer.writeInt32(2, this.left_time);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): StocTimeLimit {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new StocTimeLimit();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.player = reader.readInt32();
                        break;
                    case 2:
                        message.left_time = reader.readInt32();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): StocTimeLimit {
            return StocTimeLimit.deserialize(bytes);
        }
    }
    export class StocGameMessage extends pb_1.Message {
        #one_of_decls: number[][] = [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54]];
        constructor(data?: any[] | ({} & (({
            start?: StocGameMessage.MsgStart;
            draw?: never;
            new_turn?: never;
            new_phase?: never;
            hint?: never;
            select_idle_cmd?: never;
            select_place?: never;
            move?: never;
            select_card?: never;
            select_chain?: never;
            select_effect_yn?: never;
            select_position?: never;
            select_option?: never;
            shuffle_hand_extra?: never;
            select_battle_cmd?: never;
            pos_change?: never;
            select_unselect_card?: never;
            select_yes_no?: never;
            update_hp?: never;
            win?: never;
            wait?: never;
            unimplemented?: never;
            update_data?: never;
            reload_field?: never;
            select_sum?: never;
            select_tribute?: never;
            update_counter?: never;
            select_counter?: never;
            sort_card?: never;
            set?: never;
            swap?: never;
            summoning?: never;
            summoned?: never;
            flip_summoning?: never;
            flip_summoned?: never;
            sp_summoning?: never;
            sp_summoned?: never;
            chaining?: never;
            attack?: never;
            attack_disable?: never;
            chain_solved?: never;
            chain_end?: never;
            announce?: never;
            lp_update?: never;
            confirm_cards?: never;
            become_target?: never;
            toss?: never;
            shuffle_set_card?: never;
            field_disabled?: never;
            shuffle_deck?: never;
            rock_paper_scissors?: never;
            hand_res?: never;
            swap_grave_deck?: never;
            sibyl_name?: never;
        } | {
            start?: never;
            draw?: StocGameMessage.MsgDraw;
            new_turn?: never;
            new_phase?: never;
            hint?: never;
            select_idle_cmd?: never;
            select_place?: never;
            move?: never;
            select_card?: never;
            select_chain?: never;
            select_effect_yn?: never;
            select_position?: never;
            select_option?: never;
            shuffle_hand_extra?: never;
            select_battle_cmd?: never;
            pos_change?: never;
            select_unselect_card?: never;
            select_yes_no?: never;
            update_hp?: never;
            win?: never;
            wait?: never;
            unimplemented?: never;
            update_data?: never;
            reload_field?: never;
            select_sum?: never;
            select_tribute?: never;
            update_counter?: never;
            select_counter?: never;
            sort_card?: never;
            set?: never;
            swap?: never;
            summoning?: never;
            summoned?: never;
            flip_summoning?: never;
            flip_summoned?: never;
            sp_summoning?: never;
            sp_summoned?: never;
            chaining?: never;
            attack?: never;
            attack_disable?: never;
            chain_solved?: never;
            chain_end?: never;
            announce?: never;
            lp_update?: never;
            confirm_cards?: never;
            become_target?: never;
            toss?: never;
            shuffle_set_card?: never;
            field_disabled?: never;
            shuffle_deck?: never;
            rock_paper_scissors?: never;
            hand_res?: never;
            swap_grave_deck?: never;
            sibyl_name?: never;
        } | {
            start?: never;
            draw?: never;
            new_turn?: StocGameMessage.MsgNewTurn;
            new_phase?: never;
            hint?: never;
            select_idle_cmd?: never;
            select_place?: never;
            move?: never;
            select_card?: never;
            select_chain?: never;
            select_effect_yn?: never;
            select_position?: never;
            select_option?: never;
            shuffle_hand_extra?: never;
            select_battle_cmd?: never;
            pos_change?: never;
            select_unselect_card?: never;
            select_yes_no?: never;
            update_hp?: never;
            win?: never;
            wait?: never;
            unimplemented?: never;
            update_data?: never;
            reload_field?: never;
            select_sum?: never;
            select_tribute?: never;
            update_counter?: never;
            select_counter?: never;
            sort_card?: never;
            set?: never;
            swap?: never;
            summoning?: never;
            summoned?: never;
            flip_summoning?: never;
            flip_summoned?: never;
            sp_summoning?: never;
            sp_summoned?: never;
            chaining?: never;
            attack?: never;
            attack_disable?: never;
            chain_solved?: never;
            chain_end?: never;
            announce?: never;
            lp_update?: never;
            confirm_cards?: never;
            become_target?: never;
            toss?: never;
            shuffle_set_card?: never;
            field_disabled?: never;
            shuffle_deck?: never;
            rock_paper_scissors?: never;
            hand_res?: never;
            swap_grave_deck?: never;
            sibyl_name?: never;
        } | {
            start?: never;
            draw?: never;
            new_turn?: never;
            new_phase?: StocGameMessage.MsgNewPhase;
            hint?: never;
            select_idle_cmd?: never;
            select_place?: never;
            move?: never;
            select_card?: never;
            select_chain?: never;
            select_effect_yn?: never;
            select_position?: never;
            select_option?: never;
            shuffle_hand_extra?: never;
            select_battle_cmd?: never;
            pos_change?: never;
            select_unselect_card?: never;
            select_yes_no?: never;
            update_hp?: never;
            win?: never;
            wait?: never;
            unimplemented?: never;
            update_data?: never;
            reload_field?: never;
            select_sum?: never;
            select_tribute?: never;
            update_counter?: never;
            select_counter?: never;
            sort_card?: never;
            set?: never;
            swap?: never;
            summoning?: never;
            summoned?: never;
            flip_summoning?: never;
            flip_summoned?: never;
            sp_summoning?: never;
            sp_summoned?: never;
            chaining?: never;
            attack?: never;
            attack_disable?: never;
            chain_solved?: never;
            chain_end?: never;
            announce?: never;
            lp_update?: never;
            confirm_cards?: never;
            become_target?: never;
            toss?: never;
            shuffle_set_card?: never;
            field_disabled?: never;
            shuffle_deck?: never;
            rock_paper_scissors?: never;
            hand_res?: never;
            swap_grave_deck?: never;
            sibyl_name?: never;
        } | {
            start?: never;
            draw?: never;
            new_turn?: never;
            new_phase?: never;
            hint?: StocGameMessage.MsgHint;
            select_idle_cmd?: never;
            select_place?: never;
            move?: never;
            select_card?: never;
            select_chain?: never;
            select_effect_yn?: never;
            select_position?: never;
            select_option?: never;
            shuffle_hand_extra?: never;
            select_battle_cmd?: never;
            pos_change?: never;
            select_unselect_card?: never;
            select_yes_no?: never;
            update_hp?: never;
            win?: never;
            wait?: never;
            unimplemented?: never;
            update_data?: never;
            reload_field?: never;
            select_sum?: never;
            select_tribute?: never;
            update_counter?: never;
            select_counter?: never;
            sort_card?: never;
            set?: never;
            swap?: never;
            summoning?: never;
            summoned?: never;
            flip_summoning?: never;
            flip_summoned?: never;
            sp_summoning?: never;
            sp_summoned?: never;
            chaining?: never;
            attack?: never;
            attack_disable?: never;
            chain_solved?: never;
            chain_end?: never;
            announce?: never;
            lp_update?: never;
            confirm_cards?: never;
            become_target?: never;
            toss?: never;
            shuffle_set_card?: never;
            field_disabled?: never;
            shuffle_deck?: never;
            rock_paper_scissors?: never;
            hand_res?: never;
            swap_grave_deck?: never;
            sibyl_name?: never;
        } | {
            start?: never;
            draw?: never;
            new_turn?: never;
            new_phase?: never;
            hint?: never;
            select_idle_cmd?: StocGameMessage.MsgSelectIdleCmd;
            select_place?: never;
            move?: never;
            select_card?: never;
            select_chain?: never;
            select_effect_yn?: never;
            select_position?: never;
            select_option?: never;
            shuffle_hand_extra?: never;
            select_battle_cmd?: never;
            pos_change?: never;
            select_unselect_card?: never;
            select_yes_no?: never;
            update_hp?: never;
            win?: never;
            wait?: never;
            unimplemented?: never;
            update_data?: never;
            reload_field?: never;
            select_sum?: never;
            select_tribute?: never;
            update_counter?: never;
            select_counter?: never;
            sort_card?: never;
            set?: never;
            swap?: never;
            summoning?: never;
            summoned?: never;
            flip_summoning?: never;
            flip_summoned?: never;
            sp_summoning?: never;
            sp_summoned?: never;
            chaining?: never;
            attack?: never;
            attack_disable?: never;
            chain_solved?: never;
            chain_end?: never;
            announce?: never;
            lp_update?: never;
            confirm_cards?: never;
            become_target?: never;
            toss?: never;
            shuffle_set_card?: never;
            field_disabled?: never;
            shuffle_deck?: never;
            rock_paper_scissors?: never;
            hand_res?: never;
            swap_grave_deck?: never;
            sibyl_name?: never;
        } | {
            start?: never;
            draw?: never;
            new_turn?: never;
            new_phase?: never;
            hint?: never;
            select_idle_cmd?: never;
            select_place?: StocGameMessage.MsgSelectPlace;
            move?: never;
            select_card?: never;
            select_chain?: never;
            select_effect_yn?: never;
            select_position?: never;
            select_option?: never;
            shuffle_hand_extra?: never;
            select_battle_cmd?: never;
            pos_change?: never;
            select_unselect_card?: never;
            select_yes_no?: never;
            update_hp?: never;
            win?: never;
            wait?: never;
            unimplemented?: never;
            update_data?: never;
            reload_field?: never;
            select_sum?: never;
            select_tribute?: never;
            update_counter?: never;
            select_counter?: never;
            sort_card?: never;
            set?: never;
            swap?: never;
            summoning?: never;
            summoned?: never;
            flip_summoning?: never;
            flip_summoned?: never;
            sp_summoning?: never;
            sp_summoned?: never;
            chaining?: never;
            attack?: never;
            attack_disable?: never;
            chain_solved?: never;
            chain_end?: never;
            announce?: never;
            lp_update?: never;
            confirm_cards?: never;
            become_target?: never;
            toss?: never;
            shuffle_set_card?: never;
            field_disabled?: never;
            shuffle_deck?: never;
            rock_paper_scissors?: never;
            hand_res?: never;
            swap_grave_deck?: never;
            sibyl_name?: never;
        } | {
            start?: never;
            draw?: never;
            new_turn?: never;
            new_phase?: never;
            hint?: never;
            select_idle_cmd?: never;
            select_place?: never;
            move?: StocGameMessage.MsgMove;
            select_card?: never;
            select_chain?: never;
            select_effect_yn?: never;
            select_position?: never;
            select_option?: never;
            shuffle_hand_extra?: never;
            select_battle_cmd?: never;
            pos_change?: never;
            select_unselect_card?: never;
            select_yes_no?: never;
            update_hp?: never;
            win?: never;
            wait?: never;
            unimplemented?: never;
            update_data?: never;
            reload_field?: never;
            select_sum?: never;
            select_tribute?: never;
            update_counter?: never;
            select_counter?: never;
            sort_card?: never;
            set?: never;
            swap?: never;
            summoning?: never;
            summoned?: never;
            flip_summoning?: never;
            flip_summoned?: never;
            sp_summoning?: never;
            sp_summoned?: never;
            chaining?: never;
            attack?: never;
            attack_disable?: never;
            chain_solved?: never;
            chain_end?: never;
            announce?: never;
            lp_update?: never;
            confirm_cards?: never;
            become_target?: never;
            toss?: never;
            shuffle_set_card?: never;
            field_disabled?: never;
            shuffle_deck?: never;
            rock_paper_scissors?: never;
            hand_res?: never;
            swap_grave_deck?: never;
            sibyl_name?: never;
        } | {
            start?: never;
            draw?: never;
            new_turn?: never;
            new_phase?: never;
            hint?: never;
            select_idle_cmd?: never;
            select_place?: never;
            move?: never;
            select_card?: StocGameMessage.MsgSelectCard;
            select_chain?: never;
            select_effect_yn?: never;
            select_position?: never;
            select_option?: never;
            shuffle_hand_extra?: never;
            select_battle_cmd?: never;
            pos_change?: never;
            select_unselect_card?: never;
            select_yes_no?: never;
            update_hp?: never;
            win?: never;
            wait?: never;
            unimplemented?: never;
            update_data?: never;
            reload_field?: never;
            select_sum?: never;
            select_tribute?: never;
            update_counter?: never;
            select_counter?: never;
            sort_card?: never;
            set?: never;
            swap?: never;
            summoning?: never;
            summoned?: never;
            flip_summoning?: never;
            flip_summoned?: never;
            sp_summoning?: never;
            sp_summoned?: never;
            chaining?: never;
            attack?: never;
            attack_disable?: never;
            chain_solved?: never;
            chain_end?: never;
            announce?: never;
            lp_update?: never;
            confirm_cards?: never;
            become_target?: never;
            toss?: never;
            shuffle_set_card?: never;
            field_disabled?: never;
            shuffle_deck?: never;
            rock_paper_scissors?: never;
            hand_res?: never;
            swap_grave_deck?: never;
            sibyl_name?: never;
        } | {
            start?: never;
            draw?: never;
            new_turn?: never;
            new_phase?: never;
            hint?: never;
            select_idle_cmd?: never;
            select_place?: never;
            move?: never;
            select_card?: never;
            select_chain?: StocGameMessage.MsgSelectChain;
            select_effect_yn?: never;
            select_position?: never;
            select_option?: never;
            shuffle_hand_extra?: never;
            select_battle_cmd?: never;
            pos_change?: never;
            select_unselect_card?: never;
            select_yes_no?: never;
            update_hp?: never;
            win?: never;
            wait?: never;
            unimplemented?: never;
            update_data?: never;
            reload_field?: never;
            select_sum?: never;
            select_tribute?: never;
            update_counter?: never;
            select_counter?: never;
            sort_card?: never;
            set?: never;
            swap?: never;
            summoning?: never;
            summoned?: never;
            flip_summoning?: never;
            flip_summoned?: never;
            sp_summoning?: never;
            sp_summoned?: never;
            chaining?: never;
            attack?: never;
            attack_disable?: never;
            chain_solved?: never;
            chain_end?: never;
            announce?: never;
            lp_update?: never;
            confirm_cards?: never;
            become_target?: never;
            toss?: never;
            shuffle_set_card?: never;
            field_disabled?: never;
            shuffle_deck?: never;
            rock_paper_scissors?: never;
            hand_res?: never;
            swap_grave_deck?: never;
            sibyl_name?: never;
        } | {
            start?: never;
            draw?: never;
            new_turn?: never;
            new_phase?: never;
            hint?: never;
            select_idle_cmd?: never;
            select_place?: never;
            move?: never;
            select_card?: never;
            select_chain?: never;
            select_effect_yn?: StocGameMessage.MsgSelectEffectYn;
            select_position?: never;
            select_option?: never;
            shuffle_hand_extra?: never;
            select_battle_cmd?: never;
            pos_change?: never;
            select_unselect_card?: never;
            select_yes_no?: never;
            update_hp?: never;
            win?: never;
            wait?: never;
            unimplemented?: never;
            update_data?: never;
            reload_field?: never;
            select_sum?: never;
            select_tribute?: never;
            update_counter?: never;
            select_counter?: never;
            sort_card?: never;
            set?: never;
            swap?: never;
            summoning?: never;
            summoned?: never;
            flip_summoning?: never;
            flip_summoned?: never;
            sp_summoning?: never;
            sp_summoned?: never;
            chaining?: never;
            attack?: never;
            attack_disable?: never;
            chain_solved?: never;
            chain_end?: never;
            announce?: never;
            lp_update?: never;
            confirm_cards?: never;
            become_target?: never;
            toss?: never;
            shuffle_set_card?: never;
            field_disabled?: never;
            shuffle_deck?: never;
            rock_paper_scissors?: never;
            hand_res?: never;
            swap_grave_deck?: never;
            sibyl_name?: never;
        } | {
            start?: never;
            draw?: never;
            new_turn?: never;
            new_phase?: never;
            hint?: never;
            select_idle_cmd?: never;
            select_place?: never;
            move?: never;
            select_card?: never;
            select_chain?: never;
            select_effect_yn?: never;
            select_position?: StocGameMessage.MsgSelectPosition;
            select_option?: never;
            shuffle_hand_extra?: never;
            select_battle_cmd?: never;
            pos_change?: never;
            select_unselect_card?: never;
            select_yes_no?: never;
            update_hp?: never;
            win?: never;
            wait?: never;
            unimplemented?: never;
            update_data?: never;
            reload_field?: never;
            select_sum?: never;
            select_tribute?: never;
            update_counter?: never;
            select_counter?: never;
            sort_card?: never;
            set?: never;
            swap?: never;
            summoning?: never;
            summoned?: never;
            flip_summoning?: never;
            flip_summoned?: never;
            sp_summoning?: never;
            sp_summoned?: never;
            chaining?: never;
            attack?: never;
            attack_disable?: never;
            chain_solved?: never;
            chain_end?: never;
            announce?: never;
            lp_update?: never;
            confirm_cards?: never;
            become_target?: never;
            toss?: never;
            shuffle_set_card?: never;
            field_disabled?: never;
            shuffle_deck?: never;
            rock_paper_scissors?: never;
            hand_res?: never;
            swap_grave_deck?: never;
            sibyl_name?: never;
        } | {
            start?: never;
            draw?: never;
            new_turn?: never;
            new_phase?: never;
            hint?: never;
            select_idle_cmd?: never;
            select_place?: never;
            move?: never;
            select_card?: never;
            select_chain?: never;
            select_effect_yn?: never;
            select_position?: never;
            select_option?: StocGameMessage.MsgSelectOption;
            shuffle_hand_extra?: never;
            select_battle_cmd?: never;
            pos_change?: never;
            select_unselect_card?: never;
            select_yes_no?: never;
            update_hp?: never;
            win?: never;
            wait?: never;
            unimplemented?: never;
            update_data?: never;
            reload_field?: never;
            select_sum?: never;
            select_tribute?: never;
            update_counter?: never;
            select_counter?: never;
            sort_card?: never;
            set?: never;
            swap?: never;
            summoning?: never;
            summoned?: never;
            flip_summoning?: never;
            flip_summoned?: never;
            sp_summoning?: never;
            sp_summoned?: never;
            chaining?: never;
            attack?: never;
            attack_disable?: never;
            chain_solved?: never;
            chain_end?: never;
            announce?: never;
            lp_update?: never;
            confirm_cards?: never;
            become_target?: never;
            toss?: never;
            shuffle_set_card?: never;
            field_disabled?: never;
            shuffle_deck?: never;
            rock_paper_scissors?: never;
            hand_res?: never;
            swap_grave_deck?: never;
            sibyl_name?: never;
        } | {
            start?: never;
            draw?: never;
            new_turn?: never;
            new_phase?: never;
            hint?: never;
            select_idle_cmd?: never;
            select_place?: never;
            move?: never;
            select_card?: never;
            select_chain?: never;
            select_effect_yn?: never;
            select_position?: never;
            select_option?: never;
            shuffle_hand_extra?: StocGameMessage.MsgShuffleHandExtra;
            select_battle_cmd?: never;
            pos_change?: never;
            select_unselect_card?: never;
            select_yes_no?: never;
            update_hp?: never;
            win?: never;
            wait?: never;
            unimplemented?: never;
            update_data?: never;
            reload_field?: never;
            select_sum?: never;
            select_tribute?: never;
            update_counter?: never;
            select_counter?: never;
            sort_card?: never;
            set?: never;
            swap?: never;
            summoning?: never;
            summoned?: never;
            flip_summoning?: never;
            flip_summoned?: never;
            sp_summoning?: never;
            sp_summoned?: never;
            chaining?: never;
            attack?: never;
            attack_disable?: never;
            chain_solved?: never;
            chain_end?: never;
            announce?: never;
            lp_update?: never;
            confirm_cards?: never;
            become_target?: never;
            toss?: never;
            shuffle_set_card?: never;
            field_disabled?: never;
            shuffle_deck?: never;
            rock_paper_scissors?: never;
            hand_res?: never;
            swap_grave_deck?: never;
            sibyl_name?: never;
        } | {
            start?: never;
            draw?: never;
            new_turn?: never;
            new_phase?: never;
            hint?: never;
            select_idle_cmd?: never;
            select_place?: never;
            move?: never;
            select_card?: never;
            select_chain?: never;
            select_effect_yn?: never;
            select_position?: never;
            select_option?: never;
            shuffle_hand_extra?: never;
            select_battle_cmd?: StocGameMessage.MsgSelectBattleCmd;
            pos_change?: never;
            select_unselect_card?: never;
            select_yes_no?: never;
            update_hp?: never;
            win?: never;
            wait?: never;
            unimplemented?: never;
            update_data?: never;
            reload_field?: never;
            select_sum?: never;
            select_tribute?: never;
            update_counter?: never;
            select_counter?: never;
            sort_card?: never;
            set?: never;
            swap?: never;
            summoning?: never;
            summoned?: never;
            flip_summoning?: never;
            flip_summoned?: never;
            sp_summoning?: never;
            sp_summoned?: never;
            chaining?: never;
            attack?: never;
            attack_disable?: never;
            chain_solved?: never;
            chain_end?: never;
            announce?: never;
            lp_update?: never;
            confirm_cards?: never;
            become_target?: never;
            toss?: never;
            shuffle_set_card?: never;
            field_disabled?: never;
            shuffle_deck?: never;
            rock_paper_scissors?: never;
            hand_res?: never;
            swap_grave_deck?: never;
            sibyl_name?: never;
        } | {
            start?: never;
            draw?: never;
            new_turn?: never;
            new_phase?: never;
            hint?: never;
            select_idle_cmd?: never;
            select_place?: never;
            move?: never;
            select_card?: never;
            select_chain?: never;
            select_effect_yn?: never;
            select_position?: never;
            select_option?: never;
            shuffle_hand_extra?: never;
            select_battle_cmd?: never;
            pos_change?: StocGameMessage.MsgPosChange;
            select_unselect_card?: never;
            select_yes_no?: never;
            update_hp?: never;
            win?: never;
            wait?: never;
            unimplemented?: never;
            update_data?: never;
            reload_field?: never;
            select_sum?: never;
            select_tribute?: never;
            update_counter?: never;
            select_counter?: never;
            sort_card?: never;
            set?: never;
            swap?: never;
            summoning?: never;
            summoned?: never;
            flip_summoning?: never;
            flip_summoned?: never;
            sp_summoning?: never;
            sp_summoned?: never;
            chaining?: never;
            attack?: never;
            attack_disable?: never;
            chain_solved?: never;
            chain_end?: never;
            announce?: never;
            lp_update?: never;
            confirm_cards?: never;
            become_target?: never;
            toss?: never;
            shuffle_set_card?: never;
            field_disabled?: never;
            shuffle_deck?: never;
            rock_paper_scissors?: never;
            hand_res?: never;
            swap_grave_deck?: never;
            sibyl_name?: never;
        } | {
            start?: never;
            draw?: never;
            new_turn?: never;
            new_phase?: never;
            hint?: never;
            select_idle_cmd?: never;
            select_place?: never;
            move?: never;
            select_card?: never;
            select_chain?: never;
            select_effect_yn?: never;
            select_position?: never;
            select_option?: never;
            shuffle_hand_extra?: never;
            select_battle_cmd?: never;
            pos_change?: never;
            select_unselect_card?: StocGameMessage.MsgSelectUnselectCard;
            select_yes_no?: never;
            update_hp?: never;
            win?: never;
            wait?: never;
            unimplemented?: never;
            update_data?: never;
            reload_field?: never;
            select_sum?: never;
            select_tribute?: never;
            update_counter?: never;
            select_counter?: never;
            sort_card?: never;
            set?: never;
            swap?: never;
            summoning?: never;
            summoned?: never;
            flip_summoning?: never;
            flip_summoned?: never;
            sp_summoning?: never;
            sp_summoned?: never;
            chaining?: never;
            attack?: never;
            attack_disable?: never;
            chain_solved?: never;
            chain_end?: never;
            announce?: never;
            lp_update?: never;
            confirm_cards?: never;
            become_target?: never;
            toss?: never;
            shuffle_set_card?: never;
            field_disabled?: never;
            shuffle_deck?: never;
            rock_paper_scissors?: never;
            hand_res?: never;
            swap_grave_deck?: never;
            sibyl_name?: never;
        } | {
            start?: never;
            draw?: never;
            new_turn?: never;
            new_phase?: never;
            hint?: never;
            select_idle_cmd?: never;
            select_place?: never;
            move?: never;
            select_card?: never;
            select_chain?: never;
            select_effect_yn?: never;
            select_position?: never;
            select_option?: never;
            shuffle_hand_extra?: never;
            select_battle_cmd?: never;
            pos_change?: never;
            select_unselect_card?: never;
            select_yes_no?: StocGameMessage.MsgSelectYesNo;
            update_hp?: never;
            win?: never;
            wait?: never;
            unimplemented?: never;
            update_data?: never;
            reload_field?: never;
            select_sum?: never;
            select_tribute?: never;
            update_counter?: never;
            select_counter?: never;
            sort_card?: never;
            set?: never;
            swap?: never;
            summoning?: never;
            summoned?: never;
            flip_summoning?: never;
            flip_summoned?: never;
            sp_summoning?: never;
            sp_summoned?: never;
            chaining?: never;
            attack?: never;
            attack_disable?: never;
            chain_solved?: never;
            chain_end?: never;
            announce?: never;
            lp_update?: never;
            confirm_cards?: never;
            become_target?: never;
            toss?: never;
            shuffle_set_card?: never;
            field_disabled?: never;
            shuffle_deck?: never;
            rock_paper_scissors?: never;
            hand_res?: never;
            swap_grave_deck?: never;
            sibyl_name?: never;
        } | {
            start?: never;
            draw?: never;
            new_turn?: never;
            new_phase?: never;
            hint?: never;
            select_idle_cmd?: never;
            select_place?: never;
            move?: never;
            select_card?: never;
            select_chain?: never;
            select_effect_yn?: never;
            select_position?: never;
            select_option?: never;
            shuffle_hand_extra?: never;
            select_battle_cmd?: never;
            pos_change?: never;
            select_unselect_card?: never;
            select_yes_no?: never;
            update_hp?: StocGameMessage.MsgUpdateHp;
            win?: never;
            wait?: never;
            unimplemented?: never;
            update_data?: never;
            reload_field?: never;
            select_sum?: never;
            select_tribute?: never;
            update_counter?: never;
            select_counter?: never;
            sort_card?: never;
            set?: never;
            swap?: never;
            summoning?: never;
            summoned?: never;
            flip_summoning?: never;
            flip_summoned?: never;
            sp_summoning?: never;
            sp_summoned?: never;
            chaining?: never;
            attack?: never;
            attack_disable?: never;
            chain_solved?: never;
            chain_end?: never;
            announce?: never;
            lp_update?: never;
            confirm_cards?: never;
            become_target?: never;
            toss?: never;
            shuffle_set_card?: never;
            field_disabled?: never;
            shuffle_deck?: never;
            rock_paper_scissors?: never;
            hand_res?: never;
            swap_grave_deck?: never;
            sibyl_name?: never;
        } | {
            start?: never;
            draw?: never;
            new_turn?: never;
            new_phase?: never;
            hint?: never;
            select_idle_cmd?: never;
            select_place?: never;
            move?: never;
            select_card?: never;
            select_chain?: never;
            select_effect_yn?: never;
            select_position?: never;
            select_option?: never;
            shuffle_hand_extra?: never;
            select_battle_cmd?: never;
            pos_change?: never;
            select_unselect_card?: never;
            select_yes_no?: never;
            update_hp?: never;
            win?: StocGameMessage.MsgWin;
            wait?: never;
            unimplemented?: never;
            update_data?: never;
            reload_field?: never;
            select_sum?: never;
            select_tribute?: never;
            update_counter?: never;
            select_counter?: never;
            sort_card?: never;
            set?: never;
            swap?: never;
            summoning?: never;
            summoned?: never;
            flip_summoning?: never;
            flip_summoned?: never;
            sp_summoning?: never;
            sp_summoned?: never;
            chaining?: never;
            attack?: never;
            attack_disable?: never;
            chain_solved?: never;
            chain_end?: never;
            announce?: never;
            lp_update?: never;
            confirm_cards?: never;
            become_target?: never;
            toss?: never;
            shuffle_set_card?: never;
            field_disabled?: never;
            shuffle_deck?: never;
            rock_paper_scissors?: never;
            hand_res?: never;
            swap_grave_deck?: never;
            sibyl_name?: never;
        } | {
            start?: never;
            draw?: never;
            new_turn?: never;
            new_phase?: never;
            hint?: never;
            select_idle_cmd?: never;
            select_place?: never;
            move?: never;
            select_card?: never;
            select_chain?: never;
            select_effect_yn?: never;
            select_position?: never;
            select_option?: never;
            shuffle_hand_extra?: never;
            select_battle_cmd?: never;
            pos_change?: never;
            select_unselect_card?: never;
            select_yes_no?: never;
            update_hp?: never;
            win?: never;
            wait?: StocGameMessage.MsgWait;
            unimplemented?: never;
            update_data?: never;
            reload_field?: never;
            select_sum?: never;
            select_tribute?: never;
            update_counter?: never;
            select_counter?: never;
            sort_card?: never;
            set?: never;
            swap?: never;
            summoning?: never;
            summoned?: never;
            flip_summoning?: never;
            flip_summoned?: never;
            sp_summoning?: never;
            sp_summoned?: never;
            chaining?: never;
            attack?: never;
            attack_disable?: never;
            chain_solved?: never;
            chain_end?: never;
            announce?: never;
            lp_update?: never;
            confirm_cards?: never;
            become_target?: never;
            toss?: never;
            shuffle_set_card?: never;
            field_disabled?: never;
            shuffle_deck?: never;
            rock_paper_scissors?: never;
            hand_res?: never;
            swap_grave_deck?: never;
            sibyl_name?: never;
        } | {
            start?: never;
            draw?: never;
            new_turn?: never;
            new_phase?: never;
            hint?: never;
            select_idle_cmd?: never;
            select_place?: never;
            move?: never;
            select_card?: never;
            select_chain?: never;
            select_effect_yn?: never;
            select_position?: never;
            select_option?: never;
            shuffle_hand_extra?: never;
            select_battle_cmd?: never;
            pos_change?: never;
            select_unselect_card?: never;
            select_yes_no?: never;
            update_hp?: never;
            win?: never;
            wait?: never;
            unimplemented?: StocGameMessage.MsgUnimplemented;
            update_data?: never;
            reload_field?: never;
            select_sum?: never;
            select_tribute?: never;
            update_counter?: never;
            select_counter?: never;
            sort_card?: never;
            set?: never;
            swap?: never;
            summoning?: never;
            summoned?: never;
            flip_summoning?: never;
            flip_summoned?: never;
            sp_summoning?: never;
            sp_summoned?: never;
            chaining?: never;
            attack?: never;
            attack_disable?: never;
            chain_solved?: never;
            chain_end?: never;
            announce?: never;
            lp_update?: never;
            confirm_cards?: never;
            become_target?: never;
            toss?: never;
            shuffle_set_card?: never;
            field_disabled?: never;
            shuffle_deck?: never;
            rock_paper_scissors?: never;
            hand_res?: never;
            swap_grave_deck?: never;
            sibyl_name?: never;
        } | {
            start?: never;
            draw?: never;
            new_turn?: never;
            new_phase?: never;
            hint?: never;
            select_idle_cmd?: never;
            select_place?: never;
            move?: never;
            select_card?: never;
            select_chain?: never;
            select_effect_yn?: never;
            select_position?: never;
            select_option?: never;
            shuffle_hand_extra?: never;
            select_battle_cmd?: never;
            pos_change?: never;
            select_unselect_card?: never;
            select_yes_no?: never;
            update_hp?: never;
            win?: never;
            wait?: never;
            unimplemented?: never;
            update_data?: StocGameMessage.MsgUpdateData;
            reload_field?: never;
            select_sum?: never;
            select_tribute?: never;
            update_counter?: never;
            select_counter?: never;
            sort_card?: never;
            set?: never;
            swap?: never;
            summoning?: never;
            summoned?: never;
            flip_summoning?: never;
            flip_summoned?: never;
            sp_summoning?: never;
            sp_summoned?: never;
            chaining?: never;
            attack?: never;
            attack_disable?: never;
            chain_solved?: never;
            chain_end?: never;
            announce?: never;
            lp_update?: never;
            confirm_cards?: never;
            become_target?: never;
            toss?: never;
            shuffle_set_card?: never;
            field_disabled?: never;
            shuffle_deck?: never;
            rock_paper_scissors?: never;
            hand_res?: never;
            swap_grave_deck?: never;
            sibyl_name?: never;
        } | {
            start?: never;
            draw?: never;
            new_turn?: never;
            new_phase?: never;
            hint?: never;
            select_idle_cmd?: never;
            select_place?: never;
            move?: never;
            select_card?: never;
            select_chain?: never;
            select_effect_yn?: never;
            select_position?: never;
            select_option?: never;
            shuffle_hand_extra?: never;
            select_battle_cmd?: never;
            pos_change?: never;
            select_unselect_card?: never;
            select_yes_no?: never;
            update_hp?: never;
            win?: never;
            wait?: never;
            unimplemented?: never;
            update_data?: never;
            reload_field?: StocGameMessage.MsgReloadField;
            select_sum?: never;
            select_tribute?: never;
            update_counter?: never;
            select_counter?: never;
            sort_card?: never;
            set?: never;
            swap?: never;
            summoning?: never;
            summoned?: never;
            flip_summoning?: never;
            flip_summoned?: never;
            sp_summoning?: never;
            sp_summoned?: never;
            chaining?: never;
            attack?: never;
            attack_disable?: never;
            chain_solved?: never;
            chain_end?: never;
            announce?: never;
            lp_update?: never;
            confirm_cards?: never;
            become_target?: never;
            toss?: never;
            shuffle_set_card?: never;
            field_disabled?: never;
            shuffle_deck?: never;
            rock_paper_scissors?: never;
            hand_res?: never;
            swap_grave_deck?: never;
            sibyl_name?: never;
        } | {
            start?: never;
            draw?: never;
            new_turn?: never;
            new_phase?: never;
            hint?: never;
            select_idle_cmd?: never;
            select_place?: never;
            move?: never;
            select_card?: never;
            select_chain?: never;
            select_effect_yn?: never;
            select_position?: never;
            select_option?: never;
            shuffle_hand_extra?: never;
            select_battle_cmd?: never;
            pos_change?: never;
            select_unselect_card?: never;
            select_yes_no?: never;
            update_hp?: never;
            win?: never;
            wait?: never;
            unimplemented?: never;
            update_data?: never;
            reload_field?: never;
            select_sum?: StocGameMessage.MsgSelectSum;
            select_tribute?: never;
            update_counter?: never;
            select_counter?: never;
            sort_card?: never;
            set?: never;
            swap?: never;
            summoning?: never;
            summoned?: never;
            flip_summoning?: never;
            flip_summoned?: never;
            sp_summoning?: never;
            sp_summoned?: never;
            chaining?: never;
            attack?: never;
            attack_disable?: never;
            chain_solved?: never;
            chain_end?: never;
            announce?: never;
            lp_update?: never;
            confirm_cards?: never;
            become_target?: never;
            toss?: never;
            shuffle_set_card?: never;
            field_disabled?: never;
            shuffle_deck?: never;
            rock_paper_scissors?: never;
            hand_res?: never;
            swap_grave_deck?: never;
            sibyl_name?: never;
        } | {
            start?: never;
            draw?: never;
            new_turn?: never;
            new_phase?: never;
            hint?: never;
            select_idle_cmd?: never;
            select_place?: never;
            move?: never;
            select_card?: never;
            select_chain?: never;
            select_effect_yn?: never;
            select_position?: never;
            select_option?: never;
            shuffle_hand_extra?: never;
            select_battle_cmd?: never;
            pos_change?: never;
            select_unselect_card?: never;
            select_yes_no?: never;
            update_hp?: never;
            win?: never;
            wait?: never;
            unimplemented?: never;
            update_data?: never;
            reload_field?: never;
            select_sum?: never;
            select_tribute?: StocGameMessage.MsgSelectTribute;
            update_counter?: never;
            select_counter?: never;
            sort_card?: never;
            set?: never;
            swap?: never;
            summoning?: never;
            summoned?: never;
            flip_summoning?: never;
            flip_summoned?: never;
            sp_summoning?: never;
            sp_summoned?: never;
            chaining?: never;
            attack?: never;
            attack_disable?: never;
            chain_solved?: never;
            chain_end?: never;
            announce?: never;
            lp_update?: never;
            confirm_cards?: never;
            become_target?: never;
            toss?: never;
            shuffle_set_card?: never;
            field_disabled?: never;
            shuffle_deck?: never;
            rock_paper_scissors?: never;
            hand_res?: never;
            swap_grave_deck?: never;
            sibyl_name?: never;
        } | {
            start?: never;
            draw?: never;
            new_turn?: never;
            new_phase?: never;
            hint?: never;
            select_idle_cmd?: never;
            select_place?: never;
            move?: never;
            select_card?: never;
            select_chain?: never;
            select_effect_yn?: never;
            select_position?: never;
            select_option?: never;
            shuffle_hand_extra?: never;
            select_battle_cmd?: never;
            pos_change?: never;
            select_unselect_card?: never;
            select_yes_no?: never;
            update_hp?: never;
            win?: never;
            wait?: never;
            unimplemented?: never;
            update_data?: never;
            reload_field?: never;
            select_sum?: never;
            select_tribute?: never;
            update_counter?: StocGameMessage.MsgUpdateCounter;
            select_counter?: never;
            sort_card?: never;
            set?: never;
            swap?: never;
            summoning?: never;
            summoned?: never;
            flip_summoning?: never;
            flip_summoned?: never;
            sp_summoning?: never;
            sp_summoned?: never;
            chaining?: never;
            attack?: never;
            attack_disable?: never;
            chain_solved?: never;
            chain_end?: never;
            announce?: never;
            lp_update?: never;
            confirm_cards?: never;
            become_target?: never;
            toss?: never;
            shuffle_set_card?: never;
            field_disabled?: never;
            shuffle_deck?: never;
            rock_paper_scissors?: never;
            hand_res?: never;
            swap_grave_deck?: never;
            sibyl_name?: never;
        } | {
            start?: never;
            draw?: never;
            new_turn?: never;
            new_phase?: never;
            hint?: never;
            select_idle_cmd?: never;
            select_place?: never;
            move?: never;
            select_card?: never;
            select_chain?: never;
            select_effect_yn?: never;
            select_position?: never;
            select_option?: never;
            shuffle_hand_extra?: never;
            select_battle_cmd?: never;
            pos_change?: never;
            select_unselect_card?: never;
            select_yes_no?: never;
            update_hp?: never;
            win?: never;
            wait?: never;
            unimplemented?: never;
            update_data?: never;
            reload_field?: never;
            select_sum?: never;
            select_tribute?: never;
            update_counter?: never;
            select_counter?: StocGameMessage.MsgSelectCounter;
            sort_card?: never;
            set?: never;
            swap?: never;
            summoning?: never;
            summoned?: never;
            flip_summoning?: never;
            flip_summoned?: never;
            sp_summoning?: never;
            sp_summoned?: never;
            chaining?: never;
            attack?: never;
            attack_disable?: never;
            chain_solved?: never;
            chain_end?: never;
            announce?: never;
            lp_update?: never;
            confirm_cards?: never;
            become_target?: never;
            toss?: never;
            shuffle_set_card?: never;
            field_disabled?: never;
            shuffle_deck?: never;
            rock_paper_scissors?: never;
            hand_res?: never;
            swap_grave_deck?: never;
            sibyl_name?: never;
        } | {
            start?: never;
            draw?: never;
            new_turn?: never;
            new_phase?: never;
            hint?: never;
            select_idle_cmd?: never;
            select_place?: never;
            move?: never;
            select_card?: never;
            select_chain?: never;
            select_effect_yn?: never;
            select_position?: never;
            select_option?: never;
            shuffle_hand_extra?: never;
            select_battle_cmd?: never;
            pos_change?: never;
            select_unselect_card?: never;
            select_yes_no?: never;
            update_hp?: never;
            win?: never;
            wait?: never;
            unimplemented?: never;
            update_data?: never;
            reload_field?: never;
            select_sum?: never;
            select_tribute?: never;
            update_counter?: never;
            select_counter?: never;
            sort_card?: StocGameMessage.MsgSortCard;
            set?: never;
            swap?: never;
            summoning?: never;
            summoned?: never;
            flip_summoning?: never;
            flip_summoned?: never;
            sp_summoning?: never;
            sp_summoned?: never;
            chaining?: never;
            attack?: never;
            attack_disable?: never;
            chain_solved?: never;
            chain_end?: never;
            announce?: never;
            lp_update?: never;
            confirm_cards?: never;
            become_target?: never;
            toss?: never;
            shuffle_set_card?: never;
            field_disabled?: never;
            shuffle_deck?: never;
            rock_paper_scissors?: never;
            hand_res?: never;
            swap_grave_deck?: never;
            sibyl_name?: never;
        } | {
            start?: never;
            draw?: never;
            new_turn?: never;
            new_phase?: never;
            hint?: never;
            select_idle_cmd?: never;
            select_place?: never;
            move?: never;
            select_card?: never;
            select_chain?: never;
            select_effect_yn?: never;
            select_position?: never;
            select_option?: never;
            shuffle_hand_extra?: never;
            select_battle_cmd?: never;
            pos_change?: never;
            select_unselect_card?: never;
            select_yes_no?: never;
            update_hp?: never;
            win?: never;
            wait?: never;
            unimplemented?: never;
            update_data?: never;
            reload_field?: never;
            select_sum?: never;
            select_tribute?: never;
            update_counter?: never;
            select_counter?: never;
            sort_card?: never;
            set?: StocGameMessage.MsgSet;
            swap?: never;
            summoning?: never;
            summoned?: never;
            flip_summoning?: never;
            flip_summoned?: never;
            sp_summoning?: never;
            sp_summoned?: never;
            chaining?: never;
            attack?: never;
            attack_disable?: never;
            chain_solved?: never;
            chain_end?: never;
            announce?: never;
            lp_update?: never;
            confirm_cards?: never;
            become_target?: never;
            toss?: never;
            shuffle_set_card?: never;
            field_disabled?: never;
            shuffle_deck?: never;
            rock_paper_scissors?: never;
            hand_res?: never;
            swap_grave_deck?: never;
            sibyl_name?: never;
        } | {
            start?: never;
            draw?: never;
            new_turn?: never;
            new_phase?: never;
            hint?: never;
            select_idle_cmd?: never;
            select_place?: never;
            move?: never;
            select_card?: never;
            select_chain?: never;
            select_effect_yn?: never;
            select_position?: never;
            select_option?: never;
            shuffle_hand_extra?: never;
            select_battle_cmd?: never;
            pos_change?: never;
            select_unselect_card?: never;
            select_yes_no?: never;
            update_hp?: never;
            win?: never;
            wait?: never;
            unimplemented?: never;
            update_data?: never;
            reload_field?: never;
            select_sum?: never;
            select_tribute?: never;
            update_counter?: never;
            select_counter?: never;
            sort_card?: never;
            set?: never;
            swap?: StocGameMessage.MsgSwap;
            summoning?: never;
            summoned?: never;
            flip_summoning?: never;
            flip_summoned?: never;
            sp_summoning?: never;
            sp_summoned?: never;
            chaining?: never;
            attack?: never;
            attack_disable?: never;
            chain_solved?: never;
            chain_end?: never;
            announce?: never;
            lp_update?: never;
            confirm_cards?: never;
            become_target?: never;
            toss?: never;
            shuffle_set_card?: never;
            field_disabled?: never;
            shuffle_deck?: never;
            rock_paper_scissors?: never;
            hand_res?: never;
            swap_grave_deck?: never;
            sibyl_name?: never;
        } | {
            start?: never;
            draw?: never;
            new_turn?: never;
            new_phase?: never;
            hint?: never;
            select_idle_cmd?: never;
            select_place?: never;
            move?: never;
            select_card?: never;
            select_chain?: never;
            select_effect_yn?: never;
            select_position?: never;
            select_option?: never;
            shuffle_hand_extra?: never;
            select_battle_cmd?: never;
            pos_change?: never;
            select_unselect_card?: never;
            select_yes_no?: never;
            update_hp?: never;
            win?: never;
            wait?: never;
            unimplemented?: never;
            update_data?: never;
            reload_field?: never;
            select_sum?: never;
            select_tribute?: never;
            update_counter?: never;
            select_counter?: never;
            sort_card?: never;
            set?: never;
            swap?: never;
            summoning?: StocGameMessage.MsgSummoning;
            summoned?: never;
            flip_summoning?: never;
            flip_summoned?: never;
            sp_summoning?: never;
            sp_summoned?: never;
            chaining?: never;
            attack?: never;
            attack_disable?: never;
            chain_solved?: never;
            chain_end?: never;
            announce?: never;
            lp_update?: never;
            confirm_cards?: never;
            become_target?: never;
            toss?: never;
            shuffle_set_card?: never;
            field_disabled?: never;
            shuffle_deck?: never;
            rock_paper_scissors?: never;
            hand_res?: never;
            swap_grave_deck?: never;
            sibyl_name?: never;
        } | {
            start?: never;
            draw?: never;
            new_turn?: never;
            new_phase?: never;
            hint?: never;
            select_idle_cmd?: never;
            select_place?: never;
            move?: never;
            select_card?: never;
            select_chain?: never;
            select_effect_yn?: never;
            select_position?: never;
            select_option?: never;
            shuffle_hand_extra?: never;
            select_battle_cmd?: never;
            pos_change?: never;
            select_unselect_card?: never;
            select_yes_no?: never;
            update_hp?: never;
            win?: never;
            wait?: never;
            unimplemented?: never;
            update_data?: never;
            reload_field?: never;
            select_sum?: never;
            select_tribute?: never;
            update_counter?: never;
            select_counter?: never;
            sort_card?: never;
            set?: never;
            swap?: never;
            summoning?: never;
            summoned?: StocGameMessage.MsgSummoned;
            flip_summoning?: never;
            flip_summoned?: never;
            sp_summoning?: never;
            sp_summoned?: never;
            chaining?: never;
            attack?: never;
            attack_disable?: never;
            chain_solved?: never;
            chain_end?: never;
            announce?: never;
            lp_update?: never;
            confirm_cards?: never;
            become_target?: never;
            toss?: never;
            shuffle_set_card?: never;
            field_disabled?: never;
            shuffle_deck?: never;
            rock_paper_scissors?: never;
            hand_res?: never;
            swap_grave_deck?: never;
            sibyl_name?: never;
        } | {
            start?: never;
            draw?: never;
            new_turn?: never;
            new_phase?: never;
            hint?: never;
            select_idle_cmd?: never;
            select_place?: never;
            move?: never;
            select_card?: never;
            select_chain?: never;
            select_effect_yn?: never;
            select_position?: never;
            select_option?: never;
            shuffle_hand_extra?: never;
            select_battle_cmd?: never;
            pos_change?: never;
            select_unselect_card?: never;
            select_yes_no?: never;
            update_hp?: never;
            win?: never;
            wait?: never;
            unimplemented?: never;
            update_data?: never;
            reload_field?: never;
            select_sum?: never;
            select_tribute?: never;
            update_counter?: never;
            select_counter?: never;
            sort_card?: never;
            set?: never;
            swap?: never;
            summoning?: never;
            summoned?: never;
            flip_summoning?: StocGameMessage.MsgFlipSummoning;
            flip_summoned?: never;
            sp_summoning?: never;
            sp_summoned?: never;
            chaining?: never;
            attack?: never;
            attack_disable?: never;
            chain_solved?: never;
            chain_end?: never;
            announce?: never;
            lp_update?: never;
            confirm_cards?: never;
            become_target?: never;
            toss?: never;
            shuffle_set_card?: never;
            field_disabled?: never;
            shuffle_deck?: never;
            rock_paper_scissors?: never;
            hand_res?: never;
            swap_grave_deck?: never;
            sibyl_name?: never;
        } | {
            start?: never;
            draw?: never;
            new_turn?: never;
            new_phase?: never;
            hint?: never;
            select_idle_cmd?: never;
            select_place?: never;
            move?: never;
            select_card?: never;
            select_chain?: never;
            select_effect_yn?: never;
            select_position?: never;
            select_option?: never;
            shuffle_hand_extra?: never;
            select_battle_cmd?: never;
            pos_change?: never;
            select_unselect_card?: never;
            select_yes_no?: never;
            update_hp?: never;
            win?: never;
            wait?: never;
            unimplemented?: never;
            update_data?: never;
            reload_field?: never;
            select_sum?: never;
            select_tribute?: never;
            update_counter?: never;
            select_counter?: never;
            sort_card?: never;
            set?: never;
            swap?: never;
            summoning?: never;
            summoned?: never;
            flip_summoning?: never;
            flip_summoned?: StocGameMessage.MsgFlipSummoned;
            sp_summoning?: never;
            sp_summoned?: never;
            chaining?: never;
            attack?: never;
            attack_disable?: never;
            chain_solved?: never;
            chain_end?: never;
            announce?: never;
            lp_update?: never;
            confirm_cards?: never;
            become_target?: never;
            toss?: never;
            shuffle_set_card?: never;
            field_disabled?: never;
            shuffle_deck?: never;
            rock_paper_scissors?: never;
            hand_res?: never;
            swap_grave_deck?: never;
            sibyl_name?: never;
        } | {
            start?: never;
            draw?: never;
            new_turn?: never;
            new_phase?: never;
            hint?: never;
            select_idle_cmd?: never;
            select_place?: never;
            move?: never;
            select_card?: never;
            select_chain?: never;
            select_effect_yn?: never;
            select_position?: never;
            select_option?: never;
            shuffle_hand_extra?: never;
            select_battle_cmd?: never;
            pos_change?: never;
            select_unselect_card?: never;
            select_yes_no?: never;
            update_hp?: never;
            win?: never;
            wait?: never;
            unimplemented?: never;
            update_data?: never;
            reload_field?: never;
            select_sum?: never;
            select_tribute?: never;
            update_counter?: never;
            select_counter?: never;
            sort_card?: never;
            set?: never;
            swap?: never;
            summoning?: never;
            summoned?: never;
            flip_summoning?: never;
            flip_summoned?: never;
            sp_summoning?: StocGameMessage.MsgSpSummoning;
            sp_summoned?: never;
            chaining?: never;
            attack?: never;
            attack_disable?: never;
            chain_solved?: never;
            chain_end?: never;
            announce?: never;
            lp_update?: never;
            confirm_cards?: never;
            become_target?: never;
            toss?: never;
            shuffle_set_card?: never;
            field_disabled?: never;
            shuffle_deck?: never;
            rock_paper_scissors?: never;
            hand_res?: never;
            swap_grave_deck?: never;
            sibyl_name?: never;
        } | {
            start?: never;
            draw?: never;
            new_turn?: never;
            new_phase?: never;
            hint?: never;
            select_idle_cmd?: never;
            select_place?: never;
            move?: never;
            select_card?: never;
            select_chain?: never;
            select_effect_yn?: never;
            select_position?: never;
            select_option?: never;
            shuffle_hand_extra?: never;
            select_battle_cmd?: never;
            pos_change?: never;
            select_unselect_card?: never;
            select_yes_no?: never;
            update_hp?: never;
            win?: never;
            wait?: never;
            unimplemented?: never;
            update_data?: never;
            reload_field?: never;
            select_sum?: never;
            select_tribute?: never;
            update_counter?: never;
            select_counter?: never;
            sort_card?: never;
            set?: never;
            swap?: never;
            summoning?: never;
            summoned?: never;
            flip_summoning?: never;
            flip_summoned?: never;
            sp_summoning?: never;
            sp_summoned?: StocGameMessage.MsgSpSummoned;
            chaining?: never;
            attack?: never;
            attack_disable?: never;
            chain_solved?: never;
            chain_end?: never;
            announce?: never;
            lp_update?: never;
            confirm_cards?: never;
            become_target?: never;
            toss?: never;
            shuffle_set_card?: never;
            field_disabled?: never;
            shuffle_deck?: never;
            rock_paper_scissors?: never;
            hand_res?: never;
            swap_grave_deck?: never;
            sibyl_name?: never;
        } | {
            start?: never;
            draw?: never;
            new_turn?: never;
            new_phase?: never;
            hint?: never;
            select_idle_cmd?: never;
            select_place?: never;
            move?: never;
            select_card?: never;
            select_chain?: never;
            select_effect_yn?: never;
            select_position?: never;
            select_option?: never;
            shuffle_hand_extra?: never;
            select_battle_cmd?: never;
            pos_change?: never;
            select_unselect_card?: never;
            select_yes_no?: never;
            update_hp?: never;
            win?: never;
            wait?: never;
            unimplemented?: never;
            update_data?: never;
            reload_field?: never;
            select_sum?: never;
            select_tribute?: never;
            update_counter?: never;
            select_counter?: never;
            sort_card?: never;
            set?: never;
            swap?: never;
            summoning?: never;
            summoned?: never;
            flip_summoning?: never;
            flip_summoned?: never;
            sp_summoning?: never;
            sp_summoned?: never;
            chaining?: StocGameMessage.MsgChaining;
            attack?: never;
            attack_disable?: never;
            chain_solved?: never;
            chain_end?: never;
            announce?: never;
            lp_update?: never;
            confirm_cards?: never;
            become_target?: never;
            toss?: never;
            shuffle_set_card?: never;
            field_disabled?: never;
            shuffle_deck?: never;
            rock_paper_scissors?: never;
            hand_res?: never;
            swap_grave_deck?: never;
            sibyl_name?: never;
        } | {
            start?: never;
            draw?: never;
            new_turn?: never;
            new_phase?: never;
            hint?: never;
            select_idle_cmd?: never;
            select_place?: never;
            move?: never;
            select_card?: never;
            select_chain?: never;
            select_effect_yn?: never;
            select_position?: never;
            select_option?: never;
            shuffle_hand_extra?: never;
            select_battle_cmd?: never;
            pos_change?: never;
            select_unselect_card?: never;
            select_yes_no?: never;
            update_hp?: never;
            win?: never;
            wait?: never;
            unimplemented?: never;
            update_data?: never;
            reload_field?: never;
            select_sum?: never;
            select_tribute?: never;
            update_counter?: never;
            select_counter?: never;
            sort_card?: never;
            set?: never;
            swap?: never;
            summoning?: never;
            summoned?: never;
            flip_summoning?: never;
            flip_summoned?: never;
            sp_summoning?: never;
            sp_summoned?: never;
            chaining?: never;
            attack?: StocGameMessage.MsgAttack;
            attack_disable?: never;
            chain_solved?: never;
            chain_end?: never;
            announce?: never;
            lp_update?: never;
            confirm_cards?: never;
            become_target?: never;
            toss?: never;
            shuffle_set_card?: never;
            field_disabled?: never;
            shuffle_deck?: never;
            rock_paper_scissors?: never;
            hand_res?: never;
            swap_grave_deck?: never;
            sibyl_name?: never;
        } | {
            start?: never;
            draw?: never;
            new_turn?: never;
            new_phase?: never;
            hint?: never;
            select_idle_cmd?: never;
            select_place?: never;
            move?: never;
            select_card?: never;
            select_chain?: never;
            select_effect_yn?: never;
            select_position?: never;
            select_option?: never;
            shuffle_hand_extra?: never;
            select_battle_cmd?: never;
            pos_change?: never;
            select_unselect_card?: never;
            select_yes_no?: never;
            update_hp?: never;
            win?: never;
            wait?: never;
            unimplemented?: never;
            update_data?: never;
            reload_field?: never;
            select_sum?: never;
            select_tribute?: never;
            update_counter?: never;
            select_counter?: never;
            sort_card?: never;
            set?: never;
            swap?: never;
            summoning?: never;
            summoned?: never;
            flip_summoning?: never;
            flip_summoned?: never;
            sp_summoning?: never;
            sp_summoned?: never;
            chaining?: never;
            attack?: never;
            attack_disable?: StocGameMessage.MsgAttackDisabled;
            chain_solved?: never;
            chain_end?: never;
            announce?: never;
            lp_update?: never;
            confirm_cards?: never;
            become_target?: never;
            toss?: never;
            shuffle_set_card?: never;
            field_disabled?: never;
            shuffle_deck?: never;
            rock_paper_scissors?: never;
            hand_res?: never;
            swap_grave_deck?: never;
            sibyl_name?: never;
        } | {
            start?: never;
            draw?: never;
            new_turn?: never;
            new_phase?: never;
            hint?: never;
            select_idle_cmd?: never;
            select_place?: never;
            move?: never;
            select_card?: never;
            select_chain?: never;
            select_effect_yn?: never;
            select_position?: never;
            select_option?: never;
            shuffle_hand_extra?: never;
            select_battle_cmd?: never;
            pos_change?: never;
            select_unselect_card?: never;
            select_yes_no?: never;
            update_hp?: never;
            win?: never;
            wait?: never;
            unimplemented?: never;
            update_data?: never;
            reload_field?: never;
            select_sum?: never;
            select_tribute?: never;
            update_counter?: never;
            select_counter?: never;
            sort_card?: never;
            set?: never;
            swap?: never;
            summoning?: never;
            summoned?: never;
            flip_summoning?: never;
            flip_summoned?: never;
            sp_summoning?: never;
            sp_summoned?: never;
            chaining?: never;
            attack?: never;
            attack_disable?: never;
            chain_solved?: StocGameMessage.MsgChainSolved;
            chain_end?: never;
            announce?: never;
            lp_update?: never;
            confirm_cards?: never;
            become_target?: never;
            toss?: never;
            shuffle_set_card?: never;
            field_disabled?: never;
            shuffle_deck?: never;
            rock_paper_scissors?: never;
            hand_res?: never;
            swap_grave_deck?: never;
            sibyl_name?: never;
        } | {
            start?: never;
            draw?: never;
            new_turn?: never;
            new_phase?: never;
            hint?: never;
            select_idle_cmd?: never;
            select_place?: never;
            move?: never;
            select_card?: never;
            select_chain?: never;
            select_effect_yn?: never;
            select_position?: never;
            select_option?: never;
            shuffle_hand_extra?: never;
            select_battle_cmd?: never;
            pos_change?: never;
            select_unselect_card?: never;
            select_yes_no?: never;
            update_hp?: never;
            win?: never;
            wait?: never;
            unimplemented?: never;
            update_data?: never;
            reload_field?: never;
            select_sum?: never;
            select_tribute?: never;
            update_counter?: never;
            select_counter?: never;
            sort_card?: never;
            set?: never;
            swap?: never;
            summoning?: never;
            summoned?: never;
            flip_summoning?: never;
            flip_summoned?: never;
            sp_summoning?: never;
            sp_summoned?: never;
            chaining?: never;
            attack?: never;
            attack_disable?: never;
            chain_solved?: never;
            chain_end?: StocGameMessage.MsgChainEnd;
            announce?: never;
            lp_update?: never;
            confirm_cards?: never;
            become_target?: never;
            toss?: never;
            shuffle_set_card?: never;
            field_disabled?: never;
            shuffle_deck?: never;
            rock_paper_scissors?: never;
            hand_res?: never;
            swap_grave_deck?: never;
            sibyl_name?: never;
        } | {
            start?: never;
            draw?: never;
            new_turn?: never;
            new_phase?: never;
            hint?: never;
            select_idle_cmd?: never;
            select_place?: never;
            move?: never;
            select_card?: never;
            select_chain?: never;
            select_effect_yn?: never;
            select_position?: never;
            select_option?: never;
            shuffle_hand_extra?: never;
            select_battle_cmd?: never;
            pos_change?: never;
            select_unselect_card?: never;
            select_yes_no?: never;
            update_hp?: never;
            win?: never;
            wait?: never;
            unimplemented?: never;
            update_data?: never;
            reload_field?: never;
            select_sum?: never;
            select_tribute?: never;
            update_counter?: never;
            select_counter?: never;
            sort_card?: never;
            set?: never;
            swap?: never;
            summoning?: never;
            summoned?: never;
            flip_summoning?: never;
            flip_summoned?: never;
            sp_summoning?: never;
            sp_summoned?: never;
            chaining?: never;
            attack?: never;
            attack_disable?: never;
            chain_solved?: never;
            chain_end?: never;
            announce?: StocGameMessage.MsgAnnounce;
            lp_update?: never;
            confirm_cards?: never;
            become_target?: never;
            toss?: never;
            shuffle_set_card?: never;
            field_disabled?: never;
            shuffle_deck?: never;
            rock_paper_scissors?: never;
            hand_res?: never;
            swap_grave_deck?: never;
            sibyl_name?: never;
        } | {
            start?: never;
            draw?: never;
            new_turn?: never;
            new_phase?: never;
            hint?: never;
            select_idle_cmd?: never;
            select_place?: never;
            move?: never;
            select_card?: never;
            select_chain?: never;
            select_effect_yn?: never;
            select_position?: never;
            select_option?: never;
            shuffle_hand_extra?: never;
            select_battle_cmd?: never;
            pos_change?: never;
            select_unselect_card?: never;
            select_yes_no?: never;
            update_hp?: never;
            win?: never;
            wait?: never;
            unimplemented?: never;
            update_data?: never;
            reload_field?: never;
            select_sum?: never;
            select_tribute?: never;
            update_counter?: never;
            select_counter?: never;
            sort_card?: never;
            set?: never;
            swap?: never;
            summoning?: never;
            summoned?: never;
            flip_summoning?: never;
            flip_summoned?: never;
            sp_summoning?: never;
            sp_summoned?: never;
            chaining?: never;
            attack?: never;
            attack_disable?: never;
            chain_solved?: never;
            chain_end?: never;
            announce?: never;
            lp_update?: StocGameMessage.MsgLpUpdate;
            confirm_cards?: never;
            become_target?: never;
            toss?: never;
            shuffle_set_card?: never;
            field_disabled?: never;
            shuffle_deck?: never;
            rock_paper_scissors?: never;
            hand_res?: never;
            swap_grave_deck?: never;
            sibyl_name?: never;
        } | {
            start?: never;
            draw?: never;
            new_turn?: never;
            new_phase?: never;
            hint?: never;
            select_idle_cmd?: never;
            select_place?: never;
            move?: never;
            select_card?: never;
            select_chain?: never;
            select_effect_yn?: never;
            select_position?: never;
            select_option?: never;
            shuffle_hand_extra?: never;
            select_battle_cmd?: never;
            pos_change?: never;
            select_unselect_card?: never;
            select_yes_no?: never;
            update_hp?: never;
            win?: never;
            wait?: never;
            unimplemented?: never;
            update_data?: never;
            reload_field?: never;
            select_sum?: never;
            select_tribute?: never;
            update_counter?: never;
            select_counter?: never;
            sort_card?: never;
            set?: never;
            swap?: never;
            summoning?: never;
            summoned?: never;
            flip_summoning?: never;
            flip_summoned?: never;
            sp_summoning?: never;
            sp_summoned?: never;
            chaining?: never;
            attack?: never;
            attack_disable?: never;
            chain_solved?: never;
            chain_end?: never;
            announce?: never;
            lp_update?: never;
            confirm_cards?: StocGameMessage.MsgConfirmCards;
            become_target?: never;
            toss?: never;
            shuffle_set_card?: never;
            field_disabled?: never;
            shuffle_deck?: never;
            rock_paper_scissors?: never;
            hand_res?: never;
            swap_grave_deck?: never;
            sibyl_name?: never;
        } | {
            start?: never;
            draw?: never;
            new_turn?: never;
            new_phase?: never;
            hint?: never;
            select_idle_cmd?: never;
            select_place?: never;
            move?: never;
            select_card?: never;
            select_chain?: never;
            select_effect_yn?: never;
            select_position?: never;
            select_option?: never;
            shuffle_hand_extra?: never;
            select_battle_cmd?: never;
            pos_change?: never;
            select_unselect_card?: never;
            select_yes_no?: never;
            update_hp?: never;
            win?: never;
            wait?: never;
            unimplemented?: never;
            update_data?: never;
            reload_field?: never;
            select_sum?: never;
            select_tribute?: never;
            update_counter?: never;
            select_counter?: never;
            sort_card?: never;
            set?: never;
            swap?: never;
            summoning?: never;
            summoned?: never;
            flip_summoning?: never;
            flip_summoned?: never;
            sp_summoning?: never;
            sp_summoned?: never;
            chaining?: never;
            attack?: never;
            attack_disable?: never;
            chain_solved?: never;
            chain_end?: never;
            announce?: never;
            lp_update?: never;
            confirm_cards?: never;
            become_target?: StocGameMessage.MsgBecomeTarget;
            toss?: never;
            shuffle_set_card?: never;
            field_disabled?: never;
            shuffle_deck?: never;
            rock_paper_scissors?: never;
            hand_res?: never;
            swap_grave_deck?: never;
            sibyl_name?: never;
        } | {
            start?: never;
            draw?: never;
            new_turn?: never;
            new_phase?: never;
            hint?: never;
            select_idle_cmd?: never;
            select_place?: never;
            move?: never;
            select_card?: never;
            select_chain?: never;
            select_effect_yn?: never;
            select_position?: never;
            select_option?: never;
            shuffle_hand_extra?: never;
            select_battle_cmd?: never;
            pos_change?: never;
            select_unselect_card?: never;
            select_yes_no?: never;
            update_hp?: never;
            win?: never;
            wait?: never;
            unimplemented?: never;
            update_data?: never;
            reload_field?: never;
            select_sum?: never;
            select_tribute?: never;
            update_counter?: never;
            select_counter?: never;
            sort_card?: never;
            set?: never;
            swap?: never;
            summoning?: never;
            summoned?: never;
            flip_summoning?: never;
            flip_summoned?: never;
            sp_summoning?: never;
            sp_summoned?: never;
            chaining?: never;
            attack?: never;
            attack_disable?: never;
            chain_solved?: never;
            chain_end?: never;
            announce?: never;
            lp_update?: never;
            confirm_cards?: never;
            become_target?: never;
            toss?: StocGameMessage.MsgToss;
            shuffle_set_card?: never;
            field_disabled?: never;
            shuffle_deck?: never;
            rock_paper_scissors?: never;
            hand_res?: never;
            swap_grave_deck?: never;
            sibyl_name?: never;
        } | {
            start?: never;
            draw?: never;
            new_turn?: never;
            new_phase?: never;
            hint?: never;
            select_idle_cmd?: never;
            select_place?: never;
            move?: never;
            select_card?: never;
            select_chain?: never;
            select_effect_yn?: never;
            select_position?: never;
            select_option?: never;
            shuffle_hand_extra?: never;
            select_battle_cmd?: never;
            pos_change?: never;
            select_unselect_card?: never;
            select_yes_no?: never;
            update_hp?: never;
            win?: never;
            wait?: never;
            unimplemented?: never;
            update_data?: never;
            reload_field?: never;
            select_sum?: never;
            select_tribute?: never;
            update_counter?: never;
            select_counter?: never;
            sort_card?: never;
            set?: never;
            swap?: never;
            summoning?: never;
            summoned?: never;
            flip_summoning?: never;
            flip_summoned?: never;
            sp_summoning?: never;
            sp_summoned?: never;
            chaining?: never;
            attack?: never;
            attack_disable?: never;
            chain_solved?: never;
            chain_end?: never;
            announce?: never;
            lp_update?: never;
            confirm_cards?: never;
            become_target?: never;
            toss?: never;
            shuffle_set_card?: StocGameMessage.MsgShuffleSetCard;
            field_disabled?: never;
            shuffle_deck?: never;
            rock_paper_scissors?: never;
            hand_res?: never;
            swap_grave_deck?: never;
            sibyl_name?: never;
        } | {
            start?: never;
            draw?: never;
            new_turn?: never;
            new_phase?: never;
            hint?: never;
            select_idle_cmd?: never;
            select_place?: never;
            move?: never;
            select_card?: never;
            select_chain?: never;
            select_effect_yn?: never;
            select_position?: never;
            select_option?: never;
            shuffle_hand_extra?: never;
            select_battle_cmd?: never;
            pos_change?: never;
            select_unselect_card?: never;
            select_yes_no?: never;
            update_hp?: never;
            win?: never;
            wait?: never;
            unimplemented?: never;
            update_data?: never;
            reload_field?: never;
            select_sum?: never;
            select_tribute?: never;
            update_counter?: never;
            select_counter?: never;
            sort_card?: never;
            set?: never;
            swap?: never;
            summoning?: never;
            summoned?: never;
            flip_summoning?: never;
            flip_summoned?: never;
            sp_summoning?: never;
            sp_summoned?: never;
            chaining?: never;
            attack?: never;
            attack_disable?: never;
            chain_solved?: never;
            chain_end?: never;
            announce?: never;
            lp_update?: never;
            confirm_cards?: never;
            become_target?: never;
            toss?: never;
            shuffle_set_card?: never;
            field_disabled?: StocGameMessage.MsgFieldDisabled;
            shuffle_deck?: never;
            rock_paper_scissors?: never;
            hand_res?: never;
            swap_grave_deck?: never;
            sibyl_name?: never;
        } | {
            start?: never;
            draw?: never;
            new_turn?: never;
            new_phase?: never;
            hint?: never;
            select_idle_cmd?: never;
            select_place?: never;
            move?: never;
            select_card?: never;
            select_chain?: never;
            select_effect_yn?: never;
            select_position?: never;
            select_option?: never;
            shuffle_hand_extra?: never;
            select_battle_cmd?: never;
            pos_change?: never;
            select_unselect_card?: never;
            select_yes_no?: never;
            update_hp?: never;
            win?: never;
            wait?: never;
            unimplemented?: never;
            update_data?: never;
            reload_field?: never;
            select_sum?: never;
            select_tribute?: never;
            update_counter?: never;
            select_counter?: never;
            sort_card?: never;
            set?: never;
            swap?: never;
            summoning?: never;
            summoned?: never;
            flip_summoning?: never;
            flip_summoned?: never;
            sp_summoning?: never;
            sp_summoned?: never;
            chaining?: never;
            attack?: never;
            attack_disable?: never;
            chain_solved?: never;
            chain_end?: never;
            announce?: never;
            lp_update?: never;
            confirm_cards?: never;
            become_target?: never;
            toss?: never;
            shuffle_set_card?: never;
            field_disabled?: never;
            shuffle_deck?: StocGameMessage.MsgShuffleDeck;
            rock_paper_scissors?: never;
            hand_res?: never;
            swap_grave_deck?: never;
            sibyl_name?: never;
        } | {
            start?: never;
            draw?: never;
            new_turn?: never;
            new_phase?: never;
            hint?: never;
            select_idle_cmd?: never;
            select_place?: never;
            move?: never;
            select_card?: never;
            select_chain?: never;
            select_effect_yn?: never;
            select_position?: never;
            select_option?: never;
            shuffle_hand_extra?: never;
            select_battle_cmd?: never;
            pos_change?: never;
            select_unselect_card?: never;
            select_yes_no?: never;
            update_hp?: never;
            win?: never;
            wait?: never;
            unimplemented?: never;
            update_data?: never;
            reload_field?: never;
            select_sum?: never;
            select_tribute?: never;
            update_counter?: never;
            select_counter?: never;
            sort_card?: never;
            set?: never;
            swap?: never;
            summoning?: never;
            summoned?: never;
            flip_summoning?: never;
            flip_summoned?: never;
            sp_summoning?: never;
            sp_summoned?: never;
            chaining?: never;
            attack?: never;
            attack_disable?: never;
            chain_solved?: never;
            chain_end?: never;
            announce?: never;
            lp_update?: never;
            confirm_cards?: never;
            become_target?: never;
            toss?: never;
            shuffle_set_card?: never;
            field_disabled?: never;
            shuffle_deck?: never;
            rock_paper_scissors?: StocGameMessage.MsgRockPaperScissors;
            hand_res?: never;
            swap_grave_deck?: never;
            sibyl_name?: never;
        } | {
            start?: never;
            draw?: never;
            new_turn?: never;
            new_phase?: never;
            hint?: never;
            select_idle_cmd?: never;
            select_place?: never;
            move?: never;
            select_card?: never;
            select_chain?: never;
            select_effect_yn?: never;
            select_position?: never;
            select_option?: never;
            shuffle_hand_extra?: never;
            select_battle_cmd?: never;
            pos_change?: never;
            select_unselect_card?: never;
            select_yes_no?: never;
            update_hp?: never;
            win?: never;
            wait?: never;
            unimplemented?: never;
            update_data?: never;
            reload_field?: never;
            select_sum?: never;
            select_tribute?: never;
            update_counter?: never;
            select_counter?: never;
            sort_card?: never;
            set?: never;
            swap?: never;
            summoning?: never;
            summoned?: never;
            flip_summoning?: never;
            flip_summoned?: never;
            sp_summoning?: never;
            sp_summoned?: never;
            chaining?: never;
            attack?: never;
            attack_disable?: never;
            chain_solved?: never;
            chain_end?: never;
            announce?: never;
            lp_update?: never;
            confirm_cards?: never;
            become_target?: never;
            toss?: never;
            shuffle_set_card?: never;
            field_disabled?: never;
            shuffle_deck?: never;
            rock_paper_scissors?: never;
            hand_res?: StocGameMessage.MsgHandResult;
            swap_grave_deck?: never;
            sibyl_name?: never;
        } | {
            start?: never;
            draw?: never;
            new_turn?: never;
            new_phase?: never;
            hint?: never;
            select_idle_cmd?: never;
            select_place?: never;
            move?: never;
            select_card?: never;
            select_chain?: never;
            select_effect_yn?: never;
            select_position?: never;
            select_option?: never;
            shuffle_hand_extra?: never;
            select_battle_cmd?: never;
            pos_change?: never;
            select_unselect_card?: never;
            select_yes_no?: never;
            update_hp?: never;
            win?: never;
            wait?: never;
            unimplemented?: never;
            update_data?: never;
            reload_field?: never;
            select_sum?: never;
            select_tribute?: never;
            update_counter?: never;
            select_counter?: never;
            sort_card?: never;
            set?: never;
            swap?: never;
            summoning?: never;
            summoned?: never;
            flip_summoning?: never;
            flip_summoned?: never;
            sp_summoning?: never;
            sp_summoned?: never;
            chaining?: never;
            attack?: never;
            attack_disable?: never;
            chain_solved?: never;
            chain_end?: never;
            announce?: never;
            lp_update?: never;
            confirm_cards?: never;
            become_target?: never;
            toss?: never;
            shuffle_set_card?: never;
            field_disabled?: never;
            shuffle_deck?: never;
            rock_paper_scissors?: never;
            hand_res?: never;
            swap_grave_deck?: StocGameMessage.MsgSwapGraveDeck;
            sibyl_name?: never;
        } | {
            start?: never;
            draw?: never;
            new_turn?: never;
            new_phase?: never;
            hint?: never;
            select_idle_cmd?: never;
            select_place?: never;
            move?: never;
            select_card?: never;
            select_chain?: never;
            select_effect_yn?: never;
            select_position?: never;
            select_option?: never;
            shuffle_hand_extra?: never;
            select_battle_cmd?: never;
            pos_change?: never;
            select_unselect_card?: never;
            select_yes_no?: never;
            update_hp?: never;
            win?: never;
            wait?: never;
            unimplemented?: never;
            update_data?: never;
            reload_field?: never;
            select_sum?: never;
            select_tribute?: never;
            update_counter?: never;
            select_counter?: never;
            sort_card?: never;
            set?: never;
            swap?: never;
            summoning?: never;
            summoned?: never;
            flip_summoning?: never;
            flip_summoned?: never;
            sp_summoning?: never;
            sp_summoned?: never;
            chaining?: never;
            attack?: never;
            attack_disable?: never;
            chain_solved?: never;
            chain_end?: never;
            announce?: never;
            lp_update?: never;
            confirm_cards?: never;
            become_target?: never;
            toss?: never;
            shuffle_set_card?: never;
            field_disabled?: never;
            shuffle_deck?: never;
            rock_paper_scissors?: never;
            hand_res?: never;
            swap_grave_deck?: never;
            sibyl_name?: StocGameMessage.MsgSibylName;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("start" in data && data.start != undefined) {
                    this.start = data.start;
                }
                if ("draw" in data && data.draw != undefined) {
                    this.draw = data.draw;
                }
                if ("new_turn" in data && data.new_turn != undefined) {
                    this.new_turn = data.new_turn;
                }
                if ("new_phase" in data && data.new_phase != undefined) {
                    this.new_phase = data.new_phase;
                }
                if ("hint" in data && data.hint != undefined) {
                    this.hint = data.hint;
                }
                if ("select_idle_cmd" in data && data.select_idle_cmd != undefined) {
                    this.select_idle_cmd = data.select_idle_cmd;
                }
                if ("select_place" in data && data.select_place != undefined) {
                    this.select_place = data.select_place;
                }
                if ("move" in data && data.move != undefined) {
                    this.move = data.move;
                }
                if ("select_card" in data && data.select_card != undefined) {
                    this.select_card = data.select_card;
                }
                if ("select_chain" in data && data.select_chain != undefined) {
                    this.select_chain = data.select_chain;
                }
                if ("select_effect_yn" in data && data.select_effect_yn != undefined) {
                    this.select_effect_yn = data.select_effect_yn;
                }
                if ("select_position" in data && data.select_position != undefined) {
                    this.select_position = data.select_position;
                }
                if ("select_option" in data && data.select_option != undefined) {
                    this.select_option = data.select_option;
                }
                if ("shuffle_hand_extra" in data && data.shuffle_hand_extra != undefined) {
                    this.shuffle_hand_extra = data.shuffle_hand_extra;
                }
                if ("select_battle_cmd" in data && data.select_battle_cmd != undefined) {
                    this.select_battle_cmd = data.select_battle_cmd;
                }
                if ("pos_change" in data && data.pos_change != undefined) {
                    this.pos_change = data.pos_change;
                }
                if ("select_unselect_card" in data && data.select_unselect_card != undefined) {
                    this.select_unselect_card = data.select_unselect_card;
                }
                if ("select_yes_no" in data && data.select_yes_no != undefined) {
                    this.select_yes_no = data.select_yes_no;
                }
                if ("update_hp" in data && data.update_hp != undefined) {
                    this.update_hp = data.update_hp;
                }
                if ("win" in data && data.win != undefined) {
                    this.win = data.win;
                }
                if ("wait" in data && data.wait != undefined) {
                    this.wait = data.wait;
                }
                if ("unimplemented" in data && data.unimplemented != undefined) {
                    this.unimplemented = data.unimplemented;
                }
                if ("update_data" in data && data.update_data != undefined) {
                    this.update_data = data.update_data;
                }
                if ("reload_field" in data && data.reload_field != undefined) {
                    this.reload_field = data.reload_field;
                }
                if ("select_sum" in data && data.select_sum != undefined) {
                    this.select_sum = data.select_sum;
                }
                if ("select_tribute" in data && data.select_tribute != undefined) {
                    this.select_tribute = data.select_tribute;
                }
                if ("update_counter" in data && data.update_counter != undefined) {
                    this.update_counter = data.update_counter;
                }
                if ("select_counter" in data && data.select_counter != undefined) {
                    this.select_counter = data.select_counter;
                }
                if ("sort_card" in data && data.sort_card != undefined) {
                    this.sort_card = data.sort_card;
                }
                if ("set" in data && data.set != undefined) {
                    this.set = data.set;
                }
                if ("swap" in data && data.swap != undefined) {
                    this.swap = data.swap;
                }
                if ("summoning" in data && data.summoning != undefined) {
                    this.summoning = data.summoning;
                }
                if ("summoned" in data && data.summoned != undefined) {
                    this.summoned = data.summoned;
                }
                if ("flip_summoning" in data && data.flip_summoning != undefined) {
                    this.flip_summoning = data.flip_summoning;
                }
                if ("flip_summoned" in data && data.flip_summoned != undefined) {
                    this.flip_summoned = data.flip_summoned;
                }
                if ("sp_summoning" in data && data.sp_summoning != undefined) {
                    this.sp_summoning = data.sp_summoning;
                }
                if ("sp_summoned" in data && data.sp_summoned != undefined) {
                    this.sp_summoned = data.sp_summoned;
                }
                if ("chaining" in data && data.chaining != undefined) {
                    this.chaining = data.chaining;
                }
                if ("attack" in data && data.attack != undefined) {
                    this.attack = data.attack;
                }
                if ("attack_disable" in data && data.attack_disable != undefined) {
                    this.attack_disable = data.attack_disable;
                }
                if ("chain_solved" in data && data.chain_solved != undefined) {
                    this.chain_solved = data.chain_solved;
                }
                if ("chain_end" in data && data.chain_end != undefined) {
                    this.chain_end = data.chain_end;
                }
                if ("announce" in data && data.announce != undefined) {
                    this.announce = data.announce;
                }
                if ("lp_update" in data && data.lp_update != undefined) {
                    this.lp_update = data.lp_update;
                }
                if ("confirm_cards" in data && data.confirm_cards != undefined) {
                    this.confirm_cards = data.confirm_cards;
                }
                if ("become_target" in data && data.become_target != undefined) {
                    this.become_target = data.become_target;
                }
                if ("toss" in data && data.toss != undefined) {
                    this.toss = data.toss;
                }
                if ("shuffle_set_card" in data && data.shuffle_set_card != undefined) {
                    this.shuffle_set_card = data.shuffle_set_card;
                }
                if ("field_disabled" in data && data.field_disabled != undefined) {
                    this.field_disabled = data.field_disabled;
                }
                if ("shuffle_deck" in data && data.shuffle_deck != undefined) {
                    this.shuffle_deck = data.shuffle_deck;
                }
                if ("rock_paper_scissors" in data && data.rock_paper_scissors != undefined) {
                    this.rock_paper_scissors = data.rock_paper_scissors;
                }
                if ("hand_res" in data && data.hand_res != undefined) {
                    this.hand_res = data.hand_res;
                }
                if ("swap_grave_deck" in data && data.swap_grave_deck != undefined) {
                    this.swap_grave_deck = data.swap_grave_deck;
                }
                if ("sibyl_name" in data && data.sibyl_name != undefined) {
                    this.sibyl_name = data.sibyl_name;
                }
            }
        }
        get start() {
            return pb_1.Message.getWrapperField(this, StocGameMessage.MsgStart, 1) as StocGameMessage.MsgStart;
        }
        set start(value: StocGameMessage.MsgStart) {
            pb_1.Message.setOneofWrapperField(this, 1, this.#one_of_decls[0], value);
        }
        get has_start() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get draw() {
            return pb_1.Message.getWrapperField(this, StocGameMessage.MsgDraw, 2) as StocGameMessage.MsgDraw;
        }
        set draw(value: StocGameMessage.MsgDraw) {
            pb_1.Message.setOneofWrapperField(this, 2, this.#one_of_decls[0], value);
        }
        get has_draw() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get new_turn() {
            return pb_1.Message.getWrapperField(this, StocGameMessage.MsgNewTurn, 3) as StocGameMessage.MsgNewTurn;
        }
        set new_turn(value: StocGameMessage.MsgNewTurn) {
            pb_1.Message.setOneofWrapperField(this, 3, this.#one_of_decls[0], value);
        }
        get has_new_turn() {
            return pb_1.Message.getField(this, 3) != null;
        }
        get new_phase() {
            return pb_1.Message.getWrapperField(this, StocGameMessage.MsgNewPhase, 4) as StocGameMessage.MsgNewPhase;
        }
        set new_phase(value: StocGameMessage.MsgNewPhase) {
            pb_1.Message.setOneofWrapperField(this, 4, this.#one_of_decls[0], value);
        }
        get has_new_phase() {
            return pb_1.Message.getField(this, 4) != null;
        }
        get hint() {
            return pb_1.Message.getWrapperField(this, StocGameMessage.MsgHint, 5) as StocGameMessage.MsgHint;
        }
        set hint(value: StocGameMessage.MsgHint) {
            pb_1.Message.setOneofWrapperField(this, 5, this.#one_of_decls[0], value);
        }
        get has_hint() {
            return pb_1.Message.getField(this, 5) != null;
        }
        get select_idle_cmd() {
            return pb_1.Message.getWrapperField(this, StocGameMessage.MsgSelectIdleCmd, 6) as StocGameMessage.MsgSelectIdleCmd;
        }
        set select_idle_cmd(value: StocGameMessage.MsgSelectIdleCmd) {
            pb_1.Message.setOneofWrapperField(this, 6, this.#one_of_decls[0], value);
        }
        get has_select_idle_cmd() {
            return pb_1.Message.getField(this, 6) != null;
        }
        get select_place() {
            return pb_1.Message.getWrapperField(this, StocGameMessage.MsgSelectPlace, 7) as StocGameMessage.MsgSelectPlace;
        }
        set select_place(value: StocGameMessage.MsgSelectPlace) {
            pb_1.Message.setOneofWrapperField(this, 7, this.#one_of_decls[0], value);
        }
        get has_select_place() {
            return pb_1.Message.getField(this, 7) != null;
        }
        get move() {
            return pb_1.Message.getWrapperField(this, StocGameMessage.MsgMove, 8) as StocGameMessage.MsgMove;
        }
        set move(value: StocGameMessage.MsgMove) {
            pb_1.Message.setOneofWrapperField(this, 8, this.#one_of_decls[0], value);
        }
        get has_move() {
            return pb_1.Message.getField(this, 8) != null;
        }
        get select_card() {
            return pb_1.Message.getWrapperField(this, StocGameMessage.MsgSelectCard, 9) as StocGameMessage.MsgSelectCard;
        }
        set select_card(value: StocGameMessage.MsgSelectCard) {
            pb_1.Message.setOneofWrapperField(this, 9, this.#one_of_decls[0], value);
        }
        get has_select_card() {
            return pb_1.Message.getField(this, 9) != null;
        }
        get select_chain() {
            return pb_1.Message.getWrapperField(this, StocGameMessage.MsgSelectChain, 10) as StocGameMessage.MsgSelectChain;
        }
        set select_chain(value: StocGameMessage.MsgSelectChain) {
            pb_1.Message.setOneofWrapperField(this, 10, this.#one_of_decls[0], value);
        }
        get has_select_chain() {
            return pb_1.Message.getField(this, 10) != null;
        }
        get select_effect_yn() {
            return pb_1.Message.getWrapperField(this, StocGameMessage.MsgSelectEffectYn, 11) as StocGameMessage.MsgSelectEffectYn;
        }
        set select_effect_yn(value: StocGameMessage.MsgSelectEffectYn) {
            pb_1.Message.setOneofWrapperField(this, 11, this.#one_of_decls[0], value);
        }
        get has_select_effect_yn() {
            return pb_1.Message.getField(this, 11) != null;
        }
        get select_position() {
            return pb_1.Message.getWrapperField(this, StocGameMessage.MsgSelectPosition, 12) as StocGameMessage.MsgSelectPosition;
        }
        set select_position(value: StocGameMessage.MsgSelectPosition) {
            pb_1.Message.setOneofWrapperField(this, 12, this.#one_of_decls[0], value);
        }
        get has_select_position() {
            return pb_1.Message.getField(this, 12) != null;
        }
        get select_option() {
            return pb_1.Message.getWrapperField(this, StocGameMessage.MsgSelectOption, 13) as StocGameMessage.MsgSelectOption;
        }
        set select_option(value: StocGameMessage.MsgSelectOption) {
            pb_1.Message.setOneofWrapperField(this, 13, this.#one_of_decls[0], value);
        }
        get has_select_option() {
            return pb_1.Message.getField(this, 13) != null;
        }
        get shuffle_hand_extra() {
            return pb_1.Message.getWrapperField(this, StocGameMessage.MsgShuffleHandExtra, 14) as StocGameMessage.MsgShuffleHandExtra;
        }
        set shuffle_hand_extra(value: StocGameMessage.MsgShuffleHandExtra) {
            pb_1.Message.setOneofWrapperField(this, 14, this.#one_of_decls[0], value);
        }
        get has_shuffle_hand_extra() {
            return pb_1.Message.getField(this, 14) != null;
        }
        get select_battle_cmd() {
            return pb_1.Message.getWrapperField(this, StocGameMessage.MsgSelectBattleCmd, 15) as StocGameMessage.MsgSelectBattleCmd;
        }
        set select_battle_cmd(value: StocGameMessage.MsgSelectBattleCmd) {
            pb_1.Message.setOneofWrapperField(this, 15, this.#one_of_decls[0], value);
        }
        get has_select_battle_cmd() {
            return pb_1.Message.getField(this, 15) != null;
        }
        get pos_change() {
            return pb_1.Message.getWrapperField(this, StocGameMessage.MsgPosChange, 16) as StocGameMessage.MsgPosChange;
        }
        set pos_change(value: StocGameMessage.MsgPosChange) {
            pb_1.Message.setOneofWrapperField(this, 16, this.#one_of_decls[0], value);
        }
        get has_pos_change() {
            return pb_1.Message.getField(this, 16) != null;
        }
        get select_unselect_card() {
            return pb_1.Message.getWrapperField(this, StocGameMessage.MsgSelectUnselectCard, 17) as StocGameMessage.MsgSelectUnselectCard;
        }
        set select_unselect_card(value: StocGameMessage.MsgSelectUnselectCard) {
            pb_1.Message.setOneofWrapperField(this, 17, this.#one_of_decls[0], value);
        }
        get has_select_unselect_card() {
            return pb_1.Message.getField(this, 17) != null;
        }
        get select_yes_no() {
            return pb_1.Message.getWrapperField(this, StocGameMessage.MsgSelectYesNo, 18) as StocGameMessage.MsgSelectYesNo;
        }
        set select_yes_no(value: StocGameMessage.MsgSelectYesNo) {
            pb_1.Message.setOneofWrapperField(this, 18, this.#one_of_decls[0], value);
        }
        get has_select_yes_no() {
            return pb_1.Message.getField(this, 18) != null;
        }
        get update_hp() {
            return pb_1.Message.getWrapperField(this, StocGameMessage.MsgUpdateHp, 19) as StocGameMessage.MsgUpdateHp;
        }
        set update_hp(value: StocGameMessage.MsgUpdateHp) {
            pb_1.Message.setOneofWrapperField(this, 19, this.#one_of_decls[0], value);
        }
        get has_update_hp() {
            return pb_1.Message.getField(this, 19) != null;
        }
        get win() {
            return pb_1.Message.getWrapperField(this, StocGameMessage.MsgWin, 20) as StocGameMessage.MsgWin;
        }
        set win(value: StocGameMessage.MsgWin) {
            pb_1.Message.setOneofWrapperField(this, 20, this.#one_of_decls[0], value);
        }
        get has_win() {
            return pb_1.Message.getField(this, 20) != null;
        }
        get wait() {
            return pb_1.Message.getWrapperField(this, StocGameMessage.MsgWait, 21) as StocGameMessage.MsgWait;
        }
        set wait(value: StocGameMessage.MsgWait) {
            pb_1.Message.setOneofWrapperField(this, 21, this.#one_of_decls[0], value);
        }
        get has_wait() {
            return pb_1.Message.getField(this, 21) != null;
        }
        get unimplemented() {
            return pb_1.Message.getWrapperField(this, StocGameMessage.MsgUnimplemented, 22) as StocGameMessage.MsgUnimplemented;
        }
        set unimplemented(value: StocGameMessage.MsgUnimplemented) {
            pb_1.Message.setOneofWrapperField(this, 22, this.#one_of_decls[0], value);
        }
        get has_unimplemented() {
            return pb_1.Message.getField(this, 22) != null;
        }
        get update_data() {
            return pb_1.Message.getWrapperField(this, StocGameMessage.MsgUpdateData, 23) as StocGameMessage.MsgUpdateData;
        }
        set update_data(value: StocGameMessage.MsgUpdateData) {
            pb_1.Message.setOneofWrapperField(this, 23, this.#one_of_decls[0], value);
        }
        get has_update_data() {
            return pb_1.Message.getField(this, 23) != null;
        }
        get reload_field() {
            return pb_1.Message.getWrapperField(this, StocGameMessage.MsgReloadField, 24) as StocGameMessage.MsgReloadField;
        }
        set reload_field(value: StocGameMessage.MsgReloadField) {
            pb_1.Message.setOneofWrapperField(this, 24, this.#one_of_decls[0], value);
        }
        get has_reload_field() {
            return pb_1.Message.getField(this, 24) != null;
        }
        get select_sum() {
            return pb_1.Message.getWrapperField(this, StocGameMessage.MsgSelectSum, 25) as StocGameMessage.MsgSelectSum;
        }
        set select_sum(value: StocGameMessage.MsgSelectSum) {
            pb_1.Message.setOneofWrapperField(this, 25, this.#one_of_decls[0], value);
        }
        get has_select_sum() {
            return pb_1.Message.getField(this, 25) != null;
        }
        get select_tribute() {
            return pb_1.Message.getWrapperField(this, StocGameMessage.MsgSelectTribute, 26) as StocGameMessage.MsgSelectTribute;
        }
        set select_tribute(value: StocGameMessage.MsgSelectTribute) {
            pb_1.Message.setOneofWrapperField(this, 26, this.#one_of_decls[0], value);
        }
        get has_select_tribute() {
            return pb_1.Message.getField(this, 26) != null;
        }
        get update_counter() {
            return pb_1.Message.getWrapperField(this, StocGameMessage.MsgUpdateCounter, 27) as StocGameMessage.MsgUpdateCounter;
        }
        set update_counter(value: StocGameMessage.MsgUpdateCounter) {
            pb_1.Message.setOneofWrapperField(this, 27, this.#one_of_decls[0], value);
        }
        get has_update_counter() {
            return pb_1.Message.getField(this, 27) != null;
        }
        get select_counter() {
            return pb_1.Message.getWrapperField(this, StocGameMessage.MsgSelectCounter, 28) as StocGameMessage.MsgSelectCounter;
        }
        set select_counter(value: StocGameMessage.MsgSelectCounter) {
            pb_1.Message.setOneofWrapperField(this, 28, this.#one_of_decls[0], value);
        }
        get has_select_counter() {
            return pb_1.Message.getField(this, 28) != null;
        }
        get sort_card() {
            return pb_1.Message.getWrapperField(this, StocGameMessage.MsgSortCard, 29) as StocGameMessage.MsgSortCard;
        }
        set sort_card(value: StocGameMessage.MsgSortCard) {
            pb_1.Message.setOneofWrapperField(this, 29, this.#one_of_decls[0], value);
        }
        get has_sort_card() {
            return pb_1.Message.getField(this, 29) != null;
        }
        get set() {
            return pb_1.Message.getWrapperField(this, StocGameMessage.MsgSet, 30) as StocGameMessage.MsgSet;
        }
        set set(value: StocGameMessage.MsgSet) {
            pb_1.Message.setOneofWrapperField(this, 30, this.#one_of_decls[0], value);
        }
        get has_set() {
            return pb_1.Message.getField(this, 30) != null;
        }
        get swap() {
            return pb_1.Message.getWrapperField(this, StocGameMessage.MsgSwap, 31) as StocGameMessage.MsgSwap;
        }
        set swap(value: StocGameMessage.MsgSwap) {
            pb_1.Message.setOneofWrapperField(this, 31, this.#one_of_decls[0], value);
        }
        get has_swap() {
            return pb_1.Message.getField(this, 31) != null;
        }
        get summoning() {
            return pb_1.Message.getWrapperField(this, StocGameMessage.MsgSummoning, 32) as StocGameMessage.MsgSummoning;
        }
        set summoning(value: StocGameMessage.MsgSummoning) {
            pb_1.Message.setOneofWrapperField(this, 32, this.#one_of_decls[0], value);
        }
        get has_summoning() {
            return pb_1.Message.getField(this, 32) != null;
        }
        get summoned() {
            return pb_1.Message.getWrapperField(this, StocGameMessage.MsgSummoned, 33) as StocGameMessage.MsgSummoned;
        }
        set summoned(value: StocGameMessage.MsgSummoned) {
            pb_1.Message.setOneofWrapperField(this, 33, this.#one_of_decls[0], value);
        }
        get has_summoned() {
            return pb_1.Message.getField(this, 33) != null;
        }
        get flip_summoning() {
            return pb_1.Message.getWrapperField(this, StocGameMessage.MsgFlipSummoning, 34) as StocGameMessage.MsgFlipSummoning;
        }
        set flip_summoning(value: StocGameMessage.MsgFlipSummoning) {
            pb_1.Message.setOneofWrapperField(this, 34, this.#one_of_decls[0], value);
        }
        get has_flip_summoning() {
            return pb_1.Message.getField(this, 34) != null;
        }
        get flip_summoned() {
            return pb_1.Message.getWrapperField(this, StocGameMessage.MsgFlipSummoned, 35) as StocGameMessage.MsgFlipSummoned;
        }
        set flip_summoned(value: StocGameMessage.MsgFlipSummoned) {
            pb_1.Message.setOneofWrapperField(this, 35, this.#one_of_decls[0], value);
        }
        get has_flip_summoned() {
            return pb_1.Message.getField(this, 35) != null;
        }
        get sp_summoning() {
            return pb_1.Message.getWrapperField(this, StocGameMessage.MsgSpSummoning, 36) as StocGameMessage.MsgSpSummoning;
        }
        set sp_summoning(value: StocGameMessage.MsgSpSummoning) {
            pb_1.Message.setOneofWrapperField(this, 36, this.#one_of_decls[0], value);
        }
        get has_sp_summoning() {
            return pb_1.Message.getField(this, 36) != null;
        }
        get sp_summoned() {
            return pb_1.Message.getWrapperField(this, StocGameMessage.MsgSpSummoned, 37) as StocGameMessage.MsgSpSummoned;
        }
        set sp_summoned(value: StocGameMessage.MsgSpSummoned) {
            pb_1.Message.setOneofWrapperField(this, 37, this.#one_of_decls[0], value);
        }
        get has_sp_summoned() {
            return pb_1.Message.getField(this, 37) != null;
        }
        get chaining() {
            return pb_1.Message.getWrapperField(this, StocGameMessage.MsgChaining, 38) as StocGameMessage.MsgChaining;
        }
        set chaining(value: StocGameMessage.MsgChaining) {
            pb_1.Message.setOneofWrapperField(this, 38, this.#one_of_decls[0], value);
        }
        get has_chaining() {
            return pb_1.Message.getField(this, 38) != null;
        }
        get attack() {
            return pb_1.Message.getWrapperField(this, StocGameMessage.MsgAttack, 39) as StocGameMessage.MsgAttack;
        }
        set attack(value: StocGameMessage.MsgAttack) {
            pb_1.Message.setOneofWrapperField(this, 39, this.#one_of_decls[0], value);
        }
        get has_attack() {
            return pb_1.Message.getField(this, 39) != null;
        }
        get attack_disable() {
            return pb_1.Message.getWrapperField(this, StocGameMessage.MsgAttackDisabled, 40) as StocGameMessage.MsgAttackDisabled;
        }
        set attack_disable(value: StocGameMessage.MsgAttackDisabled) {
            pb_1.Message.setOneofWrapperField(this, 40, this.#one_of_decls[0], value);
        }
        get has_attack_disable() {
            return pb_1.Message.getField(this, 40) != null;
        }
        get chain_solved() {
            return pb_1.Message.getWrapperField(this, StocGameMessage.MsgChainSolved, 41) as StocGameMessage.MsgChainSolved;
        }
        set chain_solved(value: StocGameMessage.MsgChainSolved) {
            pb_1.Message.setOneofWrapperField(this, 41, this.#one_of_decls[0], value);
        }
        get has_chain_solved() {
            return pb_1.Message.getField(this, 41) != null;
        }
        get chain_end() {
            return pb_1.Message.getWrapperField(this, StocGameMessage.MsgChainEnd, 42) as StocGameMessage.MsgChainEnd;
        }
        set chain_end(value: StocGameMessage.MsgChainEnd) {
            pb_1.Message.setOneofWrapperField(this, 42, this.#one_of_decls[0], value);
        }
        get has_chain_end() {
            return pb_1.Message.getField(this, 42) != null;
        }
        get announce() {
            return pb_1.Message.getWrapperField(this, StocGameMessage.MsgAnnounce, 43) as StocGameMessage.MsgAnnounce;
        }
        set announce(value: StocGameMessage.MsgAnnounce) {
            pb_1.Message.setOneofWrapperField(this, 43, this.#one_of_decls[0], value);
        }
        get has_announce() {
            return pb_1.Message.getField(this, 43) != null;
        }
        get lp_update() {
            return pb_1.Message.getWrapperField(this, StocGameMessage.MsgLpUpdate, 44) as StocGameMessage.MsgLpUpdate;
        }
        set lp_update(value: StocGameMessage.MsgLpUpdate) {
            pb_1.Message.setOneofWrapperField(this, 44, this.#one_of_decls[0], value);
        }
        get has_lp_update() {
            return pb_1.Message.getField(this, 44) != null;
        }
        get confirm_cards() {
            return pb_1.Message.getWrapperField(this, StocGameMessage.MsgConfirmCards, 45) as StocGameMessage.MsgConfirmCards;
        }
        set confirm_cards(value: StocGameMessage.MsgConfirmCards) {
            pb_1.Message.setOneofWrapperField(this, 45, this.#one_of_decls[0], value);
        }
        get has_confirm_cards() {
            return pb_1.Message.getField(this, 45) != null;
        }
        get become_target() {
            return pb_1.Message.getWrapperField(this, StocGameMessage.MsgBecomeTarget, 46) as StocGameMessage.MsgBecomeTarget;
        }
        set become_target(value: StocGameMessage.MsgBecomeTarget) {
            pb_1.Message.setOneofWrapperField(this, 46, this.#one_of_decls[0], value);
        }
        get has_become_target() {
            return pb_1.Message.getField(this, 46) != null;
        }
        get toss() {
            return pb_1.Message.getWrapperField(this, StocGameMessage.MsgToss, 47) as StocGameMessage.MsgToss;
        }
        set toss(value: StocGameMessage.MsgToss) {
            pb_1.Message.setOneofWrapperField(this, 47, this.#one_of_decls[0], value);
        }
        get has_toss() {
            return pb_1.Message.getField(this, 47) != null;
        }
        get shuffle_set_card() {
            return pb_1.Message.getWrapperField(this, StocGameMessage.MsgShuffleSetCard, 48) as StocGameMessage.MsgShuffleSetCard;
        }
        set shuffle_set_card(value: StocGameMessage.MsgShuffleSetCard) {
            pb_1.Message.setOneofWrapperField(this, 48, this.#one_of_decls[0], value);
        }
        get has_shuffle_set_card() {
            return pb_1.Message.getField(this, 48) != null;
        }
        get field_disabled() {
            return pb_1.Message.getWrapperField(this, StocGameMessage.MsgFieldDisabled, 49) as StocGameMessage.MsgFieldDisabled;
        }
        set field_disabled(value: StocGameMessage.MsgFieldDisabled) {
            pb_1.Message.setOneofWrapperField(this, 49, this.#one_of_decls[0], value);
        }
        get has_field_disabled() {
            return pb_1.Message.getField(this, 49) != null;
        }
        get shuffle_deck() {
            return pb_1.Message.getWrapperField(this, StocGameMessage.MsgShuffleDeck, 50) as StocGameMessage.MsgShuffleDeck;
        }
        set shuffle_deck(value: StocGameMessage.MsgShuffleDeck) {
            pb_1.Message.setOneofWrapperField(this, 50, this.#one_of_decls[0], value);
        }
        get has_shuffle_deck() {
            return pb_1.Message.getField(this, 50) != null;
        }
        get rock_paper_scissors() {
            return pb_1.Message.getWrapperField(this, StocGameMessage.MsgRockPaperScissors, 51) as StocGameMessage.MsgRockPaperScissors;
        }
        set rock_paper_scissors(value: StocGameMessage.MsgRockPaperScissors) {
            pb_1.Message.setOneofWrapperField(this, 51, this.#one_of_decls[0], value);
        }
        get has_rock_paper_scissors() {
            return pb_1.Message.getField(this, 51) != null;
        }
        get hand_res() {
            return pb_1.Message.getWrapperField(this, StocGameMessage.MsgHandResult, 52) as StocGameMessage.MsgHandResult;
        }
        set hand_res(value: StocGameMessage.MsgHandResult) {
            pb_1.Message.setOneofWrapperField(this, 52, this.#one_of_decls[0], value);
        }
        get has_hand_res() {
            return pb_1.Message.getField(this, 52) != null;
        }
        get swap_grave_deck() {
            return pb_1.Message.getWrapperField(this, StocGameMessage.MsgSwapGraveDeck, 53) as StocGameMessage.MsgSwapGraveDeck;
        }
        set swap_grave_deck(value: StocGameMessage.MsgSwapGraveDeck) {
            pb_1.Message.setOneofWrapperField(this, 53, this.#one_of_decls[0], value);
        }
        get has_swap_grave_deck() {
            return pb_1.Message.getField(this, 53) != null;
        }
        get sibyl_name() {
            return pb_1.Message.getWrapperField(this, StocGameMessage.MsgSibylName, 54) as StocGameMessage.MsgSibylName;
        }
        set sibyl_name(value: StocGameMessage.MsgSibylName) {
            pb_1.Message.setOneofWrapperField(this, 54, this.#one_of_decls[0], value);
        }
        get has_sibyl_name() {
            return pb_1.Message.getField(this, 54) != null;
        }
        get gameMsg() {
            const cases: {
                [index: number]: "none" | "start" | "draw" | "new_turn" | "new_phase" | "hint" | "select_idle_cmd" | "select_place" | "move" | "select_card" | "select_chain" | "select_effect_yn" | "select_position" | "select_option" | "shuffle_hand_extra" | "select_battle_cmd" | "pos_change" | "select_unselect_card" | "select_yes_no" | "update_hp" | "win" | "wait" | "unimplemented" | "update_data" | "reload_field" | "select_sum" | "select_tribute" | "update_counter" | "select_counter" | "sort_card" | "set" | "swap" | "summoning" | "summoned" | "flip_summoning" | "flip_summoned" | "sp_summoning" | "sp_summoned" | "chaining" | "attack" | "attack_disable" | "chain_solved" | "chain_end" | "announce" | "lp_update" | "confirm_cards" | "become_target" | "toss" | "shuffle_set_card" | "field_disabled" | "shuffle_deck" | "rock_paper_scissors" | "hand_res" | "swap_grave_deck" | "sibyl_name";
            } = {
                0: "none",
                1: "start",
                2: "draw",
                3: "new_turn",
                4: "new_phase",
                5: "hint",
                6: "select_idle_cmd",
                7: "select_place",
                8: "move",
                9: "select_card",
                10: "select_chain",
                11: "select_effect_yn",
                12: "select_position",
                13: "select_option",
                14: "shuffle_hand_extra",
                15: "select_battle_cmd",
                16: "pos_change",
                17: "select_unselect_card",
                18: "select_yes_no",
                19: "update_hp",
                20: "win",
                21: "wait",
                22: "unimplemented",
                23: "update_data",
                24: "reload_field",
                25: "select_sum",
                26: "select_tribute",
                27: "update_counter",
                28: "select_counter",
                29: "sort_card",
                30: "set",
                31: "swap",
                32: "summoning",
                33: "summoned",
                34: "flip_summoning",
                35: "flip_summoned",
                36: "sp_summoning",
                37: "sp_summoned",
                38: "chaining",
                39: "attack",
                40: "attack_disable",
                41: "chain_solved",
                42: "chain_end",
                43: "announce",
                44: "lp_update",
                45: "confirm_cards",
                46: "become_target",
                47: "toss",
                48: "shuffle_set_card",
                49: "field_disabled",
                50: "shuffle_deck",
                51: "rock_paper_scissors",
                52: "hand_res",
                53: "swap_grave_deck",
                54: "sibyl_name"
            };
            return cases[pb_1.Message.computeOneofCase(this, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54])];
        }
        static fromObject(data: {
            start?: ReturnType<typeof StocGameMessage.MsgStart.prototype.toObject>;
            draw?: ReturnType<typeof StocGameMessage.MsgDraw.prototype.toObject>;
            new_turn?: ReturnType<typeof StocGameMessage.MsgNewTurn.prototype.toObject>;
            new_phase?: ReturnType<typeof StocGameMessage.MsgNewPhase.prototype.toObject>;
            hint?: ReturnType<typeof StocGameMessage.MsgHint.prototype.toObject>;
            select_idle_cmd?: ReturnType<typeof StocGameMessage.MsgSelectIdleCmd.prototype.toObject>;
            select_place?: ReturnType<typeof StocGameMessage.MsgSelectPlace.prototype.toObject>;
            move?: ReturnType<typeof StocGameMessage.MsgMove.prototype.toObject>;
            select_card?: ReturnType<typeof StocGameMessage.MsgSelectCard.prototype.toObject>;
            select_chain?: ReturnType<typeof StocGameMessage.MsgSelectChain.prototype.toObject>;
            select_effect_yn?: ReturnType<typeof StocGameMessage.MsgSelectEffectYn.prototype.toObject>;
            select_position?: ReturnType<typeof StocGameMessage.MsgSelectPosition.prototype.toObject>;
            select_option?: ReturnType<typeof StocGameMessage.MsgSelectOption.prototype.toObject>;
            shuffle_hand_extra?: ReturnType<typeof StocGameMessage.MsgShuffleHandExtra.prototype.toObject>;
            select_battle_cmd?: ReturnType<typeof StocGameMessage.MsgSelectBattleCmd.prototype.toObject>;
            pos_change?: ReturnType<typeof StocGameMessage.MsgPosChange.prototype.toObject>;
            select_unselect_card?: ReturnType<typeof StocGameMessage.MsgSelectUnselectCard.prototype.toObject>;
            select_yes_no?: ReturnType<typeof StocGameMessage.MsgSelectYesNo.prototype.toObject>;
            update_hp?: ReturnType<typeof StocGameMessage.MsgUpdateHp.prototype.toObject>;
            win?: ReturnType<typeof StocGameMessage.MsgWin.prototype.toObject>;
            wait?: ReturnType<typeof StocGameMessage.MsgWait.prototype.toObject>;
            unimplemented?: ReturnType<typeof StocGameMessage.MsgUnimplemented.prototype.toObject>;
            update_data?: ReturnType<typeof StocGameMessage.MsgUpdateData.prototype.toObject>;
            reload_field?: ReturnType<typeof StocGameMessage.MsgReloadField.prototype.toObject>;
            select_sum?: ReturnType<typeof StocGameMessage.MsgSelectSum.prototype.toObject>;
            select_tribute?: ReturnType<typeof StocGameMessage.MsgSelectTribute.prototype.toObject>;
            update_counter?: ReturnType<typeof StocGameMessage.MsgUpdateCounter.prototype.toObject>;
            select_counter?: ReturnType<typeof StocGameMessage.MsgSelectCounter.prototype.toObject>;
            sort_card?: ReturnType<typeof StocGameMessage.MsgSortCard.prototype.toObject>;
            set?: ReturnType<typeof StocGameMessage.MsgSet.prototype.toObject>;
            swap?: ReturnType<typeof StocGameMessage.MsgSwap.prototype.toObject>;
            summoning?: ReturnType<typeof StocGameMessage.MsgSummoning.prototype.toObject>;
            summoned?: ReturnType<typeof StocGameMessage.MsgSummoned.prototype.toObject>;
            flip_summoning?: ReturnType<typeof StocGameMessage.MsgFlipSummoning.prototype.toObject>;
            flip_summoned?: ReturnType<typeof StocGameMessage.MsgFlipSummoned.prototype.toObject>;
            sp_summoning?: ReturnType<typeof StocGameMessage.MsgSpSummoning.prototype.toObject>;
            sp_summoned?: ReturnType<typeof StocGameMessage.MsgSpSummoned.prototype.toObject>;
            chaining?: ReturnType<typeof StocGameMessage.MsgChaining.prototype.toObject>;
            attack?: ReturnType<typeof StocGameMessage.MsgAttack.prototype.toObject>;
            attack_disable?: ReturnType<typeof StocGameMessage.MsgAttackDisabled.prototype.toObject>;
            chain_solved?: ReturnType<typeof StocGameMessage.MsgChainSolved.prototype.toObject>;
            chain_end?: ReturnType<typeof StocGameMessage.MsgChainEnd.prototype.toObject>;
            announce?: ReturnType<typeof StocGameMessage.MsgAnnounce.prototype.toObject>;
            lp_update?: ReturnType<typeof StocGameMessage.MsgLpUpdate.prototype.toObject>;
            confirm_cards?: ReturnType<typeof StocGameMessage.MsgConfirmCards.prototype.toObject>;
            become_target?: ReturnType<typeof StocGameMessage.MsgBecomeTarget.prototype.toObject>;
            toss?: ReturnType<typeof StocGameMessage.MsgToss.prototype.toObject>;
            shuffle_set_card?: ReturnType<typeof StocGameMessage.MsgShuffleSetCard.prototype.toObject>;
            field_disabled?: ReturnType<typeof StocGameMessage.MsgFieldDisabled.prototype.toObject>;
            shuffle_deck?: ReturnType<typeof StocGameMessage.MsgShuffleDeck.prototype.toObject>;
            rock_paper_scissors?: ReturnType<typeof StocGameMessage.MsgRockPaperScissors.prototype.toObject>;
            hand_res?: ReturnType<typeof StocGameMessage.MsgHandResult.prototype.toObject>;
            swap_grave_deck?: ReturnType<typeof StocGameMessage.MsgSwapGraveDeck.prototype.toObject>;
            sibyl_name?: ReturnType<typeof StocGameMessage.MsgSibylName.prototype.toObject>;
        }): StocGameMessage {
            const message = new StocGameMessage({});
            if (data.start != null) {
                message.start = StocGameMessage.MsgStart.fromObject(data.start);
            }
            if (data.draw != null) {
                message.draw = StocGameMessage.MsgDraw.fromObject(data.draw);
            }
            if (data.new_turn != null) {
                message.new_turn = StocGameMessage.MsgNewTurn.fromObject(data.new_turn);
            }
            if (data.new_phase != null) {
                message.new_phase = StocGameMessage.MsgNewPhase.fromObject(data.new_phase);
            }
            if (data.hint != null) {
                message.hint = StocGameMessage.MsgHint.fromObject(data.hint);
            }
            if (data.select_idle_cmd != null) {
                message.select_idle_cmd = StocGameMessage.MsgSelectIdleCmd.fromObject(data.select_idle_cmd);
            }
            if (data.select_place != null) {
                message.select_place = StocGameMessage.MsgSelectPlace.fromObject(data.select_place);
            }
            if (data.move != null) {
                message.move = StocGameMessage.MsgMove.fromObject(data.move);
            }
            if (data.select_card != null) {
                message.select_card = StocGameMessage.MsgSelectCard.fromObject(data.select_card);
            }
            if (data.select_chain != null) {
                message.select_chain = StocGameMessage.MsgSelectChain.fromObject(data.select_chain);
            }
            if (data.select_effect_yn != null) {
                message.select_effect_yn = StocGameMessage.MsgSelectEffectYn.fromObject(data.select_effect_yn);
            }
            if (data.select_position != null) {
                message.select_position = StocGameMessage.MsgSelectPosition.fromObject(data.select_position);
            }
            if (data.select_option != null) {
                message.select_option = StocGameMessage.MsgSelectOption.fromObject(data.select_option);
            }
            if (data.shuffle_hand_extra != null) {
                message.shuffle_hand_extra = StocGameMessage.MsgShuffleHandExtra.fromObject(data.shuffle_hand_extra);
            }
            if (data.select_battle_cmd != null) {
                message.select_battle_cmd = StocGameMessage.MsgSelectBattleCmd.fromObject(data.select_battle_cmd);
            }
            if (data.pos_change != null) {
                message.pos_change = StocGameMessage.MsgPosChange.fromObject(data.pos_change);
            }
            if (data.select_unselect_card != null) {
                message.select_unselect_card = StocGameMessage.MsgSelectUnselectCard.fromObject(data.select_unselect_card);
            }
            if (data.select_yes_no != null) {
                message.select_yes_no = StocGameMessage.MsgSelectYesNo.fromObject(data.select_yes_no);
            }
            if (data.update_hp != null) {
                message.update_hp = StocGameMessage.MsgUpdateHp.fromObject(data.update_hp);
            }
            if (data.win != null) {
                message.win = StocGameMessage.MsgWin.fromObject(data.win);
            }
            if (data.wait != null) {
                message.wait = StocGameMessage.MsgWait.fromObject(data.wait);
            }
            if (data.unimplemented != null) {
                message.unimplemented = StocGameMessage.MsgUnimplemented.fromObject(data.unimplemented);
            }
            if (data.update_data != null) {
                message.update_data = StocGameMessage.MsgUpdateData.fromObject(data.update_data);
            }
            if (data.reload_field != null) {
                message.reload_field = StocGameMessage.MsgReloadField.fromObject(data.reload_field);
            }
            if (data.select_sum != null) {
                message.select_sum = StocGameMessage.MsgSelectSum.fromObject(data.select_sum);
            }
            if (data.select_tribute != null) {
                message.select_tribute = StocGameMessage.MsgSelectTribute.fromObject(data.select_tribute);
            }
            if (data.update_counter != null) {
                message.update_counter = StocGameMessage.MsgUpdateCounter.fromObject(data.update_counter);
            }
            if (data.select_counter != null) {
                message.select_counter = StocGameMessage.MsgSelectCounter.fromObject(data.select_counter);
            }
            if (data.sort_card != null) {
                message.sort_card = StocGameMessage.MsgSortCard.fromObject(data.sort_card);
            }
            if (data.set != null) {
                message.set = StocGameMessage.MsgSet.fromObject(data.set);
            }
            if (data.swap != null) {
                message.swap = StocGameMessage.MsgSwap.fromObject(data.swap);
            }
            if (data.summoning != null) {
                message.summoning = StocGameMessage.MsgSummoning.fromObject(data.summoning);
            }
            if (data.summoned != null) {
                message.summoned = StocGameMessage.MsgSummoned.fromObject(data.summoned);
            }
            if (data.flip_summoning != null) {
                message.flip_summoning = StocGameMessage.MsgFlipSummoning.fromObject(data.flip_summoning);
            }
            if (data.flip_summoned != null) {
                message.flip_summoned = StocGameMessage.MsgFlipSummoned.fromObject(data.flip_summoned);
            }
            if (data.sp_summoning != null) {
                message.sp_summoning = StocGameMessage.MsgSpSummoning.fromObject(data.sp_summoning);
            }
            if (data.sp_summoned != null) {
                message.sp_summoned = StocGameMessage.MsgSpSummoned.fromObject(data.sp_summoned);
            }
            if (data.chaining != null) {
                message.chaining = StocGameMessage.MsgChaining.fromObject(data.chaining);
            }
            if (data.attack != null) {
                message.attack = StocGameMessage.MsgAttack.fromObject(data.attack);
            }
            if (data.attack_disable != null) {
                message.attack_disable = StocGameMessage.MsgAttackDisabled.fromObject(data.attack_disable);
            }
            if (data.chain_solved != null) {
                message.chain_solved = StocGameMessage.MsgChainSolved.fromObject(data.chain_solved);
            }
            if (data.chain_end != null) {
                message.chain_end = StocGameMessage.MsgChainEnd.fromObject(data.chain_end);
            }
            if (data.announce != null) {
                message.announce = StocGameMessage.MsgAnnounce.fromObject(data.announce);
            }
            if (data.lp_update != null) {
                message.lp_update = StocGameMessage.MsgLpUpdate.fromObject(data.lp_update);
            }
            if (data.confirm_cards != null) {
                message.confirm_cards = StocGameMessage.MsgConfirmCards.fromObject(data.confirm_cards);
            }
            if (data.become_target != null) {
                message.become_target = StocGameMessage.MsgBecomeTarget.fromObject(data.become_target);
            }
            if (data.toss != null) {
                message.toss = StocGameMessage.MsgToss.fromObject(data.toss);
            }
            if (data.shuffle_set_card != null) {
                message.shuffle_set_card = StocGameMessage.MsgShuffleSetCard.fromObject(data.shuffle_set_card);
            }
            if (data.field_disabled != null) {
                message.field_disabled = StocGameMessage.MsgFieldDisabled.fromObject(data.field_disabled);
            }
            if (data.shuffle_deck != null) {
                message.shuffle_deck = StocGameMessage.MsgShuffleDeck.fromObject(data.shuffle_deck);
            }
            if (data.rock_paper_scissors != null) {
                message.rock_paper_scissors = StocGameMessage.MsgRockPaperScissors.fromObject(data.rock_paper_scissors);
            }
            if (data.hand_res != null) {
                message.hand_res = StocGameMessage.MsgHandResult.fromObject(data.hand_res);
            }
            if (data.swap_grave_deck != null) {
                message.swap_grave_deck = StocGameMessage.MsgSwapGraveDeck.fromObject(data.swap_grave_deck);
            }
            if (data.sibyl_name != null) {
                message.sibyl_name = StocGameMessage.MsgSibylName.fromObject(data.sibyl_name);
            }
            return message;
        }
        toObject() {
            const data: {
                start?: ReturnType<typeof StocGameMessage.MsgStart.prototype.toObject>;
                draw?: ReturnType<typeof StocGameMessage.MsgDraw.prototype.toObject>;
                new_turn?: ReturnType<typeof StocGameMessage.MsgNewTurn.prototype.toObject>;
                new_phase?: ReturnType<typeof StocGameMessage.MsgNewPhase.prototype.toObject>;
                hint?: ReturnType<typeof StocGameMessage.MsgHint.prototype.toObject>;
                select_idle_cmd?: ReturnType<typeof StocGameMessage.MsgSelectIdleCmd.prototype.toObject>;
                select_place?: ReturnType<typeof StocGameMessage.MsgSelectPlace.prototype.toObject>;
                move?: ReturnType<typeof StocGameMessage.MsgMove.prototype.toObject>;
                select_card?: ReturnType<typeof StocGameMessage.MsgSelectCard.prototype.toObject>;
                select_chain?: ReturnType<typeof StocGameMessage.MsgSelectChain.prototype.toObject>;
                select_effect_yn?: ReturnType<typeof StocGameMessage.MsgSelectEffectYn.prototype.toObject>;
                select_position?: ReturnType<typeof StocGameMessage.MsgSelectPosition.prototype.toObject>;
                select_option?: ReturnType<typeof StocGameMessage.MsgSelectOption.prototype.toObject>;
                shuffle_hand_extra?: ReturnType<typeof StocGameMessage.MsgShuffleHandExtra.prototype.toObject>;
                select_battle_cmd?: ReturnType<typeof StocGameMessage.MsgSelectBattleCmd.prototype.toObject>;
                pos_change?: ReturnType<typeof StocGameMessage.MsgPosChange.prototype.toObject>;
                select_unselect_card?: ReturnType<typeof StocGameMessage.MsgSelectUnselectCard.prototype.toObject>;
                select_yes_no?: ReturnType<typeof StocGameMessage.MsgSelectYesNo.prototype.toObject>;
                update_hp?: ReturnType<typeof StocGameMessage.MsgUpdateHp.prototype.toObject>;
                win?: ReturnType<typeof StocGameMessage.MsgWin.prototype.toObject>;
                wait?: ReturnType<typeof StocGameMessage.MsgWait.prototype.toObject>;
                unimplemented?: ReturnType<typeof StocGameMessage.MsgUnimplemented.prototype.toObject>;
                update_data?: ReturnType<typeof StocGameMessage.MsgUpdateData.prototype.toObject>;
                reload_field?: ReturnType<typeof StocGameMessage.MsgReloadField.prototype.toObject>;
                select_sum?: ReturnType<typeof StocGameMessage.MsgSelectSum.prototype.toObject>;
                select_tribute?: ReturnType<typeof StocGameMessage.MsgSelectTribute.prototype.toObject>;
                update_counter?: ReturnType<typeof StocGameMessage.MsgUpdateCounter.prototype.toObject>;
                select_counter?: ReturnType<typeof StocGameMessage.MsgSelectCounter.prototype.toObject>;
                sort_card?: ReturnType<typeof StocGameMessage.MsgSortCard.prototype.toObject>;
                set?: ReturnType<typeof StocGameMessage.MsgSet.prototype.toObject>;
                swap?: ReturnType<typeof StocGameMessage.MsgSwap.prototype.toObject>;
                summoning?: ReturnType<typeof StocGameMessage.MsgSummoning.prototype.toObject>;
                summoned?: ReturnType<typeof StocGameMessage.MsgSummoned.prototype.toObject>;
                flip_summoning?: ReturnType<typeof StocGameMessage.MsgFlipSummoning.prototype.toObject>;
                flip_summoned?: ReturnType<typeof StocGameMessage.MsgFlipSummoned.prototype.toObject>;
                sp_summoning?: ReturnType<typeof StocGameMessage.MsgSpSummoning.prototype.toObject>;
                sp_summoned?: ReturnType<typeof StocGameMessage.MsgSpSummoned.prototype.toObject>;
                chaining?: ReturnType<typeof StocGameMessage.MsgChaining.prototype.toObject>;
                attack?: ReturnType<typeof StocGameMessage.MsgAttack.prototype.toObject>;
                attack_disable?: ReturnType<typeof StocGameMessage.MsgAttackDisabled.prototype.toObject>;
                chain_solved?: ReturnType<typeof StocGameMessage.MsgChainSolved.prototype.toObject>;
                chain_end?: ReturnType<typeof StocGameMessage.MsgChainEnd.prototype.toObject>;
                announce?: ReturnType<typeof StocGameMessage.MsgAnnounce.prototype.toObject>;
                lp_update?: ReturnType<typeof StocGameMessage.MsgLpUpdate.prototype.toObject>;
                confirm_cards?: ReturnType<typeof StocGameMessage.MsgConfirmCards.prototype.toObject>;
                become_target?: ReturnType<typeof StocGameMessage.MsgBecomeTarget.prototype.toObject>;
                toss?: ReturnType<typeof StocGameMessage.MsgToss.prototype.toObject>;
                shuffle_set_card?: ReturnType<typeof StocGameMessage.MsgShuffleSetCard.prototype.toObject>;
                field_disabled?: ReturnType<typeof StocGameMessage.MsgFieldDisabled.prototype.toObject>;
                shuffle_deck?: ReturnType<typeof StocGameMessage.MsgShuffleDeck.prototype.toObject>;
                rock_paper_scissors?: ReturnType<typeof StocGameMessage.MsgRockPaperScissors.prototype.toObject>;
                hand_res?: ReturnType<typeof StocGameMessage.MsgHandResult.prototype.toObject>;
                swap_grave_deck?: ReturnType<typeof StocGameMessage.MsgSwapGraveDeck.prototype.toObject>;
                sibyl_name?: ReturnType<typeof StocGameMessage.MsgSibylName.prototype.toObject>;
            } = {};
            if (this.start != null) {
                data.start = this.start.toObject();
            }
            if (this.draw != null) {
                data.draw = this.draw.toObject();
            }
            if (this.new_turn != null) {
                data.new_turn = this.new_turn.toObject();
            }
            if (this.new_phase != null) {
                data.new_phase = this.new_phase.toObject();
            }
            if (this.hint != null) {
                data.hint = this.hint.toObject();
            }
            if (this.select_idle_cmd != null) {
                data.select_idle_cmd = this.select_idle_cmd.toObject();
            }
            if (this.select_place != null) {
                data.select_place = this.select_place.toObject();
            }
            if (this.move != null) {
                data.move = this.move.toObject();
            }
            if (this.select_card != null) {
                data.select_card = this.select_card.toObject();
            }
            if (this.select_chain != null) {
                data.select_chain = this.select_chain.toObject();
            }
            if (this.select_effect_yn != null) {
                data.select_effect_yn = this.select_effect_yn.toObject();
            }
            if (this.select_position != null) {
                data.select_position = this.select_position.toObject();
            }
            if (this.select_option != null) {
                data.select_option = this.select_option.toObject();
            }
            if (this.shuffle_hand_extra != null) {
                data.shuffle_hand_extra = this.shuffle_hand_extra.toObject();
            }
            if (this.select_battle_cmd != null) {
                data.select_battle_cmd = this.select_battle_cmd.toObject();
            }
            if (this.pos_change != null) {
                data.pos_change = this.pos_change.toObject();
            }
            if (this.select_unselect_card != null) {
                data.select_unselect_card = this.select_unselect_card.toObject();
            }
            if (this.select_yes_no != null) {
                data.select_yes_no = this.select_yes_no.toObject();
            }
            if (this.update_hp != null) {
                data.update_hp = this.update_hp.toObject();
            }
            if (this.win != null) {
                data.win = this.win.toObject();
            }
            if (this.wait != null) {
                data.wait = this.wait.toObject();
            }
            if (this.unimplemented != null) {
                data.unimplemented = this.unimplemented.toObject();
            }
            if (this.update_data != null) {
                data.update_data = this.update_data.toObject();
            }
            if (this.reload_field != null) {
                data.reload_field = this.reload_field.toObject();
            }
            if (this.select_sum != null) {
                data.select_sum = this.select_sum.toObject();
            }
            if (this.select_tribute != null) {
                data.select_tribute = this.select_tribute.toObject();
            }
            if (this.update_counter != null) {
                data.update_counter = this.update_counter.toObject();
            }
            if (this.select_counter != null) {
                data.select_counter = this.select_counter.toObject();
            }
            if (this.sort_card != null) {
                data.sort_card = this.sort_card.toObject();
            }
            if (this.set != null) {
                data.set = this.set.toObject();
            }
            if (this.swap != null) {
                data.swap = this.swap.toObject();
            }
            if (this.summoning != null) {
                data.summoning = this.summoning.toObject();
            }
            if (this.summoned != null) {
                data.summoned = this.summoned.toObject();
            }
            if (this.flip_summoning != null) {
                data.flip_summoning = this.flip_summoning.toObject();
            }
            if (this.flip_summoned != null) {
                data.flip_summoned = this.flip_summoned.toObject();
            }
            if (this.sp_summoning != null) {
                data.sp_summoning = this.sp_summoning.toObject();
            }
            if (this.sp_summoned != null) {
                data.sp_summoned = this.sp_summoned.toObject();
            }
            if (this.chaining != null) {
                data.chaining = this.chaining.toObject();
            }
            if (this.attack != null) {
                data.attack = this.attack.toObject();
            }
            if (this.attack_disable != null) {
                data.attack_disable = this.attack_disable.toObject();
            }
            if (this.chain_solved != null) {
                data.chain_solved = this.chain_solved.toObject();
            }
            if (this.chain_end != null) {
                data.chain_end = this.chain_end.toObject();
            }
            if (this.announce != null) {
                data.announce = this.announce.toObject();
            }
            if (this.lp_update != null) {
                data.lp_update = this.lp_update.toObject();
            }
            if (this.confirm_cards != null) {
                data.confirm_cards = this.confirm_cards.toObject();
            }
            if (this.become_target != null) {
                data.become_target = this.become_target.toObject();
            }
            if (this.toss != null) {
                data.toss = this.toss.toObject();
            }
            if (this.shuffle_set_card != null) {
                data.shuffle_set_card = this.shuffle_set_card.toObject();
            }
            if (this.field_disabled != null) {
                data.field_disabled = this.field_disabled.toObject();
            }
            if (this.shuffle_deck != null) {
                data.shuffle_deck = this.shuffle_deck.toObject();
            }
            if (this.rock_paper_scissors != null) {
                data.rock_paper_scissors = this.rock_paper_scissors.toObject();
            }
            if (this.hand_res != null) {
                data.hand_res = this.hand_res.toObject();
            }
            if (this.swap_grave_deck != null) {
                data.swap_grave_deck = this.swap_grave_deck.toObject();
            }
            if (this.sibyl_name != null) {
                data.sibyl_name = this.sibyl_name.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_start)
                writer.writeMessage(1, this.start, () => this.start.serialize(writer));
            if (this.has_draw)
                writer.writeMessage(2, this.draw, () => this.draw.serialize(writer));
            if (this.has_new_turn)
                writer.writeMessage(3, this.new_turn, () => this.new_turn.serialize(writer));
            if (this.has_new_phase)
                writer.writeMessage(4, this.new_phase, () => this.new_phase.serialize(writer));
            if (this.has_hint)
                writer.writeMessage(5, this.hint, () => this.hint.serialize(writer));
            if (this.has_select_idle_cmd)
                writer.writeMessage(6, this.select_idle_cmd, () => this.select_idle_cmd.serialize(writer));
            if (this.has_select_place)
                writer.writeMessage(7, this.select_place, () => this.select_place.serialize(writer));
            if (this.has_move)
                writer.writeMessage(8, this.move, () => this.move.serialize(writer));
            if (this.has_select_card)
                writer.writeMessage(9, this.select_card, () => this.select_card.serialize(writer));
            if (this.has_select_chain)
                writer.writeMessage(10, this.select_chain, () => this.select_chain.serialize(writer));
            if (this.has_select_effect_yn)
                writer.writeMessage(11, this.select_effect_yn, () => this.select_effect_yn.serialize(writer));
            if (this.has_select_position)
                writer.writeMessage(12, this.select_position, () => this.select_position.serialize(writer));
            if (this.has_select_option)
                writer.writeMessage(13, this.select_option, () => this.select_option.serialize(writer));
            if (this.has_shuffle_hand_extra)
                writer.writeMessage(14, this.shuffle_hand_extra, () => this.shuffle_hand_extra.serialize(writer));
            if (this.has_select_battle_cmd)
                writer.writeMessage(15, this.select_battle_cmd, () => this.select_battle_cmd.serialize(writer));
            if (this.has_pos_change)
                writer.writeMessage(16, this.pos_change, () => this.pos_change.serialize(writer));
            if (this.has_select_unselect_card)
                writer.writeMessage(17, this.select_unselect_card, () => this.select_unselect_card.serialize(writer));
            if (this.has_select_yes_no)
                writer.writeMessage(18, this.select_yes_no, () => this.select_yes_no.serialize(writer));
            if (this.has_update_hp)
                writer.writeMessage(19, this.update_hp, () => this.update_hp.serialize(writer));
            if (this.has_win)
                writer.writeMessage(20, this.win, () => this.win.serialize(writer));
            if (this.has_wait)
                writer.writeMessage(21, this.wait, () => this.wait.serialize(writer));
            if (this.has_unimplemented)
                writer.writeMessage(22, this.unimplemented, () => this.unimplemented.serialize(writer));
            if (this.has_update_data)
                writer.writeMessage(23, this.update_data, () => this.update_data.serialize(writer));
            if (this.has_reload_field)
                writer.writeMessage(24, this.reload_field, () => this.reload_field.serialize(writer));
            if (this.has_select_sum)
                writer.writeMessage(25, this.select_sum, () => this.select_sum.serialize(writer));
            if (this.has_select_tribute)
                writer.writeMessage(26, this.select_tribute, () => this.select_tribute.serialize(writer));
            if (this.has_update_counter)
                writer.writeMessage(27, this.update_counter, () => this.update_counter.serialize(writer));
            if (this.has_select_counter)
                writer.writeMessage(28, this.select_counter, () => this.select_counter.serialize(writer));
            if (this.has_sort_card)
                writer.writeMessage(29, this.sort_card, () => this.sort_card.serialize(writer));
            if (this.has_set)
                writer.writeMessage(30, this.set, () => this.set.serialize(writer));
            if (this.has_swap)
                writer.writeMessage(31, this.swap, () => this.swap.serialize(writer));
            if (this.has_summoning)
                writer.writeMessage(32, this.summoning, () => this.summoning.serialize(writer));
            if (this.has_summoned)
                writer.writeMessage(33, this.summoned, () => this.summoned.serialize(writer));
            if (this.has_flip_summoning)
                writer.writeMessage(34, this.flip_summoning, () => this.flip_summoning.serialize(writer));
            if (this.has_flip_summoned)
                writer.writeMessage(35, this.flip_summoned, () => this.flip_summoned.serialize(writer));
            if (this.has_sp_summoning)
                writer.writeMessage(36, this.sp_summoning, () => this.sp_summoning.serialize(writer));
            if (this.has_sp_summoned)
                writer.writeMessage(37, this.sp_summoned, () => this.sp_summoned.serialize(writer));
            if (this.has_chaining)
                writer.writeMessage(38, this.chaining, () => this.chaining.serialize(writer));
            if (this.has_attack)
                writer.writeMessage(39, this.attack, () => this.attack.serialize(writer));
            if (this.has_attack_disable)
                writer.writeMessage(40, this.attack_disable, () => this.attack_disable.serialize(writer));
            if (this.has_chain_solved)
                writer.writeMessage(41, this.chain_solved, () => this.chain_solved.serialize(writer));
            if (this.has_chain_end)
                writer.writeMessage(42, this.chain_end, () => this.chain_end.serialize(writer));
            if (this.has_announce)
                writer.writeMessage(43, this.announce, () => this.announce.serialize(writer));
            if (this.has_lp_update)
                writer.writeMessage(44, this.lp_update, () => this.lp_update.serialize(writer));
            if (this.has_confirm_cards)
                writer.writeMessage(45, this.confirm_cards, () => this.confirm_cards.serialize(writer));
            if (this.has_become_target)
                writer.writeMessage(46, this.become_target, () => this.become_target.serialize(writer));
            if (this.has_toss)
                writer.writeMessage(47, this.toss, () => this.toss.serialize(writer));
            if (this.has_shuffle_set_card)
                writer.writeMessage(48, this.shuffle_set_card, () => this.shuffle_set_card.serialize(writer));
            if (this.has_field_disabled)
                writer.writeMessage(49, this.field_disabled, () => this.field_disabled.serialize(writer));
            if (this.has_shuffle_deck)
                writer.writeMessage(50, this.shuffle_deck, () => this.shuffle_deck.serialize(writer));
            if (this.has_rock_paper_scissors)
                writer.writeMessage(51, this.rock_paper_scissors, () => this.rock_paper_scissors.serialize(writer));
            if (this.has_hand_res)
                writer.writeMessage(52, this.hand_res, () => this.hand_res.serialize(writer));
            if (this.has_swap_grave_deck)
                writer.writeMessage(53, this.swap_grave_deck, () => this.swap_grave_deck.serialize(writer));
            if (this.has_sibyl_name)
                writer.writeMessage(54, this.sibyl_name, () => this.sibyl_name.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): StocGameMessage {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new StocGameMessage();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.start, () => message.start = StocGameMessage.MsgStart.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message.draw, () => message.draw = StocGameMessage.MsgDraw.deserialize(reader));
                        break;
                    case 3:
                        reader.readMessage(message.new_turn, () => message.new_turn = StocGameMessage.MsgNewTurn.deserialize(reader));
                        break;
                    case 4:
                        reader.readMessage(message.new_phase, () => message.new_phase = StocGameMessage.MsgNewPhase.deserialize(reader));
                        break;
                    case 5:
                        reader.readMessage(message.hint, () => message.hint = StocGameMessage.MsgHint.deserialize(reader));
                        break;
                    case 6:
                        reader.readMessage(message.select_idle_cmd, () => message.select_idle_cmd = StocGameMessage.MsgSelectIdleCmd.deserialize(reader));
                        break;
                    case 7:
                        reader.readMessage(message.select_place, () => message.select_place = StocGameMessage.MsgSelectPlace.deserialize(reader));
                        break;
                    case 8:
                        reader.readMessage(message.move, () => message.move = StocGameMessage.MsgMove.deserialize(reader));
                        break;
                    case 9:
                        reader.readMessage(message.select_card, () => message.select_card = StocGameMessage.MsgSelectCard.deserialize(reader));
                        break;
                    case 10:
                        reader.readMessage(message.select_chain, () => message.select_chain = StocGameMessage.MsgSelectChain.deserialize(reader));
                        break;
                    case 11:
                        reader.readMessage(message.select_effect_yn, () => message.select_effect_yn = StocGameMessage.MsgSelectEffectYn.deserialize(reader));
                        break;
                    case 12:
                        reader.readMessage(message.select_position, () => message.select_position = StocGameMessage.MsgSelectPosition.deserialize(reader));
                        break;
                    case 13:
                        reader.readMessage(message.select_option, () => message.select_option = StocGameMessage.MsgSelectOption.deserialize(reader));
                        break;
                    case 14:
                        reader.readMessage(message.shuffle_hand_extra, () => message.shuffle_hand_extra = StocGameMessage.MsgShuffleHandExtra.deserialize(reader));
                        break;
                    case 15:
                        reader.readMessage(message.select_battle_cmd, () => message.select_battle_cmd = StocGameMessage.MsgSelectBattleCmd.deserialize(reader));
                        break;
                    case 16:
                        reader.readMessage(message.pos_change, () => message.pos_change = StocGameMessage.MsgPosChange.deserialize(reader));
                        break;
                    case 17:
                        reader.readMessage(message.select_unselect_card, () => message.select_unselect_card = StocGameMessage.MsgSelectUnselectCard.deserialize(reader));
                        break;
                    case 18:
                        reader.readMessage(message.select_yes_no, () => message.select_yes_no = StocGameMessage.MsgSelectYesNo.deserialize(reader));
                        break;
                    case 19:
                        reader.readMessage(message.update_hp, () => message.update_hp = StocGameMessage.MsgUpdateHp.deserialize(reader));
                        break;
                    case 20:
                        reader.readMessage(message.win, () => message.win = StocGameMessage.MsgWin.deserialize(reader));
                        break;
                    case 21:
                        reader.readMessage(message.wait, () => message.wait = StocGameMessage.MsgWait.deserialize(reader));
                        break;
                    case 22:
                        reader.readMessage(message.unimplemented, () => message.unimplemented = StocGameMessage.MsgUnimplemented.deserialize(reader));
                        break;
                    case 23:
                        reader.readMessage(message.update_data, () => message.update_data = StocGameMessage.MsgUpdateData.deserialize(reader));
                        break;
                    case 24:
                        reader.readMessage(message.reload_field, () => message.reload_field = StocGameMessage.MsgReloadField.deserialize(reader));
                        break;
                    case 25:
                        reader.readMessage(message.select_sum, () => message.select_sum = StocGameMessage.MsgSelectSum.deserialize(reader));
                        break;
                    case 26:
                        reader.readMessage(message.select_tribute, () => message.select_tribute = StocGameMessage.MsgSelectTribute.deserialize(reader));
                        break;
                    case 27:
                        reader.readMessage(message.update_counter, () => message.update_counter = StocGameMessage.MsgUpdateCounter.deserialize(reader));
                        break;
                    case 28:
                        reader.readMessage(message.select_counter, () => message.select_counter = StocGameMessage.MsgSelectCounter.deserialize(reader));
                        break;
                    case 29:
                        reader.readMessage(message.sort_card, () => message.sort_card = StocGameMessage.MsgSortCard.deserialize(reader));
                        break;
                    case 30:
                        reader.readMessage(message.set, () => message.set = StocGameMessage.MsgSet.deserialize(reader));
                        break;
                    case 31:
                        reader.readMessage(message.swap, () => message.swap = StocGameMessage.MsgSwap.deserialize(reader));
                        break;
                    case 32:
                        reader.readMessage(message.summoning, () => message.summoning = StocGameMessage.MsgSummoning.deserialize(reader));
                        break;
                    case 33:
                        reader.readMessage(message.summoned, () => message.summoned = StocGameMessage.MsgSummoned.deserialize(reader));
                        break;
                    case 34:
                        reader.readMessage(message.flip_summoning, () => message.flip_summoning = StocGameMessage.MsgFlipSummoning.deserialize(reader));
                        break;
                    case 35:
                        reader.readMessage(message.flip_summoned, () => message.flip_summoned = StocGameMessage.MsgFlipSummoned.deserialize(reader));
                        break;
                    case 36:
                        reader.readMessage(message.sp_summoning, () => message.sp_summoning = StocGameMessage.MsgSpSummoning.deserialize(reader));
                        break;
                    case 37:
                        reader.readMessage(message.sp_summoned, () => message.sp_summoned = StocGameMessage.MsgSpSummoned.deserialize(reader));
                        break;
                    case 38:
                        reader.readMessage(message.chaining, () => message.chaining = StocGameMessage.MsgChaining.deserialize(reader));
                        break;
                    case 39:
                        reader.readMessage(message.attack, () => message.attack = StocGameMessage.MsgAttack.deserialize(reader));
                        break;
                    case 40:
                        reader.readMessage(message.attack_disable, () => message.attack_disable = StocGameMessage.MsgAttackDisabled.deserialize(reader));
                        break;
                    case 41:
                        reader.readMessage(message.chain_solved, () => message.chain_solved = StocGameMessage.MsgChainSolved.deserialize(reader));
                        break;
                    case 42:
                        reader.readMessage(message.chain_end, () => message.chain_end = StocGameMessage.MsgChainEnd.deserialize(reader));
                        break;
                    case 43:
                        reader.readMessage(message.announce, () => message.announce = StocGameMessage.MsgAnnounce.deserialize(reader));
                        break;
                    case 44:
                        reader.readMessage(message.lp_update, () => message.lp_update = StocGameMessage.MsgLpUpdate.deserialize(reader));
                        break;
                    case 45:
                        reader.readMessage(message.confirm_cards, () => message.confirm_cards = StocGameMessage.MsgConfirmCards.deserialize(reader));
                        break;
                    case 46:
                        reader.readMessage(message.become_target, () => message.become_target = StocGameMessage.MsgBecomeTarget.deserialize(reader));
                        break;
                    case 47:
                        reader.readMessage(message.toss, () => message.toss = StocGameMessage.MsgToss.deserialize(reader));
                        break;
                    case 48:
                        reader.readMessage(message.shuffle_set_card, () => message.shuffle_set_card = StocGameMessage.MsgShuffleSetCard.deserialize(reader));
                        break;
                    case 49:
                        reader.readMessage(message.field_disabled, () => message.field_disabled = StocGameMessage.MsgFieldDisabled.deserialize(reader));
                        break;
                    case 50:
                        reader.readMessage(message.shuffle_deck, () => message.shuffle_deck = StocGameMessage.MsgShuffleDeck.deserialize(reader));
                        break;
                    case 51:
                        reader.readMessage(message.rock_paper_scissors, () => message.rock_paper_scissors = StocGameMessage.MsgRockPaperScissors.deserialize(reader));
                        break;
                    case 52:
                        reader.readMessage(message.hand_res, () => message.hand_res = StocGameMessage.MsgHandResult.deserialize(reader));
                        break;
                    case 53:
                        reader.readMessage(message.swap_grave_deck, () => message.swap_grave_deck = StocGameMessage.MsgSwapGraveDeck.deserialize(reader));
                        break;
                    case 54:
                        reader.readMessage(message.sibyl_name, () => message.sibyl_name = StocGameMessage.MsgSibylName.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): StocGameMessage {
            return StocGameMessage.deserialize(bytes);
        }
    }
    export namespace StocGameMessage {
        export class MsgStart extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                playerType?: StocGameMessage.MsgStart.PlayerType;
                life1?: number;
                life2?: number;
                deckSize1?: number;
                deckSize2?: number;
                extraSize1?: number;
                extraSize2?: number;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("playerType" in data && data.playerType != undefined) {
                        this.playerType = data.playerType;
                    }
                    if ("life1" in data && data.life1 != undefined) {
                        this.life1 = data.life1;
                    }
                    if ("life2" in data && data.life2 != undefined) {
                        this.life2 = data.life2;
                    }
                    if ("deckSize1" in data && data.deckSize1 != undefined) {
                        this.deckSize1 = data.deckSize1;
                    }
                    if ("deckSize2" in data && data.deckSize2 != undefined) {
                        this.deckSize2 = data.deckSize2;
                    }
                    if ("extraSize1" in data && data.extraSize1 != undefined) {
                        this.extraSize1 = data.extraSize1;
                    }
                    if ("extraSize2" in data && data.extraSize2 != undefined) {
                        this.extraSize2 = data.extraSize2;
                    }
                }
            }
            get playerType() {
                return pb_1.Message.getFieldWithDefault(this, 1, StocGameMessage.MsgStart.PlayerType.UNKNOWN) as StocGameMessage.MsgStart.PlayerType;
            }
            set playerType(value: StocGameMessage.MsgStart.PlayerType) {
                pb_1.Message.setField(this, 1, value);
            }
            get life1() {
                return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
            }
            set life1(value: number) {
                pb_1.Message.setField(this, 2, value);
            }
            get life2() {
                return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
            }
            set life2(value: number) {
                pb_1.Message.setField(this, 3, value);
            }
            get deckSize1() {
                return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
            }
            set deckSize1(value: number) {
                pb_1.Message.setField(this, 4, value);
            }
            get deckSize2() {
                return pb_1.Message.getFieldWithDefault(this, 5, 0) as number;
            }
            set deckSize2(value: number) {
                pb_1.Message.setField(this, 5, value);
            }
            get extraSize1() {
                return pb_1.Message.getFieldWithDefault(this, 6, 0) as number;
            }
            set extraSize1(value: number) {
                pb_1.Message.setField(this, 6, value);
            }
            get extraSize2() {
                return pb_1.Message.getFieldWithDefault(this, 7, 0) as number;
            }
            set extraSize2(value: number) {
                pb_1.Message.setField(this, 7, value);
            }
            static fromObject(data: {
                playerType?: StocGameMessage.MsgStart.PlayerType;
                life1?: number;
                life2?: number;
                deckSize1?: number;
                deckSize2?: number;
                extraSize1?: number;
                extraSize2?: number;
            }): MsgStart {
                const message = new MsgStart({});
                if (data.playerType != null) {
                    message.playerType = data.playerType;
                }
                if (data.life1 != null) {
                    message.life1 = data.life1;
                }
                if (data.life2 != null) {
                    message.life2 = data.life2;
                }
                if (data.deckSize1 != null) {
                    message.deckSize1 = data.deckSize1;
                }
                if (data.deckSize2 != null) {
                    message.deckSize2 = data.deckSize2;
                }
                if (data.extraSize1 != null) {
                    message.extraSize1 = data.extraSize1;
                }
                if (data.extraSize2 != null) {
                    message.extraSize2 = data.extraSize2;
                }
                return message;
            }
            toObject() {
                const data: {
                    playerType?: StocGameMessage.MsgStart.PlayerType;
                    life1?: number;
                    life2?: number;
                    deckSize1?: number;
                    deckSize2?: number;
                    extraSize1?: number;
                    extraSize2?: number;
                } = {};
                if (this.playerType != null) {
                    data.playerType = this.playerType;
                }
                if (this.life1 != null) {
                    data.life1 = this.life1;
                }
                if (this.life2 != null) {
                    data.life2 = this.life2;
                }
                if (this.deckSize1 != null) {
                    data.deckSize1 = this.deckSize1;
                }
                if (this.deckSize2 != null) {
                    data.deckSize2 = this.deckSize2;
                }
                if (this.extraSize1 != null) {
                    data.extraSize1 = this.extraSize1;
                }
                if (this.extraSize2 != null) {
                    data.extraSize2 = this.extraSize2;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.playerType != StocGameMessage.MsgStart.PlayerType.UNKNOWN)
                    writer.writeEnum(1, this.playerType);
                if (this.life1 != 0)
                    writer.writeInt32(2, this.life1);
                if (this.life2 != 0)
                    writer.writeInt32(3, this.life2);
                if (this.deckSize1 != 0)
                    writer.writeInt32(4, this.deckSize1);
                if (this.deckSize2 != 0)
                    writer.writeInt32(5, this.deckSize2);
                if (this.extraSize1 != 0)
                    writer.writeInt32(6, this.extraSize1);
                if (this.extraSize2 != 0)
                    writer.writeInt32(7, this.extraSize2);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgStart {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgStart();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.playerType = reader.readEnum();
                            break;
                        case 2:
                            message.life1 = reader.readInt32();
                            break;
                        case 3:
                            message.life2 = reader.readInt32();
                            break;
                        case 4:
                            message.deckSize1 = reader.readInt32();
                            break;
                        case 5:
                            message.deckSize2 = reader.readInt32();
                            break;
                        case 6:
                            message.extraSize1 = reader.readInt32();
                            break;
                        case 7:
                            message.extraSize2 = reader.readInt32();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): MsgStart {
                return MsgStart.deserialize(bytes);
            }
        }
        export namespace MsgStart {
            export enum PlayerType {
                UNKNOWN = 0,
                FirstStrike = 1,
                SecondStrike = 2,
                Observer = 3
            }
        }
        export class MsgDraw extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                player?: number;
                count?: number;
                cards?: number[];
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [3], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("player" in data && data.player != undefined) {
                        this.player = data.player;
                    }
                    if ("count" in data && data.count != undefined) {
                        this.count = data.count;
                    }
                    if ("cards" in data && data.cards != undefined) {
                        this.cards = data.cards;
                    }
                }
            }
            get player() {
                return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
            }
            set player(value: number) {
                pb_1.Message.setField(this, 1, value);
            }
            get count() {
                return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
            }
            set count(value: number) {
                pb_1.Message.setField(this, 2, value);
            }
            get cards() {
                return pb_1.Message.getFieldWithDefault(this, 3, []) as number[];
            }
            set cards(value: number[]) {
                pb_1.Message.setField(this, 3, value);
            }
            static fromObject(data: {
                player?: number;
                count?: number;
                cards?: number[];
            }): MsgDraw {
                const message = new MsgDraw({});
                if (data.player != null) {
                    message.player = data.player;
                }
                if (data.count != null) {
                    message.count = data.count;
                }
                if (data.cards != null) {
                    message.cards = data.cards;
                }
                return message;
            }
            toObject() {
                const data: {
                    player?: number;
                    count?: number;
                    cards?: number[];
                } = {};
                if (this.player != null) {
                    data.player = this.player;
                }
                if (this.count != null) {
                    data.count = this.count;
                }
                if (this.cards != null) {
                    data.cards = this.cards;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.player != 0)
                    writer.writeInt32(1, this.player);
                if (this.count != 0)
                    writer.writeInt32(2, this.count);
                if (this.cards.length)
                    writer.writePackedInt32(3, this.cards);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgDraw {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgDraw();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.player = reader.readInt32();
                            break;
                        case 2:
                            message.count = reader.readInt32();
                            break;
                        case 3:
                            message.cards = reader.readPackedInt32();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): MsgDraw {
                return MsgDraw.deserialize(bytes);
            }
        }
        export class MsgNewTurn extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                player?: number;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("player" in data && data.player != undefined) {
                        this.player = data.player;
                    }
                }
            }
            get player() {
                return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
            }
            set player(value: number) {
                pb_1.Message.setField(this, 1, value);
            }
            static fromObject(data: {
                player?: number;
            }): MsgNewTurn {
                const message = new MsgNewTurn({});
                if (data.player != null) {
                    message.player = data.player;
                }
                return message;
            }
            toObject() {
                const data: {
                    player?: number;
                } = {};
                if (this.player != null) {
                    data.player = this.player;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.player != 0)
                    writer.writeInt32(1, this.player);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgNewTurn {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgNewTurn();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.player = reader.readInt32();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): MsgNewTurn {
                return MsgNewTurn.deserialize(bytes);
            }
        }
        export class MsgNewPhase extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                phase_type?: StocGameMessage.MsgNewPhase.PhaseType;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("phase_type" in data && data.phase_type != undefined) {
                        this.phase_type = data.phase_type;
                    }
                }
            }
            get phase_type() {
                return pb_1.Message.getFieldWithDefault(this, 1, StocGameMessage.MsgNewPhase.PhaseType.UNKNOWN) as StocGameMessage.MsgNewPhase.PhaseType;
            }
            set phase_type(value: StocGameMessage.MsgNewPhase.PhaseType) {
                pb_1.Message.setField(this, 1, value);
            }
            static fromObject(data: {
                phase_type?: StocGameMessage.MsgNewPhase.PhaseType;
            }): MsgNewPhase {
                const message = new MsgNewPhase({});
                if (data.phase_type != null) {
                    message.phase_type = data.phase_type;
                }
                return message;
            }
            toObject() {
                const data: {
                    phase_type?: StocGameMessage.MsgNewPhase.PhaseType;
                } = {};
                if (this.phase_type != null) {
                    data.phase_type = this.phase_type;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.phase_type != StocGameMessage.MsgNewPhase.PhaseType.UNKNOWN)
                    writer.writeEnum(1, this.phase_type);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgNewPhase {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgNewPhase();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.phase_type = reader.readEnum();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): MsgNewPhase {
                return MsgNewPhase.deserialize(bytes);
            }
        }
        export namespace MsgNewPhase {
            export enum PhaseType {
                UNKNOWN = 0,
                DRAW = 1,
                STANDBY = 2,
                MAIN1 = 3,
                BATTLE_START = 4,
                BATTLE_STEP = 5,
                DAMAGE = 6,
                DAMAGE_GAL = 7,
                BATTLE = 8,
                MAIN2 = 9,
                END = 10
            }
        }
        export class MsgHint extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                hint_type?: StocGameMessage.MsgHint.HintType;
                player?: number;
                hint_data?: number;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("hint_type" in data && data.hint_type != undefined) {
                        this.hint_type = data.hint_type;
                    }
                    if ("player" in data && data.player != undefined) {
                        this.player = data.player;
                    }
                    if ("hint_data" in data && data.hint_data != undefined) {
                        this.hint_data = data.hint_data;
                    }
                }
            }
            get hint_type() {
                return pb_1.Message.getFieldWithDefault(this, 1, StocGameMessage.MsgHint.HintType.UNKNOWN) as StocGameMessage.MsgHint.HintType;
            }
            set hint_type(value: StocGameMessage.MsgHint.HintType) {
                pb_1.Message.setField(this, 1, value);
            }
            get player() {
                return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
            }
            set player(value: number) {
                pb_1.Message.setField(this, 2, value);
            }
            get hint_data() {
                return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
            }
            set hint_data(value: number) {
                pb_1.Message.setField(this, 3, value);
            }
            static fromObject(data: {
                hint_type?: StocGameMessage.MsgHint.HintType;
                player?: number;
                hint_data?: number;
            }): MsgHint {
                const message = new MsgHint({});
                if (data.hint_type != null) {
                    message.hint_type = data.hint_type;
                }
                if (data.player != null) {
                    message.player = data.player;
                }
                if (data.hint_data != null) {
                    message.hint_data = data.hint_data;
                }
                return message;
            }
            toObject() {
                const data: {
                    hint_type?: StocGameMessage.MsgHint.HintType;
                    player?: number;
                    hint_data?: number;
                } = {};
                if (this.hint_type != null) {
                    data.hint_type = this.hint_type;
                }
                if (this.player != null) {
                    data.player = this.player;
                }
                if (this.hint_data != null) {
                    data.hint_data = this.hint_data;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.hint_type != StocGameMessage.MsgHint.HintType.UNKNOWN)
                    writer.writeEnum(1, this.hint_type);
                if (this.player != 0)
                    writer.writeInt32(2, this.player);
                if (this.hint_data != 0)
                    writer.writeInt32(3, this.hint_data);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgHint {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgHint();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.hint_type = reader.readEnum();
                            break;
                        case 2:
                            message.player = reader.readInt32();
                            break;
                        case 3:
                            message.hint_data = reader.readInt32();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): MsgHint {
                return MsgHint.deserialize(bytes);
            }
        }
        export namespace MsgHint {
            export enum HintType {
                UNKNOWN = 0,
                HINT_EVENT = 1,
                HINT_MESSAGE = 2,
                HINT_SELECTMSG = 3,
                HINT_OPSELECTED = 4,
                HINT_EFFECT = 5,
                HINT_RACE = 6,
                HINT_ATTRIB = 7,
                HINT_CODE = 8,
                HINT_NUMBER = 9,
                HINT_CARD = 10,
                HINT_ZONE = 11
            }
        }
        export class MsgSelectIdleCmd extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                player?: number;
                idle_cmds?: StocGameMessage.MsgSelectIdleCmd.IdleCmd[];
                enable_bp?: boolean;
                enable_ep?: boolean;
                enable_shuffle?: boolean;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("player" in data && data.player != undefined) {
                        this.player = data.player;
                    }
                    if ("idle_cmds" in data && data.idle_cmds != undefined) {
                        this.idle_cmds = data.idle_cmds;
                    }
                    if ("enable_bp" in data && data.enable_bp != undefined) {
                        this.enable_bp = data.enable_bp;
                    }
                    if ("enable_ep" in data && data.enable_ep != undefined) {
                        this.enable_ep = data.enable_ep;
                    }
                    if ("enable_shuffle" in data && data.enable_shuffle != undefined) {
                        this.enable_shuffle = data.enable_shuffle;
                    }
                }
            }
            get player() {
                return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
            }
            set player(value: number) {
                pb_1.Message.setField(this, 1, value);
            }
            get idle_cmds() {
                return pb_1.Message.getRepeatedWrapperField(this, StocGameMessage.MsgSelectIdleCmd.IdleCmd, 2) as StocGameMessage.MsgSelectIdleCmd.IdleCmd[];
            }
            set idle_cmds(value: StocGameMessage.MsgSelectIdleCmd.IdleCmd[]) {
                pb_1.Message.setRepeatedWrapperField(this, 2, value);
            }
            get enable_bp() {
                return pb_1.Message.getFieldWithDefault(this, 3, false) as boolean;
            }
            set enable_bp(value: boolean) {
                pb_1.Message.setField(this, 3, value);
            }
            get enable_ep() {
                return pb_1.Message.getFieldWithDefault(this, 4, false) as boolean;
            }
            set enable_ep(value: boolean) {
                pb_1.Message.setField(this, 4, value);
            }
            get enable_shuffle() {
                return pb_1.Message.getFieldWithDefault(this, 5, false) as boolean;
            }
            set enable_shuffle(value: boolean) {
                pb_1.Message.setField(this, 5, value);
            }
            static fromObject(data: {
                player?: number;
                idle_cmds?: ReturnType<typeof StocGameMessage.MsgSelectIdleCmd.IdleCmd.prototype.toObject>[];
                enable_bp?: boolean;
                enable_ep?: boolean;
                enable_shuffle?: boolean;
            }): MsgSelectIdleCmd {
                const message = new MsgSelectIdleCmd({});
                if (data.player != null) {
                    message.player = data.player;
                }
                if (data.idle_cmds != null) {
                    message.idle_cmds = data.idle_cmds.map(item => StocGameMessage.MsgSelectIdleCmd.IdleCmd.fromObject(item));
                }
                if (data.enable_bp != null) {
                    message.enable_bp = data.enable_bp;
                }
                if (data.enable_ep != null) {
                    message.enable_ep = data.enable_ep;
                }
                if (data.enable_shuffle != null) {
                    message.enable_shuffle = data.enable_shuffle;
                }
                return message;
            }
            toObject() {
                const data: {
                    player?: number;
                    idle_cmds?: ReturnType<typeof StocGameMessage.MsgSelectIdleCmd.IdleCmd.prototype.toObject>[];
                    enable_bp?: boolean;
                    enable_ep?: boolean;
                    enable_shuffle?: boolean;
                } = {};
                if (this.player != null) {
                    data.player = this.player;
                }
                if (this.idle_cmds != null) {
                    data.idle_cmds = this.idle_cmds.map((item: StocGameMessage.MsgSelectIdleCmd.IdleCmd) => item.toObject());
                }
                if (this.enable_bp != null) {
                    data.enable_bp = this.enable_bp;
                }
                if (this.enable_ep != null) {
                    data.enable_ep = this.enable_ep;
                }
                if (this.enable_shuffle != null) {
                    data.enable_shuffle = this.enable_shuffle;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.player != 0)
                    writer.writeInt32(1, this.player);
                if (this.idle_cmds.length)
                    writer.writeRepeatedMessage(2, this.idle_cmds, (item: StocGameMessage.MsgSelectIdleCmd.IdleCmd) => item.serialize(writer));
                if (this.enable_bp != false)
                    writer.writeBool(3, this.enable_bp);
                if (this.enable_ep != false)
                    writer.writeBool(4, this.enable_ep);
                if (this.enable_shuffle != false)
                    writer.writeBool(5, this.enable_shuffle);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgSelectIdleCmd {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgSelectIdleCmd();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.player = reader.readInt32();
                            break;
                        case 2:
                            reader.readMessage(message.idle_cmds, () => pb_1.Message.addToRepeatedWrapperField(message, 2, StocGameMessage.MsgSelectIdleCmd.IdleCmd.deserialize(reader), StocGameMessage.MsgSelectIdleCmd.IdleCmd));
                            break;
                        case 3:
                            message.enable_bp = reader.readBool();
                            break;
                        case 4:
                            message.enable_ep = reader.readBool();
                            break;
                        case 5:
                            message.enable_shuffle = reader.readBool();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): MsgSelectIdleCmd {
                return MsgSelectIdleCmd.deserialize(bytes);
            }
        }
        export namespace MsgSelectIdleCmd {
            export class IdleCmd extends pb_1.Message {
                #one_of_decls: number[][] = [];
                constructor(data?: any[] | {
                    idle_type?: StocGameMessage.MsgSelectIdleCmd.IdleCmd.IdleType;
                    idle_datas?: StocGameMessage.MsgSelectIdleCmd.IdleCmd.IdleData[];
                }) {
                    super();
                    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2], this.#one_of_decls);
                    if (!Array.isArray(data) && typeof data == "object") {
                        if ("idle_type" in data && data.idle_type != undefined) {
                            this.idle_type = data.idle_type;
                        }
                        if ("idle_datas" in data && data.idle_datas != undefined) {
                            this.idle_datas = data.idle_datas;
                        }
                    }
                }
                get idle_type() {
                    return pb_1.Message.getFieldWithDefault(this, 1, StocGameMessage.MsgSelectIdleCmd.IdleCmd.IdleType.UNKNOWN) as StocGameMessage.MsgSelectIdleCmd.IdleCmd.IdleType;
                }
                set idle_type(value: StocGameMessage.MsgSelectIdleCmd.IdleCmd.IdleType) {
                    pb_1.Message.setField(this, 1, value);
                }
                get idle_datas() {
                    return pb_1.Message.getRepeatedWrapperField(this, StocGameMessage.MsgSelectIdleCmd.IdleCmd.IdleData, 2) as StocGameMessage.MsgSelectIdleCmd.IdleCmd.IdleData[];
                }
                set idle_datas(value: StocGameMessage.MsgSelectIdleCmd.IdleCmd.IdleData[]) {
                    pb_1.Message.setRepeatedWrapperField(this, 2, value);
                }
                static fromObject(data: {
                    idle_type?: StocGameMessage.MsgSelectIdleCmd.IdleCmd.IdleType;
                    idle_datas?: ReturnType<typeof StocGameMessage.MsgSelectIdleCmd.IdleCmd.IdleData.prototype.toObject>[];
                }): IdleCmd {
                    const message = new IdleCmd({});
                    if (data.idle_type != null) {
                        message.idle_type = data.idle_type;
                    }
                    if (data.idle_datas != null) {
                        message.idle_datas = data.idle_datas.map(item => StocGameMessage.MsgSelectIdleCmd.IdleCmd.IdleData.fromObject(item));
                    }
                    return message;
                }
                toObject() {
                    const data: {
                        idle_type?: StocGameMessage.MsgSelectIdleCmd.IdleCmd.IdleType;
                        idle_datas?: ReturnType<typeof StocGameMessage.MsgSelectIdleCmd.IdleCmd.IdleData.prototype.toObject>[];
                    } = {};
                    if (this.idle_type != null) {
                        data.idle_type = this.idle_type;
                    }
                    if (this.idle_datas != null) {
                        data.idle_datas = this.idle_datas.map((item: StocGameMessage.MsgSelectIdleCmd.IdleCmd.IdleData) => item.toObject());
                    }
                    return data;
                }
                serialize(): Uint8Array;
                serialize(w: pb_1.BinaryWriter): void;
                serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                    const writer = w || new pb_1.BinaryWriter();
                    if (this.idle_type != StocGameMessage.MsgSelectIdleCmd.IdleCmd.IdleType.UNKNOWN)
                        writer.writeEnum(1, this.idle_type);
                    if (this.idle_datas.length)
                        writer.writeRepeatedMessage(2, this.idle_datas, (item: StocGameMessage.MsgSelectIdleCmd.IdleCmd.IdleData) => item.serialize(writer));
                    if (!w)
                        return writer.getResultBuffer();
                }
                static deserialize(bytes: Uint8Array | pb_1.BinaryReader): IdleCmd {
                    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new IdleCmd();
                    while (reader.nextField()) {
                        if (reader.isEndGroup())
                            break;
                        switch (reader.getFieldNumber()) {
                            case 1:
                                message.idle_type = reader.readEnum();
                                break;
                            case 2:
                                reader.readMessage(message.idle_datas, () => pb_1.Message.addToRepeatedWrapperField(message, 2, StocGameMessage.MsgSelectIdleCmd.IdleCmd.IdleData.deserialize(reader), StocGameMessage.MsgSelectIdleCmd.IdleCmd.IdleData));
                                break;
                            default: reader.skipField();
                        }
                    }
                    return message;
                }
                serializeBinary(): Uint8Array {
                    return this.serialize();
                }
                static deserializeBinary(bytes: Uint8Array): IdleCmd {
                    return IdleCmd.deserialize(bytes);
                }
            }
            export namespace IdleCmd {
                export enum IdleType {
                    UNKNOWN = 0,
                    SUMMON = 1,
                    SPSUMMON = 2,
                    POS_CHANGE = 3,
                    MSET = 4,
                    SSET = 5,
                    ACTIVATE = 6,
                    TO_BP = 7,
                    TO_EP = 8,
                    SHUFFLE = 9
                }
                export class IdleData extends pb_1.Message {
                    #one_of_decls: number[][] = [];
                    constructor(data?: any[] | {
                        card_info?: CardInfo;
                        effect_description?: number;
                        response?: number;
                    }) {
                        super();
                        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                        if (!Array.isArray(data) && typeof data == "object") {
                            if ("card_info" in data && data.card_info != undefined) {
                                this.card_info = data.card_info;
                            }
                            if ("effect_description" in data && data.effect_description != undefined) {
                                this.effect_description = data.effect_description;
                            }
                            if ("response" in data && data.response != undefined) {
                                this.response = data.response;
                            }
                        }
                    }
                    get card_info() {
                        return pb_1.Message.getWrapperField(this, CardInfo, 1) as CardInfo;
                    }
                    set card_info(value: CardInfo) {
                        pb_1.Message.setWrapperField(this, 1, value);
                    }
                    get has_card_info() {
                        return pb_1.Message.getField(this, 1) != null;
                    }
                    get effect_description() {
                        return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
                    }
                    set effect_description(value: number) {
                        pb_1.Message.setField(this, 2, value);
                    }
                    get response() {
                        return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
                    }
                    set response(value: number) {
                        pb_1.Message.setField(this, 3, value);
                    }
                    static fromObject(data: {
                        card_info?: ReturnType<typeof CardInfo.prototype.toObject>;
                        effect_description?: number;
                        response?: number;
                    }): IdleData {
                        const message = new IdleData({});
                        if (data.card_info != null) {
                            message.card_info = CardInfo.fromObject(data.card_info);
                        }
                        if (data.effect_description != null) {
                            message.effect_description = data.effect_description;
                        }
                        if (data.response != null) {
                            message.response = data.response;
                        }
                        return message;
                    }
                    toObject() {
                        const data: {
                            card_info?: ReturnType<typeof CardInfo.prototype.toObject>;
                            effect_description?: number;
                            response?: number;
                        } = {};
                        if (this.card_info != null) {
                            data.card_info = this.card_info.toObject();
                        }
                        if (this.effect_description != null) {
                            data.effect_description = this.effect_description;
                        }
                        if (this.response != null) {
                            data.response = this.response;
                        }
                        return data;
                    }
                    serialize(): Uint8Array;
                    serialize(w: pb_1.BinaryWriter): void;
                    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                        const writer = w || new pb_1.BinaryWriter();
                        if (this.has_card_info)
                            writer.writeMessage(1, this.card_info, () => this.card_info.serialize(writer));
                        if (this.effect_description != 0)
                            writer.writeInt32(2, this.effect_description);
                        if (this.response != 0)
                            writer.writeInt32(3, this.response);
                        if (!w)
                            return writer.getResultBuffer();
                    }
                    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): IdleData {
                        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new IdleData();
                        while (reader.nextField()) {
                            if (reader.isEndGroup())
                                break;
                            switch (reader.getFieldNumber()) {
                                case 1:
                                    reader.readMessage(message.card_info, () => message.card_info = CardInfo.deserialize(reader));
                                    break;
                                case 2:
                                    message.effect_description = reader.readInt32();
                                    break;
                                case 3:
                                    message.response = reader.readInt32();
                                    break;
                                default: reader.skipField();
                            }
                        }
                        return message;
                    }
                    serializeBinary(): Uint8Array {
                        return this.serialize();
                    }
                    static deserializeBinary(bytes: Uint8Array): IdleData {
                        return IdleData.deserialize(bytes);
                    }
                }
            }
        }
        export class MsgSelectPlace extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                player?: number;
                count?: number;
                places?: StocGameMessage.MsgSelectPlace.SelectAblePlace[];
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [3], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("player" in data && data.player != undefined) {
                        this.player = data.player;
                    }
                    if ("count" in data && data.count != undefined) {
                        this.count = data.count;
                    }
                    if ("places" in data && data.places != undefined) {
                        this.places = data.places;
                    }
                }
            }
            get player() {
                return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
            }
            set player(value: number) {
                pb_1.Message.setField(this, 1, value);
            }
            get count() {
                return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
            }
            set count(value: number) {
                pb_1.Message.setField(this, 2, value);
            }
            get places() {
                return pb_1.Message.getRepeatedWrapperField(this, StocGameMessage.MsgSelectPlace.SelectAblePlace, 3) as StocGameMessage.MsgSelectPlace.SelectAblePlace[];
            }
            set places(value: StocGameMessage.MsgSelectPlace.SelectAblePlace[]) {
                pb_1.Message.setRepeatedWrapperField(this, 3, value);
            }
            static fromObject(data: {
                player?: number;
                count?: number;
                places?: ReturnType<typeof StocGameMessage.MsgSelectPlace.SelectAblePlace.prototype.toObject>[];
            }): MsgSelectPlace {
                const message = new MsgSelectPlace({});
                if (data.player != null) {
                    message.player = data.player;
                }
                if (data.count != null) {
                    message.count = data.count;
                }
                if (data.places != null) {
                    message.places = data.places.map(item => StocGameMessage.MsgSelectPlace.SelectAblePlace.fromObject(item));
                }
                return message;
            }
            toObject() {
                const data: {
                    player?: number;
                    count?: number;
                    places?: ReturnType<typeof StocGameMessage.MsgSelectPlace.SelectAblePlace.prototype.toObject>[];
                } = {};
                if (this.player != null) {
                    data.player = this.player;
                }
                if (this.count != null) {
                    data.count = this.count;
                }
                if (this.places != null) {
                    data.places = this.places.map((item: StocGameMessage.MsgSelectPlace.SelectAblePlace) => item.toObject());
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.player != 0)
                    writer.writeInt32(1, this.player);
                if (this.count != 0)
                    writer.writeInt32(2, this.count);
                if (this.places.length)
                    writer.writeRepeatedMessage(3, this.places, (item: StocGameMessage.MsgSelectPlace.SelectAblePlace) => item.serialize(writer));
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgSelectPlace {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgSelectPlace();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.player = reader.readInt32();
                            break;
                        case 2:
                            message.count = reader.readInt32();
                            break;
                        case 3:
                            reader.readMessage(message.places, () => pb_1.Message.addToRepeatedWrapperField(message, 3, StocGameMessage.MsgSelectPlace.SelectAblePlace.deserialize(reader), StocGameMessage.MsgSelectPlace.SelectAblePlace));
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): MsgSelectPlace {
                return MsgSelectPlace.deserialize(bytes);
            }
        }
        export namespace MsgSelectPlace {
            export class SelectAblePlace extends pb_1.Message {
                #one_of_decls: number[][] = [];
                constructor(data?: any[] | {
                    controller?: number;
                    zone?: CardZone;
                    sequence?: number;
                }) {
                    super();
                    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                    if (!Array.isArray(data) && typeof data == "object") {
                        if ("controller" in data && data.controller != undefined) {
                            this.controller = data.controller;
                        }
                        if ("zone" in data && data.zone != undefined) {
                            this.zone = data.zone;
                        }
                        if ("sequence" in data && data.sequence != undefined) {
                            this.sequence = data.sequence;
                        }
                    }
                }
                get controller() {
                    return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
                }
                set controller(value: number) {
                    pb_1.Message.setField(this, 1, value);
                }
                get zone() {
                    return pb_1.Message.getFieldWithDefault(this, 2, CardZone.DECK) as CardZone;
                }
                set zone(value: CardZone) {
                    pb_1.Message.setField(this, 2, value);
                }
                get sequence() {
                    return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
                }
                set sequence(value: number) {
                    pb_1.Message.setField(this, 3, value);
                }
                static fromObject(data: {
                    controller?: number;
                    zone?: CardZone;
                    sequence?: number;
                }): SelectAblePlace {
                    const message = new SelectAblePlace({});
                    if (data.controller != null) {
                        message.controller = data.controller;
                    }
                    if (data.zone != null) {
                        message.zone = data.zone;
                    }
                    if (data.sequence != null) {
                        message.sequence = data.sequence;
                    }
                    return message;
                }
                toObject() {
                    const data: {
                        controller?: number;
                        zone?: CardZone;
                        sequence?: number;
                    } = {};
                    if (this.controller != null) {
                        data.controller = this.controller;
                    }
                    if (this.zone != null) {
                        data.zone = this.zone;
                    }
                    if (this.sequence != null) {
                        data.sequence = this.sequence;
                    }
                    return data;
                }
                serialize(): Uint8Array;
                serialize(w: pb_1.BinaryWriter): void;
                serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                    const writer = w || new pb_1.BinaryWriter();
                    if (this.controller != 0)
                        writer.writeInt32(1, this.controller);
                    if (this.zone != CardZone.DECK)
                        writer.writeEnum(2, this.zone);
                    if (this.sequence != 0)
                        writer.writeInt32(3, this.sequence);
                    if (!w)
                        return writer.getResultBuffer();
                }
                static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SelectAblePlace {
                    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SelectAblePlace();
                    while (reader.nextField()) {
                        if (reader.isEndGroup())
                            break;
                        switch (reader.getFieldNumber()) {
                            case 1:
                                message.controller = reader.readInt32();
                                break;
                            case 2:
                                message.zone = reader.readEnum();
                                break;
                            case 3:
                                message.sequence = reader.readInt32();
                                break;
                            default: reader.skipField();
                        }
                    }
                    return message;
                }
                serializeBinary(): Uint8Array {
                    return this.serialize();
                }
                static deserializeBinary(bytes: Uint8Array): SelectAblePlace {
                    return SelectAblePlace.deserialize(bytes);
                }
            }
        }
        export class MsgMove extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                code?: number;
                from?: CardLocation;
                to?: CardLocation;
                reason?: number;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("code" in data && data.code != undefined) {
                        this.code = data.code;
                    }
                    if ("from" in data && data.from != undefined) {
                        this.from = data.from;
                    }
                    if ("to" in data && data.to != undefined) {
                        this.to = data.to;
                    }
                    if ("reason" in data && data.reason != undefined) {
                        this.reason = data.reason;
                    }
                }
            }
            get code() {
                return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
            }
            set code(value: number) {
                pb_1.Message.setField(this, 1, value);
            }
            get from() {
                return pb_1.Message.getWrapperField(this, CardLocation, 2) as CardLocation;
            }
            set from(value: CardLocation) {
                pb_1.Message.setWrapperField(this, 2, value);
            }
            get has_from() {
                return pb_1.Message.getField(this, 2) != null;
            }
            get to() {
                return pb_1.Message.getWrapperField(this, CardLocation, 3) as CardLocation;
            }
            set to(value: CardLocation) {
                pb_1.Message.setWrapperField(this, 3, value);
            }
            get has_to() {
                return pb_1.Message.getField(this, 3) != null;
            }
            get reason() {
                return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
            }
            set reason(value: number) {
                pb_1.Message.setField(this, 4, value);
            }
            static fromObject(data: {
                code?: number;
                from?: ReturnType<typeof CardLocation.prototype.toObject>;
                to?: ReturnType<typeof CardLocation.prototype.toObject>;
                reason?: number;
            }): MsgMove {
                const message = new MsgMove({});
                if (data.code != null) {
                    message.code = data.code;
                }
                if (data.from != null) {
                    message.from = CardLocation.fromObject(data.from);
                }
                if (data.to != null) {
                    message.to = CardLocation.fromObject(data.to);
                }
                if (data.reason != null) {
                    message.reason = data.reason;
                }
                return message;
            }
            toObject() {
                const data: {
                    code?: number;
                    from?: ReturnType<typeof CardLocation.prototype.toObject>;
                    to?: ReturnType<typeof CardLocation.prototype.toObject>;
                    reason?: number;
                } = {};
                if (this.code != null) {
                    data.code = this.code;
                }
                if (this.from != null) {
                    data.from = this.from.toObject();
                }
                if (this.to != null) {
                    data.to = this.to.toObject();
                }
                if (this.reason != null) {
                    data.reason = this.reason;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.code != 0)
                    writer.writeInt32(1, this.code);
                if (this.has_from)
                    writer.writeMessage(2, this.from, () => this.from.serialize(writer));
                if (this.has_to)
                    writer.writeMessage(3, this.to, () => this.to.serialize(writer));
                if (this.reason != 0)
                    writer.writeInt32(4, this.reason);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgMove {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgMove();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.code = reader.readInt32();
                            break;
                        case 2:
                            reader.readMessage(message.from, () => message.from = CardLocation.deserialize(reader));
                            break;
                        case 3:
                            reader.readMessage(message.to, () => message.to = CardLocation.deserialize(reader));
                            break;
                        case 4:
                            message.reason = reader.readInt32();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): MsgMove {
                return MsgMove.deserialize(bytes);
            }
        }
        export class MsgSelectCard extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                player?: number;
                cancelable?: boolean;
                min?: number;
                max?: number;
                cards?: StocGameMessage.MsgSelectCard.SelectAbleCard[];
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [5], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("player" in data && data.player != undefined) {
                        this.player = data.player;
                    }
                    if ("cancelable" in data && data.cancelable != undefined) {
                        this.cancelable = data.cancelable;
                    }
                    if ("min" in data && data.min != undefined) {
                        this.min = data.min;
                    }
                    if ("max" in data && data.max != undefined) {
                        this.max = data.max;
                    }
                    if ("cards" in data && data.cards != undefined) {
                        this.cards = data.cards;
                    }
                }
            }
            get player() {
                return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
            }
            set player(value: number) {
                pb_1.Message.setField(this, 1, value);
            }
            get cancelable() {
                return pb_1.Message.getFieldWithDefault(this, 2, false) as boolean;
            }
            set cancelable(value: boolean) {
                pb_1.Message.setField(this, 2, value);
            }
            get min() {
                return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
            }
            set min(value: number) {
                pb_1.Message.setField(this, 3, value);
            }
            get max() {
                return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
            }
            set max(value: number) {
                pb_1.Message.setField(this, 4, value);
            }
            get cards() {
                return pb_1.Message.getRepeatedWrapperField(this, StocGameMessage.MsgSelectCard.SelectAbleCard, 5) as StocGameMessage.MsgSelectCard.SelectAbleCard[];
            }
            set cards(value: StocGameMessage.MsgSelectCard.SelectAbleCard[]) {
                pb_1.Message.setRepeatedWrapperField(this, 5, value);
            }
            static fromObject(data: {
                player?: number;
                cancelable?: boolean;
                min?: number;
                max?: number;
                cards?: ReturnType<typeof StocGameMessage.MsgSelectCard.SelectAbleCard.prototype.toObject>[];
            }): MsgSelectCard {
                const message = new MsgSelectCard({});
                if (data.player != null) {
                    message.player = data.player;
                }
                if (data.cancelable != null) {
                    message.cancelable = data.cancelable;
                }
                if (data.min != null) {
                    message.min = data.min;
                }
                if (data.max != null) {
                    message.max = data.max;
                }
                if (data.cards != null) {
                    message.cards = data.cards.map(item => StocGameMessage.MsgSelectCard.SelectAbleCard.fromObject(item));
                }
                return message;
            }
            toObject() {
                const data: {
                    player?: number;
                    cancelable?: boolean;
                    min?: number;
                    max?: number;
                    cards?: ReturnType<typeof StocGameMessage.MsgSelectCard.SelectAbleCard.prototype.toObject>[];
                } = {};
                if (this.player != null) {
                    data.player = this.player;
                }
                if (this.cancelable != null) {
                    data.cancelable = this.cancelable;
                }
                if (this.min != null) {
                    data.min = this.min;
                }
                if (this.max != null) {
                    data.max = this.max;
                }
                if (this.cards != null) {
                    data.cards = this.cards.map((item: StocGameMessage.MsgSelectCard.SelectAbleCard) => item.toObject());
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.player != 0)
                    writer.writeInt32(1, this.player);
                if (this.cancelable != false)
                    writer.writeBool(2, this.cancelable);
                if (this.min != 0)
                    writer.writeInt32(3, this.min);
                if (this.max != 0)
                    writer.writeInt32(4, this.max);
                if (this.cards.length)
                    writer.writeRepeatedMessage(5, this.cards, (item: StocGameMessage.MsgSelectCard.SelectAbleCard) => item.serialize(writer));
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgSelectCard {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgSelectCard();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.player = reader.readInt32();
                            break;
                        case 2:
                            message.cancelable = reader.readBool();
                            break;
                        case 3:
                            message.min = reader.readInt32();
                            break;
                        case 4:
                            message.max = reader.readInt32();
                            break;
                        case 5:
                            reader.readMessage(message.cards, () => pb_1.Message.addToRepeatedWrapperField(message, 5, StocGameMessage.MsgSelectCard.SelectAbleCard.deserialize(reader), StocGameMessage.MsgSelectCard.SelectAbleCard));
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): MsgSelectCard {
                return MsgSelectCard.deserialize(bytes);
            }
        }
        export namespace MsgSelectCard {
            export class SelectAbleCard extends pb_1.Message {
                #one_of_decls: number[][] = [];
                constructor(data?: any[] | {
                    code?: number;
                    location?: CardLocation;
                    response?: number;
                    release_param?: number;
                }) {
                    super();
                    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                    if (!Array.isArray(data) && typeof data == "object") {
                        if ("code" in data && data.code != undefined) {
                            this.code = data.code;
                        }
                        if ("location" in data && data.location != undefined) {
                            this.location = data.location;
                        }
                        if ("response" in data && data.response != undefined) {
                            this.response = data.response;
                        }
                        if ("release_param" in data && data.release_param != undefined) {
                            this.release_param = data.release_param;
                        }
                    }
                }
                get code() {
                    return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
                }
                set code(value: number) {
                    pb_1.Message.setField(this, 1, value);
                }
                get location() {
                    return pb_1.Message.getWrapperField(this, CardLocation, 2) as CardLocation;
                }
                set location(value: CardLocation) {
                    pb_1.Message.setWrapperField(this, 2, value);
                }
                get has_location() {
                    return pb_1.Message.getField(this, 2) != null;
                }
                get response() {
                    return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
                }
                set response(value: number) {
                    pb_1.Message.setField(this, 3, value);
                }
                get release_param() {
                    return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
                }
                set release_param(value: number) {
                    pb_1.Message.setField(this, 4, value);
                }
                static fromObject(data: {
                    code?: number;
                    location?: ReturnType<typeof CardLocation.prototype.toObject>;
                    response?: number;
                    release_param?: number;
                }): SelectAbleCard {
                    const message = new SelectAbleCard({});
                    if (data.code != null) {
                        message.code = data.code;
                    }
                    if (data.location != null) {
                        message.location = CardLocation.fromObject(data.location);
                    }
                    if (data.response != null) {
                        message.response = data.response;
                    }
                    if (data.release_param != null) {
                        message.release_param = data.release_param;
                    }
                    return message;
                }
                toObject() {
                    const data: {
                        code?: number;
                        location?: ReturnType<typeof CardLocation.prototype.toObject>;
                        response?: number;
                        release_param?: number;
                    } = {};
                    if (this.code != null) {
                        data.code = this.code;
                    }
                    if (this.location != null) {
                        data.location = this.location.toObject();
                    }
                    if (this.response != null) {
                        data.response = this.response;
                    }
                    if (this.release_param != null) {
                        data.release_param = this.release_param;
                    }
                    return data;
                }
                serialize(): Uint8Array;
                serialize(w: pb_1.BinaryWriter): void;
                serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                    const writer = w || new pb_1.BinaryWriter();
                    if (this.code != 0)
                        writer.writeInt32(1, this.code);
                    if (this.has_location)
                        writer.writeMessage(2, this.location, () => this.location.serialize(writer));
                    if (this.response != 0)
                        writer.writeInt32(3, this.response);
                    if (this.release_param != 0)
                        writer.writeInt32(4, this.release_param);
                    if (!w)
                        return writer.getResultBuffer();
                }
                static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SelectAbleCard {
                    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SelectAbleCard();
                    while (reader.nextField()) {
                        if (reader.isEndGroup())
                            break;
                        switch (reader.getFieldNumber()) {
                            case 1:
                                message.code = reader.readInt32();
                                break;
                            case 2:
                                reader.readMessage(message.location, () => message.location = CardLocation.deserialize(reader));
                                break;
                            case 3:
                                message.response = reader.readInt32();
                                break;
                            case 4:
                                message.release_param = reader.readInt32();
                                break;
                            default: reader.skipField();
                        }
                    }
                    return message;
                }
                serializeBinary(): Uint8Array {
                    return this.serialize();
                }
                static deserializeBinary(bytes: Uint8Array): SelectAbleCard {
                    return SelectAbleCard.deserialize(bytes);
                }
            }
        }
        export class MsgSelectChain extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                player?: number;
                special_count?: number;
                forced?: boolean;
                hint0?: number;
                hint1?: number;
                chains?: StocGameMessage.MsgSelectChain.Chain[];
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [6], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("player" in data && data.player != undefined) {
                        this.player = data.player;
                    }
                    if ("special_count" in data && data.special_count != undefined) {
                        this.special_count = data.special_count;
                    }
                    if ("forced" in data && data.forced != undefined) {
                        this.forced = data.forced;
                    }
                    if ("hint0" in data && data.hint0 != undefined) {
                        this.hint0 = data.hint0;
                    }
                    if ("hint1" in data && data.hint1 != undefined) {
                        this.hint1 = data.hint1;
                    }
                    if ("chains" in data && data.chains != undefined) {
                        this.chains = data.chains;
                    }
                }
            }
            get player() {
                return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
            }
            set player(value: number) {
                pb_1.Message.setField(this, 1, value);
            }
            get special_count() {
                return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
            }
            set special_count(value: number) {
                pb_1.Message.setField(this, 2, value);
            }
            get forced() {
                return pb_1.Message.getFieldWithDefault(this, 3, false) as boolean;
            }
            set forced(value: boolean) {
                pb_1.Message.setField(this, 3, value);
            }
            get hint0() {
                return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
            }
            set hint0(value: number) {
                pb_1.Message.setField(this, 4, value);
            }
            get hint1() {
                return pb_1.Message.getFieldWithDefault(this, 5, 0) as number;
            }
            set hint1(value: number) {
                pb_1.Message.setField(this, 5, value);
            }
            get chains() {
                return pb_1.Message.getRepeatedWrapperField(this, StocGameMessage.MsgSelectChain.Chain, 6) as StocGameMessage.MsgSelectChain.Chain[];
            }
            set chains(value: StocGameMessage.MsgSelectChain.Chain[]) {
                pb_1.Message.setRepeatedWrapperField(this, 6, value);
            }
            static fromObject(data: {
                player?: number;
                special_count?: number;
                forced?: boolean;
                hint0?: number;
                hint1?: number;
                chains?: ReturnType<typeof StocGameMessage.MsgSelectChain.Chain.prototype.toObject>[];
            }): MsgSelectChain {
                const message = new MsgSelectChain({});
                if (data.player != null) {
                    message.player = data.player;
                }
                if (data.special_count != null) {
                    message.special_count = data.special_count;
                }
                if (data.forced != null) {
                    message.forced = data.forced;
                }
                if (data.hint0 != null) {
                    message.hint0 = data.hint0;
                }
                if (data.hint1 != null) {
                    message.hint1 = data.hint1;
                }
                if (data.chains != null) {
                    message.chains = data.chains.map(item => StocGameMessage.MsgSelectChain.Chain.fromObject(item));
                }
                return message;
            }
            toObject() {
                const data: {
                    player?: number;
                    special_count?: number;
                    forced?: boolean;
                    hint0?: number;
                    hint1?: number;
                    chains?: ReturnType<typeof StocGameMessage.MsgSelectChain.Chain.prototype.toObject>[];
                } = {};
                if (this.player != null) {
                    data.player = this.player;
                }
                if (this.special_count != null) {
                    data.special_count = this.special_count;
                }
                if (this.forced != null) {
                    data.forced = this.forced;
                }
                if (this.hint0 != null) {
                    data.hint0 = this.hint0;
                }
                if (this.hint1 != null) {
                    data.hint1 = this.hint1;
                }
                if (this.chains != null) {
                    data.chains = this.chains.map((item: StocGameMessage.MsgSelectChain.Chain) => item.toObject());
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.player != 0)
                    writer.writeInt32(1, this.player);
                if (this.special_count != 0)
                    writer.writeInt32(2, this.special_count);
                if (this.forced != false)
                    writer.writeBool(3, this.forced);
                if (this.hint0 != 0)
                    writer.writeInt32(4, this.hint0);
                if (this.hint1 != 0)
                    writer.writeInt32(5, this.hint1);
                if (this.chains.length)
                    writer.writeRepeatedMessage(6, this.chains, (item: StocGameMessage.MsgSelectChain.Chain) => item.serialize(writer));
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgSelectChain {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgSelectChain();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.player = reader.readInt32();
                            break;
                        case 2:
                            message.special_count = reader.readInt32();
                            break;
                        case 3:
                            message.forced = reader.readBool();
                            break;
                        case 4:
                            message.hint0 = reader.readInt32();
                            break;
                        case 5:
                            message.hint1 = reader.readInt32();
                            break;
                        case 6:
                            reader.readMessage(message.chains, () => pb_1.Message.addToRepeatedWrapperField(message, 6, StocGameMessage.MsgSelectChain.Chain.deserialize(reader), StocGameMessage.MsgSelectChain.Chain));
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): MsgSelectChain {
                return MsgSelectChain.deserialize(bytes);
            }
        }
        export namespace MsgSelectChain {
            export enum ChainFlag {
                COMMON = 0,
                EDESC_OPERATION = 1,
                EDESC_RESET = 2
            }
            export class Chain extends pb_1.Message {
                #one_of_decls: number[][] = [];
                constructor(data?: any[] | {
                    flag?: StocGameMessage.MsgSelectChain.ChainFlag;
                    code?: number;
                    location?: CardLocation;
                    effect_description?: number;
                    response?: number;
                }) {
                    super();
                    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                    if (!Array.isArray(data) && typeof data == "object") {
                        if ("flag" in data && data.flag != undefined) {
                            this.flag = data.flag;
                        }
                        if ("code" in data && data.code != undefined) {
                            this.code = data.code;
                        }
                        if ("location" in data && data.location != undefined) {
                            this.location = data.location;
                        }
                        if ("effect_description" in data && data.effect_description != undefined) {
                            this.effect_description = data.effect_description;
                        }
                        if ("response" in data && data.response != undefined) {
                            this.response = data.response;
                        }
                    }
                }
                get flag() {
                    return pb_1.Message.getFieldWithDefault(this, 1, StocGameMessage.MsgSelectChain.ChainFlag.COMMON) as StocGameMessage.MsgSelectChain.ChainFlag;
                }
                set flag(value: StocGameMessage.MsgSelectChain.ChainFlag) {
                    pb_1.Message.setField(this, 1, value);
                }
                get code() {
                    return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
                }
                set code(value: number) {
                    pb_1.Message.setField(this, 2, value);
                }
                get location() {
                    return pb_1.Message.getWrapperField(this, CardLocation, 3) as CardLocation;
                }
                set location(value: CardLocation) {
                    pb_1.Message.setWrapperField(this, 3, value);
                }
                get has_location() {
                    return pb_1.Message.getField(this, 3) != null;
                }
                get effect_description() {
                    return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
                }
                set effect_description(value: number) {
                    pb_1.Message.setField(this, 4, value);
                }
                get response() {
                    return pb_1.Message.getFieldWithDefault(this, 5, 0) as number;
                }
                set response(value: number) {
                    pb_1.Message.setField(this, 5, value);
                }
                static fromObject(data: {
                    flag?: StocGameMessage.MsgSelectChain.ChainFlag;
                    code?: number;
                    location?: ReturnType<typeof CardLocation.prototype.toObject>;
                    effect_description?: number;
                    response?: number;
                }): Chain {
                    const message = new Chain({});
                    if (data.flag != null) {
                        message.flag = data.flag;
                    }
                    if (data.code != null) {
                        message.code = data.code;
                    }
                    if (data.location != null) {
                        message.location = CardLocation.fromObject(data.location);
                    }
                    if (data.effect_description != null) {
                        message.effect_description = data.effect_description;
                    }
                    if (data.response != null) {
                        message.response = data.response;
                    }
                    return message;
                }
                toObject() {
                    const data: {
                        flag?: StocGameMessage.MsgSelectChain.ChainFlag;
                        code?: number;
                        location?: ReturnType<typeof CardLocation.prototype.toObject>;
                        effect_description?: number;
                        response?: number;
                    } = {};
                    if (this.flag != null) {
                        data.flag = this.flag;
                    }
                    if (this.code != null) {
                        data.code = this.code;
                    }
                    if (this.location != null) {
                        data.location = this.location.toObject();
                    }
                    if (this.effect_description != null) {
                        data.effect_description = this.effect_description;
                    }
                    if (this.response != null) {
                        data.response = this.response;
                    }
                    return data;
                }
                serialize(): Uint8Array;
                serialize(w: pb_1.BinaryWriter): void;
                serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                    const writer = w || new pb_1.BinaryWriter();
                    if (this.flag != StocGameMessage.MsgSelectChain.ChainFlag.COMMON)
                        writer.writeEnum(1, this.flag);
                    if (this.code != 0)
                        writer.writeInt32(2, this.code);
                    if (this.has_location)
                        writer.writeMessage(3, this.location, () => this.location.serialize(writer));
                    if (this.effect_description != 0)
                        writer.writeInt32(4, this.effect_description);
                    if (this.response != 0)
                        writer.writeInt32(5, this.response);
                    if (!w)
                        return writer.getResultBuffer();
                }
                static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Chain {
                    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Chain();
                    while (reader.nextField()) {
                        if (reader.isEndGroup())
                            break;
                        switch (reader.getFieldNumber()) {
                            case 1:
                                message.flag = reader.readEnum();
                                break;
                            case 2:
                                message.code = reader.readInt32();
                                break;
                            case 3:
                                reader.readMessage(message.location, () => message.location = CardLocation.deserialize(reader));
                                break;
                            case 4:
                                message.effect_description = reader.readInt32();
                                break;
                            case 5:
                                message.response = reader.readInt32();
                                break;
                            default: reader.skipField();
                        }
                    }
                    return message;
                }
                serializeBinary(): Uint8Array {
                    return this.serialize();
                }
                static deserializeBinary(bytes: Uint8Array): Chain {
                    return Chain.deserialize(bytes);
                }
            }
        }
        export class MsgSelectEffectYn extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                player?: number;
                code?: number;
                location?: CardLocation;
                effect_description?: number;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("player" in data && data.player != undefined) {
                        this.player = data.player;
                    }
                    if ("code" in data && data.code != undefined) {
                        this.code = data.code;
                    }
                    if ("location" in data && data.location != undefined) {
                        this.location = data.location;
                    }
                    if ("effect_description" in data && data.effect_description != undefined) {
                        this.effect_description = data.effect_description;
                    }
                }
            }
            get player() {
                return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
            }
            set player(value: number) {
                pb_1.Message.setField(this, 1, value);
            }
            get code() {
                return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
            }
            set code(value: number) {
                pb_1.Message.setField(this, 2, value);
            }
            get location() {
                return pb_1.Message.getWrapperField(this, CardLocation, 3) as CardLocation;
            }
            set location(value: CardLocation) {
                pb_1.Message.setWrapperField(this, 3, value);
            }
            get has_location() {
                return pb_1.Message.getField(this, 3) != null;
            }
            get effect_description() {
                return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
            }
            set effect_description(value: number) {
                pb_1.Message.setField(this, 4, value);
            }
            static fromObject(data: {
                player?: number;
                code?: number;
                location?: ReturnType<typeof CardLocation.prototype.toObject>;
                effect_description?: number;
            }): MsgSelectEffectYn {
                const message = new MsgSelectEffectYn({});
                if (data.player != null) {
                    message.player = data.player;
                }
                if (data.code != null) {
                    message.code = data.code;
                }
                if (data.location != null) {
                    message.location = CardLocation.fromObject(data.location);
                }
                if (data.effect_description != null) {
                    message.effect_description = data.effect_description;
                }
                return message;
            }
            toObject() {
                const data: {
                    player?: number;
                    code?: number;
                    location?: ReturnType<typeof CardLocation.prototype.toObject>;
                    effect_description?: number;
                } = {};
                if (this.player != null) {
                    data.player = this.player;
                }
                if (this.code != null) {
                    data.code = this.code;
                }
                if (this.location != null) {
                    data.location = this.location.toObject();
                }
                if (this.effect_description != null) {
                    data.effect_description = this.effect_description;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.player != 0)
                    writer.writeInt32(1, this.player);
                if (this.code != 0)
                    writer.writeInt32(2, this.code);
                if (this.has_location)
                    writer.writeMessage(3, this.location, () => this.location.serialize(writer));
                if (this.effect_description != 0)
                    writer.writeInt32(4, this.effect_description);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgSelectEffectYn {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgSelectEffectYn();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.player = reader.readInt32();
                            break;
                        case 2:
                            message.code = reader.readInt32();
                            break;
                        case 3:
                            reader.readMessage(message.location, () => message.location = CardLocation.deserialize(reader));
                            break;
                        case 4:
                            message.effect_description = reader.readInt32();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): MsgSelectEffectYn {
                return MsgSelectEffectYn.deserialize(bytes);
            }
        }
        export class MsgSelectPosition extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                player?: number;
                code?: number;
                positions?: StocGameMessage.MsgSelectPosition.SelectAblePosition[];
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [3], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("player" in data && data.player != undefined) {
                        this.player = data.player;
                    }
                    if ("code" in data && data.code != undefined) {
                        this.code = data.code;
                    }
                    if ("positions" in data && data.positions != undefined) {
                        this.positions = data.positions;
                    }
                }
            }
            get player() {
                return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
            }
            set player(value: number) {
                pb_1.Message.setField(this, 1, value);
            }
            get code() {
                return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
            }
            set code(value: number) {
                pb_1.Message.setField(this, 2, value);
            }
            get positions() {
                return pb_1.Message.getRepeatedWrapperField(this, StocGameMessage.MsgSelectPosition.SelectAblePosition, 3) as StocGameMessage.MsgSelectPosition.SelectAblePosition[];
            }
            set positions(value: StocGameMessage.MsgSelectPosition.SelectAblePosition[]) {
                pb_1.Message.setRepeatedWrapperField(this, 3, value);
            }
            static fromObject(data: {
                player?: number;
                code?: number;
                positions?: ReturnType<typeof StocGameMessage.MsgSelectPosition.SelectAblePosition.prototype.toObject>[];
            }): MsgSelectPosition {
                const message = new MsgSelectPosition({});
                if (data.player != null) {
                    message.player = data.player;
                }
                if (data.code != null) {
                    message.code = data.code;
                }
                if (data.positions != null) {
                    message.positions = data.positions.map(item => StocGameMessage.MsgSelectPosition.SelectAblePosition.fromObject(item));
                }
                return message;
            }
            toObject() {
                const data: {
                    player?: number;
                    code?: number;
                    positions?: ReturnType<typeof StocGameMessage.MsgSelectPosition.SelectAblePosition.prototype.toObject>[];
                } = {};
                if (this.player != null) {
                    data.player = this.player;
                }
                if (this.code != null) {
                    data.code = this.code;
                }
                if (this.positions != null) {
                    data.positions = this.positions.map((item: StocGameMessage.MsgSelectPosition.SelectAblePosition) => item.toObject());
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.player != 0)
                    writer.writeInt32(1, this.player);
                if (this.code != 0)
                    writer.writeInt32(2, this.code);
                if (this.positions.length)
                    writer.writeRepeatedMessage(3, this.positions, (item: StocGameMessage.MsgSelectPosition.SelectAblePosition) => item.serialize(writer));
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgSelectPosition {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgSelectPosition();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.player = reader.readInt32();
                            break;
                        case 2:
                            message.code = reader.readInt32();
                            break;
                        case 3:
                            reader.readMessage(message.positions, () => pb_1.Message.addToRepeatedWrapperField(message, 3, StocGameMessage.MsgSelectPosition.SelectAblePosition.deserialize(reader), StocGameMessage.MsgSelectPosition.SelectAblePosition));
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): MsgSelectPosition {
                return MsgSelectPosition.deserialize(bytes);
            }
        }
        export namespace MsgSelectPosition {
            export class SelectAblePosition extends pb_1.Message {
                #one_of_decls: number[][] = [];
                constructor(data?: any[] | {
                    position?: CardPosition;
                }) {
                    super();
                    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                    if (!Array.isArray(data) && typeof data == "object") {
                        if ("position" in data && data.position != undefined) {
                            this.position = data.position;
                        }
                    }
                }
                get position() {
                    return pb_1.Message.getFieldWithDefault(this, 1, CardPosition.FACEUP_ATTACK) as CardPosition;
                }
                set position(value: CardPosition) {
                    pb_1.Message.setField(this, 1, value);
                }
                static fromObject(data: {
                    position?: CardPosition;
                }): SelectAblePosition {
                    const message = new SelectAblePosition({});
                    if (data.position != null) {
                        message.position = data.position;
                    }
                    return message;
                }
                toObject() {
                    const data: {
                        position?: CardPosition;
                    } = {};
                    if (this.position != null) {
                        data.position = this.position;
                    }
                    return data;
                }
                serialize(): Uint8Array;
                serialize(w: pb_1.BinaryWriter): void;
                serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                    const writer = w || new pb_1.BinaryWriter();
                    if (this.position != CardPosition.FACEUP_ATTACK)
                        writer.writeEnum(1, this.position);
                    if (!w)
                        return writer.getResultBuffer();
                }
                static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SelectAblePosition {
                    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SelectAblePosition();
                    while (reader.nextField()) {
                        if (reader.isEndGroup())
                            break;
                        switch (reader.getFieldNumber()) {
                            case 1:
                                message.position = reader.readEnum();
                                break;
                            default: reader.skipField();
                        }
                    }
                    return message;
                }
                serializeBinary(): Uint8Array {
                    return this.serialize();
                }
                static deserializeBinary(bytes: Uint8Array): SelectAblePosition {
                    return SelectAblePosition.deserialize(bytes);
                }
            }
        }
        export class MsgSelectOption extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                player?: number;
                options?: StocGameMessage.MsgSelectOption.Option[];
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("player" in data && data.player != undefined) {
                        this.player = data.player;
                    }
                    if ("options" in data && data.options != undefined) {
                        this.options = data.options;
                    }
                }
            }
            get player() {
                return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
            }
            set player(value: number) {
                pb_1.Message.setField(this, 1, value);
            }
            get options() {
                return pb_1.Message.getRepeatedWrapperField(this, StocGameMessage.MsgSelectOption.Option, 2) as StocGameMessage.MsgSelectOption.Option[];
            }
            set options(value: StocGameMessage.MsgSelectOption.Option[]) {
                pb_1.Message.setRepeatedWrapperField(this, 2, value);
            }
            static fromObject(data: {
                player?: number;
                options?: ReturnType<typeof StocGameMessage.MsgSelectOption.Option.prototype.toObject>[];
            }): MsgSelectOption {
                const message = new MsgSelectOption({});
                if (data.player != null) {
                    message.player = data.player;
                }
                if (data.options != null) {
                    message.options = data.options.map(item => StocGameMessage.MsgSelectOption.Option.fromObject(item));
                }
                return message;
            }
            toObject() {
                const data: {
                    player?: number;
                    options?: ReturnType<typeof StocGameMessage.MsgSelectOption.Option.prototype.toObject>[];
                } = {};
                if (this.player != null) {
                    data.player = this.player;
                }
                if (this.options != null) {
                    data.options = this.options.map((item: StocGameMessage.MsgSelectOption.Option) => item.toObject());
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.player != 0)
                    writer.writeInt32(1, this.player);
                if (this.options.length)
                    writer.writeRepeatedMessage(2, this.options, (item: StocGameMessage.MsgSelectOption.Option) => item.serialize(writer));
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgSelectOption {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgSelectOption();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.player = reader.readInt32();
                            break;
                        case 2:
                            reader.readMessage(message.options, () => pb_1.Message.addToRepeatedWrapperField(message, 2, StocGameMessage.MsgSelectOption.Option.deserialize(reader), StocGameMessage.MsgSelectOption.Option));
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): MsgSelectOption {
                return MsgSelectOption.deserialize(bytes);
            }
        }
        export namespace MsgSelectOption {
            export class Option extends pb_1.Message {
                #one_of_decls: number[][] = [];
                constructor(data?: any[] | {
                    code?: number;
                    response?: number;
                }) {
                    super();
                    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                    if (!Array.isArray(data) && typeof data == "object") {
                        if ("code" in data && data.code != undefined) {
                            this.code = data.code;
                        }
                        if ("response" in data && data.response != undefined) {
                            this.response = data.response;
                        }
                    }
                }
                get code() {
                    return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
                }
                set code(value: number) {
                    pb_1.Message.setField(this, 1, value);
                }
                get response() {
                    return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
                }
                set response(value: number) {
                    pb_1.Message.setField(this, 2, value);
                }
                static fromObject(data: {
                    code?: number;
                    response?: number;
                }): Option {
                    const message = new Option({});
                    if (data.code != null) {
                        message.code = data.code;
                    }
                    if (data.response != null) {
                        message.response = data.response;
                    }
                    return message;
                }
                toObject() {
                    const data: {
                        code?: number;
                        response?: number;
                    } = {};
                    if (this.code != null) {
                        data.code = this.code;
                    }
                    if (this.response != null) {
                        data.response = this.response;
                    }
                    return data;
                }
                serialize(): Uint8Array;
                serialize(w: pb_1.BinaryWriter): void;
                serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                    const writer = w || new pb_1.BinaryWriter();
                    if (this.code != 0)
                        writer.writeInt32(1, this.code);
                    if (this.response != 0)
                        writer.writeInt32(2, this.response);
                    if (!w)
                        return writer.getResultBuffer();
                }
                static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Option {
                    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Option();
                    while (reader.nextField()) {
                        if (reader.isEndGroup())
                            break;
                        switch (reader.getFieldNumber()) {
                            case 1:
                                message.code = reader.readInt32();
                                break;
                            case 2:
                                message.response = reader.readInt32();
                                break;
                            default: reader.skipField();
                        }
                    }
                    return message;
                }
                serializeBinary(): Uint8Array {
                    return this.serialize();
                }
                static deserializeBinary(bytes: Uint8Array): Option {
                    return Option.deserialize(bytes);
                }
            }
        }
        export class MsgShuffleHandExtra extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                player?: number;
                zone?: CardZone;
                cards?: number[];
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [3], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("player" in data && data.player != undefined) {
                        this.player = data.player;
                    }
                    if ("zone" in data && data.zone != undefined) {
                        this.zone = data.zone;
                    }
                    if ("cards" in data && data.cards != undefined) {
                        this.cards = data.cards;
                    }
                }
            }
            get player() {
                return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
            }
            set player(value: number) {
                pb_1.Message.setField(this, 1, value);
            }
            get zone() {
                return pb_1.Message.getFieldWithDefault(this, 2, CardZone.DECK) as CardZone;
            }
            set zone(value: CardZone) {
                pb_1.Message.setField(this, 2, value);
            }
            get cards() {
                return pb_1.Message.getFieldWithDefault(this, 3, []) as number[];
            }
            set cards(value: number[]) {
                pb_1.Message.setField(this, 3, value);
            }
            static fromObject(data: {
                player?: number;
                zone?: CardZone;
                cards?: number[];
            }): MsgShuffleHandExtra {
                const message = new MsgShuffleHandExtra({});
                if (data.player != null) {
                    message.player = data.player;
                }
                if (data.zone != null) {
                    message.zone = data.zone;
                }
                if (data.cards != null) {
                    message.cards = data.cards;
                }
                return message;
            }
            toObject() {
                const data: {
                    player?: number;
                    zone?: CardZone;
                    cards?: number[];
                } = {};
                if (this.player != null) {
                    data.player = this.player;
                }
                if (this.zone != null) {
                    data.zone = this.zone;
                }
                if (this.cards != null) {
                    data.cards = this.cards;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.player != 0)
                    writer.writeInt32(1, this.player);
                if (this.zone != CardZone.DECK)
                    writer.writeEnum(2, this.zone);
                if (this.cards.length)
                    writer.writePackedInt32(3, this.cards);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgShuffleHandExtra {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgShuffleHandExtra();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.player = reader.readInt32();
                            break;
                        case 2:
                            message.zone = reader.readEnum();
                            break;
                        case 3:
                            message.cards = reader.readPackedInt32();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): MsgShuffleHandExtra {
                return MsgShuffleHandExtra.deserialize(bytes);
            }
        }
        export class MsgShuffleSetCard extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                zone?: CardZone;
                from_locations?: CardLocation[];
                overlay_locations?: CardLocation[];
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2, 3], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("zone" in data && data.zone != undefined) {
                        this.zone = data.zone;
                    }
                    if ("from_locations" in data && data.from_locations != undefined) {
                        this.from_locations = data.from_locations;
                    }
                    if ("overlay_locations" in data && data.overlay_locations != undefined) {
                        this.overlay_locations = data.overlay_locations;
                    }
                }
            }
            get zone() {
                return pb_1.Message.getFieldWithDefault(this, 1, CardZone.DECK) as CardZone;
            }
            set zone(value: CardZone) {
                pb_1.Message.setField(this, 1, value);
            }
            get from_locations() {
                return pb_1.Message.getRepeatedWrapperField(this, CardLocation, 2) as CardLocation[];
            }
            set from_locations(value: CardLocation[]) {
                pb_1.Message.setRepeatedWrapperField(this, 2, value);
            }
            get overlay_locations() {
                return pb_1.Message.getRepeatedWrapperField(this, CardLocation, 3) as CardLocation[];
            }
            set overlay_locations(value: CardLocation[]) {
                pb_1.Message.setRepeatedWrapperField(this, 3, value);
            }
            static fromObject(data: {
                zone?: CardZone;
                from_locations?: ReturnType<typeof CardLocation.prototype.toObject>[];
                overlay_locations?: ReturnType<typeof CardLocation.prototype.toObject>[];
            }): MsgShuffleSetCard {
                const message = new MsgShuffleSetCard({});
                if (data.zone != null) {
                    message.zone = data.zone;
                }
                if (data.from_locations != null) {
                    message.from_locations = data.from_locations.map(item => CardLocation.fromObject(item));
                }
                if (data.overlay_locations != null) {
                    message.overlay_locations = data.overlay_locations.map(item => CardLocation.fromObject(item));
                }
                return message;
            }
            toObject() {
                const data: {
                    zone?: CardZone;
                    from_locations?: ReturnType<typeof CardLocation.prototype.toObject>[];
                    overlay_locations?: ReturnType<typeof CardLocation.prototype.toObject>[];
                } = {};
                if (this.zone != null) {
                    data.zone = this.zone;
                }
                if (this.from_locations != null) {
                    data.from_locations = this.from_locations.map((item: CardLocation) => item.toObject());
                }
                if (this.overlay_locations != null) {
                    data.overlay_locations = this.overlay_locations.map((item: CardLocation) => item.toObject());
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.zone != CardZone.DECK)
                    writer.writeEnum(1, this.zone);
                if (this.from_locations.length)
                    writer.writeRepeatedMessage(2, this.from_locations, (item: CardLocation) => item.serialize(writer));
                if (this.overlay_locations.length)
                    writer.writeRepeatedMessage(3, this.overlay_locations, (item: CardLocation) => item.serialize(writer));
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgShuffleSetCard {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgShuffleSetCard();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.zone = reader.readEnum();
                            break;
                        case 2:
                            reader.readMessage(message.from_locations, () => pb_1.Message.addToRepeatedWrapperField(message, 2, CardLocation.deserialize(reader), CardLocation));
                            break;
                        case 3:
                            reader.readMessage(message.overlay_locations, () => pb_1.Message.addToRepeatedWrapperField(message, 3, CardLocation.deserialize(reader), CardLocation));
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): MsgShuffleSetCard {
                return MsgShuffleSetCard.deserialize(bytes);
            }
        }
        export class MsgSelectBattleCmd extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                player?: number;
                battle_cmds?: StocGameMessage.MsgSelectBattleCmd.BattleCmd[];
                enable_m2?: boolean;
                enable_ep?: boolean;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("player" in data && data.player != undefined) {
                        this.player = data.player;
                    }
                    if ("battle_cmds" in data && data.battle_cmds != undefined) {
                        this.battle_cmds = data.battle_cmds;
                    }
                    if ("enable_m2" in data && data.enable_m2 != undefined) {
                        this.enable_m2 = data.enable_m2;
                    }
                    if ("enable_ep" in data && data.enable_ep != undefined) {
                        this.enable_ep = data.enable_ep;
                    }
                }
            }
            get player() {
                return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
            }
            set player(value: number) {
                pb_1.Message.setField(this, 1, value);
            }
            get battle_cmds() {
                return pb_1.Message.getRepeatedWrapperField(this, StocGameMessage.MsgSelectBattleCmd.BattleCmd, 2) as StocGameMessage.MsgSelectBattleCmd.BattleCmd[];
            }
            set battle_cmds(value: StocGameMessage.MsgSelectBattleCmd.BattleCmd[]) {
                pb_1.Message.setRepeatedWrapperField(this, 2, value);
            }
            get enable_m2() {
                return pb_1.Message.getFieldWithDefault(this, 3, false) as boolean;
            }
            set enable_m2(value: boolean) {
                pb_1.Message.setField(this, 3, value);
            }
            get enable_ep() {
                return pb_1.Message.getFieldWithDefault(this, 4, false) as boolean;
            }
            set enable_ep(value: boolean) {
                pb_1.Message.setField(this, 4, value);
            }
            static fromObject(data: {
                player?: number;
                battle_cmds?: ReturnType<typeof StocGameMessage.MsgSelectBattleCmd.BattleCmd.prototype.toObject>[];
                enable_m2?: boolean;
                enable_ep?: boolean;
            }): MsgSelectBattleCmd {
                const message = new MsgSelectBattleCmd({});
                if (data.player != null) {
                    message.player = data.player;
                }
                if (data.battle_cmds != null) {
                    message.battle_cmds = data.battle_cmds.map(item => StocGameMessage.MsgSelectBattleCmd.BattleCmd.fromObject(item));
                }
                if (data.enable_m2 != null) {
                    message.enable_m2 = data.enable_m2;
                }
                if (data.enable_ep != null) {
                    message.enable_ep = data.enable_ep;
                }
                return message;
            }
            toObject() {
                const data: {
                    player?: number;
                    battle_cmds?: ReturnType<typeof StocGameMessage.MsgSelectBattleCmd.BattleCmd.prototype.toObject>[];
                    enable_m2?: boolean;
                    enable_ep?: boolean;
                } = {};
                if (this.player != null) {
                    data.player = this.player;
                }
                if (this.battle_cmds != null) {
                    data.battle_cmds = this.battle_cmds.map((item: StocGameMessage.MsgSelectBattleCmd.BattleCmd) => item.toObject());
                }
                if (this.enable_m2 != null) {
                    data.enable_m2 = this.enable_m2;
                }
                if (this.enable_ep != null) {
                    data.enable_ep = this.enable_ep;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.player != 0)
                    writer.writeInt32(1, this.player);
                if (this.battle_cmds.length)
                    writer.writeRepeatedMessage(2, this.battle_cmds, (item: StocGameMessage.MsgSelectBattleCmd.BattleCmd) => item.serialize(writer));
                if (this.enable_m2 != false)
                    writer.writeBool(3, this.enable_m2);
                if (this.enable_ep != false)
                    writer.writeBool(4, this.enable_ep);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgSelectBattleCmd {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgSelectBattleCmd();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.player = reader.readInt32();
                            break;
                        case 2:
                            reader.readMessage(message.battle_cmds, () => pb_1.Message.addToRepeatedWrapperField(message, 2, StocGameMessage.MsgSelectBattleCmd.BattleCmd.deserialize(reader), StocGameMessage.MsgSelectBattleCmd.BattleCmd));
                            break;
                        case 3:
                            message.enable_m2 = reader.readBool();
                            break;
                        case 4:
                            message.enable_ep = reader.readBool();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): MsgSelectBattleCmd {
                return MsgSelectBattleCmd.deserialize(bytes);
            }
        }
        export namespace MsgSelectBattleCmd {
            export class BattleCmd extends pb_1.Message {
                #one_of_decls: number[][] = [];
                constructor(data?: any[] | {
                    battle_type?: StocGameMessage.MsgSelectBattleCmd.BattleCmd.BattleType;
                    battle_datas?: StocGameMessage.MsgSelectBattleCmd.BattleCmd.BattleData[];
                }) {
                    super();
                    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2], this.#one_of_decls);
                    if (!Array.isArray(data) && typeof data == "object") {
                        if ("battle_type" in data && data.battle_type != undefined) {
                            this.battle_type = data.battle_type;
                        }
                        if ("battle_datas" in data && data.battle_datas != undefined) {
                            this.battle_datas = data.battle_datas;
                        }
                    }
                }
                get battle_type() {
                    return pb_1.Message.getFieldWithDefault(this, 1, StocGameMessage.MsgSelectBattleCmd.BattleCmd.BattleType.UNKNOWN) as StocGameMessage.MsgSelectBattleCmd.BattleCmd.BattleType;
                }
                set battle_type(value: StocGameMessage.MsgSelectBattleCmd.BattleCmd.BattleType) {
                    pb_1.Message.setField(this, 1, value);
                }
                get battle_datas() {
                    return pb_1.Message.getRepeatedWrapperField(this, StocGameMessage.MsgSelectBattleCmd.BattleCmd.BattleData, 2) as StocGameMessage.MsgSelectBattleCmd.BattleCmd.BattleData[];
                }
                set battle_datas(value: StocGameMessage.MsgSelectBattleCmd.BattleCmd.BattleData[]) {
                    pb_1.Message.setRepeatedWrapperField(this, 2, value);
                }
                static fromObject(data: {
                    battle_type?: StocGameMessage.MsgSelectBattleCmd.BattleCmd.BattleType;
                    battle_datas?: ReturnType<typeof StocGameMessage.MsgSelectBattleCmd.BattleCmd.BattleData.prototype.toObject>[];
                }): BattleCmd {
                    const message = new BattleCmd({});
                    if (data.battle_type != null) {
                        message.battle_type = data.battle_type;
                    }
                    if (data.battle_datas != null) {
                        message.battle_datas = data.battle_datas.map(item => StocGameMessage.MsgSelectBattleCmd.BattleCmd.BattleData.fromObject(item));
                    }
                    return message;
                }
                toObject() {
                    const data: {
                        battle_type?: StocGameMessage.MsgSelectBattleCmd.BattleCmd.BattleType;
                        battle_datas?: ReturnType<typeof StocGameMessage.MsgSelectBattleCmd.BattleCmd.BattleData.prototype.toObject>[];
                    } = {};
                    if (this.battle_type != null) {
                        data.battle_type = this.battle_type;
                    }
                    if (this.battle_datas != null) {
                        data.battle_datas = this.battle_datas.map((item: StocGameMessage.MsgSelectBattleCmd.BattleCmd.BattleData) => item.toObject());
                    }
                    return data;
                }
                serialize(): Uint8Array;
                serialize(w: pb_1.BinaryWriter): void;
                serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                    const writer = w || new pb_1.BinaryWriter();
                    if (this.battle_type != StocGameMessage.MsgSelectBattleCmd.BattleCmd.BattleType.UNKNOWN)
                        writer.writeEnum(1, this.battle_type);
                    if (this.battle_datas.length)
                        writer.writeRepeatedMessage(2, this.battle_datas, (item: StocGameMessage.MsgSelectBattleCmd.BattleCmd.BattleData) => item.serialize(writer));
                    if (!w)
                        return writer.getResultBuffer();
                }
                static deserialize(bytes: Uint8Array | pb_1.BinaryReader): BattleCmd {
                    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new BattleCmd();
                    while (reader.nextField()) {
                        if (reader.isEndGroup())
                            break;
                        switch (reader.getFieldNumber()) {
                            case 1:
                                message.battle_type = reader.readEnum();
                                break;
                            case 2:
                                reader.readMessage(message.battle_datas, () => pb_1.Message.addToRepeatedWrapperField(message, 2, StocGameMessage.MsgSelectBattleCmd.BattleCmd.BattleData.deserialize(reader), StocGameMessage.MsgSelectBattleCmd.BattleCmd.BattleData));
                                break;
                            default: reader.skipField();
                        }
                    }
                    return message;
                }
                serializeBinary(): Uint8Array {
                    return this.serialize();
                }
                static deserializeBinary(bytes: Uint8Array): BattleCmd {
                    return BattleCmd.deserialize(bytes);
                }
            }
            export namespace BattleCmd {
                export enum BattleType {
                    UNKNOWN = 0,
                    ACTIVATE = 1,
                    ATTACK = 2
                }
                export class BattleData extends pb_1.Message {
                    #one_of_decls: number[][] = [];
                    constructor(data?: any[] | {
                        card_info?: CardInfo;
                        effect_description?: number;
                        direct_attackable?: boolean;
                        response?: number;
                    }) {
                        super();
                        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                        if (!Array.isArray(data) && typeof data == "object") {
                            if ("card_info" in data && data.card_info != undefined) {
                                this.card_info = data.card_info;
                            }
                            if ("effect_description" in data && data.effect_description != undefined) {
                                this.effect_description = data.effect_description;
                            }
                            if ("direct_attackable" in data && data.direct_attackable != undefined) {
                                this.direct_attackable = data.direct_attackable;
                            }
                            if ("response" in data && data.response != undefined) {
                                this.response = data.response;
                            }
                        }
                    }
                    get card_info() {
                        return pb_1.Message.getWrapperField(this, CardInfo, 1) as CardInfo;
                    }
                    set card_info(value: CardInfo) {
                        pb_1.Message.setWrapperField(this, 1, value);
                    }
                    get has_card_info() {
                        return pb_1.Message.getField(this, 1) != null;
                    }
                    get effect_description() {
                        return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
                    }
                    set effect_description(value: number) {
                        pb_1.Message.setField(this, 2, value);
                    }
                    get direct_attackable() {
                        return pb_1.Message.getFieldWithDefault(this, 3, false) as boolean;
                    }
                    set direct_attackable(value: boolean) {
                        pb_1.Message.setField(this, 3, value);
                    }
                    get response() {
                        return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
                    }
                    set response(value: number) {
                        pb_1.Message.setField(this, 4, value);
                    }
                    static fromObject(data: {
                        card_info?: ReturnType<typeof CardInfo.prototype.toObject>;
                        effect_description?: number;
                        direct_attackable?: boolean;
                        response?: number;
                    }): BattleData {
                        const message = new BattleData({});
                        if (data.card_info != null) {
                            message.card_info = CardInfo.fromObject(data.card_info);
                        }
                        if (data.effect_description != null) {
                            message.effect_description = data.effect_description;
                        }
                        if (data.direct_attackable != null) {
                            message.direct_attackable = data.direct_attackable;
                        }
                        if (data.response != null) {
                            message.response = data.response;
                        }
                        return message;
                    }
                    toObject() {
                        const data: {
                            card_info?: ReturnType<typeof CardInfo.prototype.toObject>;
                            effect_description?: number;
                            direct_attackable?: boolean;
                            response?: number;
                        } = {};
                        if (this.card_info != null) {
                            data.card_info = this.card_info.toObject();
                        }
                        if (this.effect_description != null) {
                            data.effect_description = this.effect_description;
                        }
                        if (this.direct_attackable != null) {
                            data.direct_attackable = this.direct_attackable;
                        }
                        if (this.response != null) {
                            data.response = this.response;
                        }
                        return data;
                    }
                    serialize(): Uint8Array;
                    serialize(w: pb_1.BinaryWriter): void;
                    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                        const writer = w || new pb_1.BinaryWriter();
                        if (this.has_card_info)
                            writer.writeMessage(1, this.card_info, () => this.card_info.serialize(writer));
                        if (this.effect_description != 0)
                            writer.writeInt32(2, this.effect_description);
                        if (this.direct_attackable != false)
                            writer.writeBool(3, this.direct_attackable);
                        if (this.response != 0)
                            writer.writeInt32(4, this.response);
                        if (!w)
                            return writer.getResultBuffer();
                    }
                    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): BattleData {
                        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new BattleData();
                        while (reader.nextField()) {
                            if (reader.isEndGroup())
                                break;
                            switch (reader.getFieldNumber()) {
                                case 1:
                                    reader.readMessage(message.card_info, () => message.card_info = CardInfo.deserialize(reader));
                                    break;
                                case 2:
                                    message.effect_description = reader.readInt32();
                                    break;
                                case 3:
                                    message.direct_attackable = reader.readBool();
                                    break;
                                case 4:
                                    message.response = reader.readInt32();
                                    break;
                                default: reader.skipField();
                            }
                        }
                        return message;
                    }
                    serializeBinary(): Uint8Array {
                        return this.serialize();
                    }
                    static deserializeBinary(bytes: Uint8Array): BattleData {
                        return BattleData.deserialize(bytes);
                    }
                }
            }
        }
        export class MsgPosChange extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                card_info?: CardInfo;
                pre_position?: CardPosition;
                cur_position?: CardPosition;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("card_info" in data && data.card_info != undefined) {
                        this.card_info = data.card_info;
                    }
                    if ("pre_position" in data && data.pre_position != undefined) {
                        this.pre_position = data.pre_position;
                    }
                    if ("cur_position" in data && data.cur_position != undefined) {
                        this.cur_position = data.cur_position;
                    }
                }
            }
            get card_info() {
                return pb_1.Message.getWrapperField(this, CardInfo, 1) as CardInfo;
            }
            set card_info(value: CardInfo) {
                pb_1.Message.setWrapperField(this, 1, value);
            }
            get has_card_info() {
                return pb_1.Message.getField(this, 1) != null;
            }
            get pre_position() {
                return pb_1.Message.getFieldWithDefault(this, 2, CardPosition.FACEUP_ATTACK) as CardPosition;
            }
            set pre_position(value: CardPosition) {
                pb_1.Message.setField(this, 2, value);
            }
            get cur_position() {
                return pb_1.Message.getFieldWithDefault(this, 3, CardPosition.FACEUP_ATTACK) as CardPosition;
            }
            set cur_position(value: CardPosition) {
                pb_1.Message.setField(this, 3, value);
            }
            static fromObject(data: {
                card_info?: ReturnType<typeof CardInfo.prototype.toObject>;
                pre_position?: CardPosition;
                cur_position?: CardPosition;
            }): MsgPosChange {
                const message = new MsgPosChange({});
                if (data.card_info != null) {
                    message.card_info = CardInfo.fromObject(data.card_info);
                }
                if (data.pre_position != null) {
                    message.pre_position = data.pre_position;
                }
                if (data.cur_position != null) {
                    message.cur_position = data.cur_position;
                }
                return message;
            }
            toObject() {
                const data: {
                    card_info?: ReturnType<typeof CardInfo.prototype.toObject>;
                    pre_position?: CardPosition;
                    cur_position?: CardPosition;
                } = {};
                if (this.card_info != null) {
                    data.card_info = this.card_info.toObject();
                }
                if (this.pre_position != null) {
                    data.pre_position = this.pre_position;
                }
                if (this.cur_position != null) {
                    data.cur_position = this.cur_position;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.has_card_info)
                    writer.writeMessage(1, this.card_info, () => this.card_info.serialize(writer));
                if (this.pre_position != CardPosition.FACEUP_ATTACK)
                    writer.writeEnum(2, this.pre_position);
                if (this.cur_position != CardPosition.FACEUP_ATTACK)
                    writer.writeEnum(3, this.cur_position);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgPosChange {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgPosChange();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            reader.readMessage(message.card_info, () => message.card_info = CardInfo.deserialize(reader));
                            break;
                        case 2:
                            message.pre_position = reader.readEnum();
                            break;
                        case 3:
                            message.cur_position = reader.readEnum();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): MsgPosChange {
                return MsgPosChange.deserialize(bytes);
            }
        }
        export class MsgSelectUnselectCard extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                player?: number;
                finishable?: boolean;
                cancelable?: boolean;
                min?: number;
                max?: number;
                selectable_cards?: StocGameMessage.MsgSelectUnselectCard.Info[];
                selected_cards?: StocGameMessage.MsgSelectUnselectCard.Info[];
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [6, 7], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("player" in data && data.player != undefined) {
                        this.player = data.player;
                    }
                    if ("finishable" in data && data.finishable != undefined) {
                        this.finishable = data.finishable;
                    }
                    if ("cancelable" in data && data.cancelable != undefined) {
                        this.cancelable = data.cancelable;
                    }
                    if ("min" in data && data.min != undefined) {
                        this.min = data.min;
                    }
                    if ("max" in data && data.max != undefined) {
                        this.max = data.max;
                    }
                    if ("selectable_cards" in data && data.selectable_cards != undefined) {
                        this.selectable_cards = data.selectable_cards;
                    }
                    if ("selected_cards" in data && data.selected_cards != undefined) {
                        this.selected_cards = data.selected_cards;
                    }
                }
            }
            get player() {
                return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
            }
            set player(value: number) {
                pb_1.Message.setField(this, 1, value);
            }
            get finishable() {
                return pb_1.Message.getFieldWithDefault(this, 2, false) as boolean;
            }
            set finishable(value: boolean) {
                pb_1.Message.setField(this, 2, value);
            }
            get cancelable() {
                return pb_1.Message.getFieldWithDefault(this, 3, false) as boolean;
            }
            set cancelable(value: boolean) {
                pb_1.Message.setField(this, 3, value);
            }
            get min() {
                return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
            }
            set min(value: number) {
                pb_1.Message.setField(this, 4, value);
            }
            get max() {
                return pb_1.Message.getFieldWithDefault(this, 5, 0) as number;
            }
            set max(value: number) {
                pb_1.Message.setField(this, 5, value);
            }
            get selectable_cards() {
                return pb_1.Message.getRepeatedWrapperField(this, StocGameMessage.MsgSelectUnselectCard.Info, 6) as StocGameMessage.MsgSelectUnselectCard.Info[];
            }
            set selectable_cards(value: StocGameMessage.MsgSelectUnselectCard.Info[]) {
                pb_1.Message.setRepeatedWrapperField(this, 6, value);
            }
            get selected_cards() {
                return pb_1.Message.getRepeatedWrapperField(this, StocGameMessage.MsgSelectUnselectCard.Info, 7) as StocGameMessage.MsgSelectUnselectCard.Info[];
            }
            set selected_cards(value: StocGameMessage.MsgSelectUnselectCard.Info[]) {
                pb_1.Message.setRepeatedWrapperField(this, 7, value);
            }
            static fromObject(data: {
                player?: number;
                finishable?: boolean;
                cancelable?: boolean;
                min?: number;
                max?: number;
                selectable_cards?: ReturnType<typeof StocGameMessage.MsgSelectUnselectCard.Info.prototype.toObject>[];
                selected_cards?: ReturnType<typeof StocGameMessage.MsgSelectUnselectCard.Info.prototype.toObject>[];
            }): MsgSelectUnselectCard {
                const message = new MsgSelectUnselectCard({});
                if (data.player != null) {
                    message.player = data.player;
                }
                if (data.finishable != null) {
                    message.finishable = data.finishable;
                }
                if (data.cancelable != null) {
                    message.cancelable = data.cancelable;
                }
                if (data.min != null) {
                    message.min = data.min;
                }
                if (data.max != null) {
                    message.max = data.max;
                }
                if (data.selectable_cards != null) {
                    message.selectable_cards = data.selectable_cards.map(item => StocGameMessage.MsgSelectUnselectCard.Info.fromObject(item));
                }
                if (data.selected_cards != null) {
                    message.selected_cards = data.selected_cards.map(item => StocGameMessage.MsgSelectUnselectCard.Info.fromObject(item));
                }
                return message;
            }
            toObject() {
                const data: {
                    player?: number;
                    finishable?: boolean;
                    cancelable?: boolean;
                    min?: number;
                    max?: number;
                    selectable_cards?: ReturnType<typeof StocGameMessage.MsgSelectUnselectCard.Info.prototype.toObject>[];
                    selected_cards?: ReturnType<typeof StocGameMessage.MsgSelectUnselectCard.Info.prototype.toObject>[];
                } = {};
                if (this.player != null) {
                    data.player = this.player;
                }
                if (this.finishable != null) {
                    data.finishable = this.finishable;
                }
                if (this.cancelable != null) {
                    data.cancelable = this.cancelable;
                }
                if (this.min != null) {
                    data.min = this.min;
                }
                if (this.max != null) {
                    data.max = this.max;
                }
                if (this.selectable_cards != null) {
                    data.selectable_cards = this.selectable_cards.map((item: StocGameMessage.MsgSelectUnselectCard.Info) => item.toObject());
                }
                if (this.selected_cards != null) {
                    data.selected_cards = this.selected_cards.map((item: StocGameMessage.MsgSelectUnselectCard.Info) => item.toObject());
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.player != 0)
                    writer.writeInt32(1, this.player);
                if (this.finishable != false)
                    writer.writeBool(2, this.finishable);
                if (this.cancelable != false)
                    writer.writeBool(3, this.cancelable);
                if (this.min != 0)
                    writer.writeInt32(4, this.min);
                if (this.max != 0)
                    writer.writeInt32(5, this.max);
                if (this.selectable_cards.length)
                    writer.writeRepeatedMessage(6, this.selectable_cards, (item: StocGameMessage.MsgSelectUnselectCard.Info) => item.serialize(writer));
                if (this.selected_cards.length)
                    writer.writeRepeatedMessage(7, this.selected_cards, (item: StocGameMessage.MsgSelectUnselectCard.Info) => item.serialize(writer));
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgSelectUnselectCard {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgSelectUnselectCard();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.player = reader.readInt32();
                            break;
                        case 2:
                            message.finishable = reader.readBool();
                            break;
                        case 3:
                            message.cancelable = reader.readBool();
                            break;
                        case 4:
                            message.min = reader.readInt32();
                            break;
                        case 5:
                            message.max = reader.readInt32();
                            break;
                        case 6:
                            reader.readMessage(message.selectable_cards, () => pb_1.Message.addToRepeatedWrapperField(message, 6, StocGameMessage.MsgSelectUnselectCard.Info.deserialize(reader), StocGameMessage.MsgSelectUnselectCard.Info));
                            break;
                        case 7:
                            reader.readMessage(message.selected_cards, () => pb_1.Message.addToRepeatedWrapperField(message, 7, StocGameMessage.MsgSelectUnselectCard.Info.deserialize(reader), StocGameMessage.MsgSelectUnselectCard.Info));
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): MsgSelectUnselectCard {
                return MsgSelectUnselectCard.deserialize(bytes);
            }
        }
        export namespace MsgSelectUnselectCard {
            export class Info extends pb_1.Message {
                #one_of_decls: number[][] = [];
                constructor(data?: any[] | {
                    code?: number;
                    location?: CardLocation;
                    response?: number;
                }) {
                    super();
                    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                    if (!Array.isArray(data) && typeof data == "object") {
                        if ("code" in data && data.code != undefined) {
                            this.code = data.code;
                        }
                        if ("location" in data && data.location != undefined) {
                            this.location = data.location;
                        }
                        if ("response" in data && data.response != undefined) {
                            this.response = data.response;
                        }
                    }
                }
                get code() {
                    return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
                }
                set code(value: number) {
                    pb_1.Message.setField(this, 1, value);
                }
                get location() {
                    return pb_1.Message.getWrapperField(this, CardLocation, 2) as CardLocation;
                }
                set location(value: CardLocation) {
                    pb_1.Message.setWrapperField(this, 2, value);
                }
                get has_location() {
                    return pb_1.Message.getField(this, 2) != null;
                }
                get response() {
                    return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
                }
                set response(value: number) {
                    pb_1.Message.setField(this, 3, value);
                }
                static fromObject(data: {
                    code?: number;
                    location?: ReturnType<typeof CardLocation.prototype.toObject>;
                    response?: number;
                }): Info {
                    const message = new Info({});
                    if (data.code != null) {
                        message.code = data.code;
                    }
                    if (data.location != null) {
                        message.location = CardLocation.fromObject(data.location);
                    }
                    if (data.response != null) {
                        message.response = data.response;
                    }
                    return message;
                }
                toObject() {
                    const data: {
                        code?: number;
                        location?: ReturnType<typeof CardLocation.prototype.toObject>;
                        response?: number;
                    } = {};
                    if (this.code != null) {
                        data.code = this.code;
                    }
                    if (this.location != null) {
                        data.location = this.location.toObject();
                    }
                    if (this.response != null) {
                        data.response = this.response;
                    }
                    return data;
                }
                serialize(): Uint8Array;
                serialize(w: pb_1.BinaryWriter): void;
                serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                    const writer = w || new pb_1.BinaryWriter();
                    if (this.code != 0)
                        writer.writeInt32(1, this.code);
                    if (this.has_location)
                        writer.writeMessage(2, this.location, () => this.location.serialize(writer));
                    if (this.response != 0)
                        writer.writeInt32(3, this.response);
                    if (!w)
                        return writer.getResultBuffer();
                }
                static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Info {
                    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Info();
                    while (reader.nextField()) {
                        if (reader.isEndGroup())
                            break;
                        switch (reader.getFieldNumber()) {
                            case 1:
                                message.code = reader.readInt32();
                                break;
                            case 2:
                                reader.readMessage(message.location, () => message.location = CardLocation.deserialize(reader));
                                break;
                            case 3:
                                message.response = reader.readInt32();
                                break;
                            default: reader.skipField();
                        }
                    }
                    return message;
                }
                serializeBinary(): Uint8Array {
                    return this.serialize();
                }
                static deserializeBinary(bytes: Uint8Array): Info {
                    return Info.deserialize(bytes);
                }
            }
        }
        export class MsgSelectTribute extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                player?: number;
                cancelable?: boolean;
                min?: number;
                max?: number;
                selectable_cards?: StocGameMessage.MsgSelectTribute.Info[];
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [5], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("player" in data && data.player != undefined) {
                        this.player = data.player;
                    }
                    if ("cancelable" in data && data.cancelable != undefined) {
                        this.cancelable = data.cancelable;
                    }
                    if ("min" in data && data.min != undefined) {
                        this.min = data.min;
                    }
                    if ("max" in data && data.max != undefined) {
                        this.max = data.max;
                    }
                    if ("selectable_cards" in data && data.selectable_cards != undefined) {
                        this.selectable_cards = data.selectable_cards;
                    }
                }
            }
            get player() {
                return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
            }
            set player(value: number) {
                pb_1.Message.setField(this, 1, value);
            }
            get cancelable() {
                return pb_1.Message.getFieldWithDefault(this, 2, false) as boolean;
            }
            set cancelable(value: boolean) {
                pb_1.Message.setField(this, 2, value);
            }
            get min() {
                return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
            }
            set min(value: number) {
                pb_1.Message.setField(this, 3, value);
            }
            get max() {
                return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
            }
            set max(value: number) {
                pb_1.Message.setField(this, 4, value);
            }
            get selectable_cards() {
                return pb_1.Message.getRepeatedWrapperField(this, StocGameMessage.MsgSelectTribute.Info, 5) as StocGameMessage.MsgSelectTribute.Info[];
            }
            set selectable_cards(value: StocGameMessage.MsgSelectTribute.Info[]) {
                pb_1.Message.setRepeatedWrapperField(this, 5, value);
            }
            static fromObject(data: {
                player?: number;
                cancelable?: boolean;
                min?: number;
                max?: number;
                selectable_cards?: ReturnType<typeof StocGameMessage.MsgSelectTribute.Info.prototype.toObject>[];
            }): MsgSelectTribute {
                const message = new MsgSelectTribute({});
                if (data.player != null) {
                    message.player = data.player;
                }
                if (data.cancelable != null) {
                    message.cancelable = data.cancelable;
                }
                if (data.min != null) {
                    message.min = data.min;
                }
                if (data.max != null) {
                    message.max = data.max;
                }
                if (data.selectable_cards != null) {
                    message.selectable_cards = data.selectable_cards.map(item => StocGameMessage.MsgSelectTribute.Info.fromObject(item));
                }
                return message;
            }
            toObject() {
                const data: {
                    player?: number;
                    cancelable?: boolean;
                    min?: number;
                    max?: number;
                    selectable_cards?: ReturnType<typeof StocGameMessage.MsgSelectTribute.Info.prototype.toObject>[];
                } = {};
                if (this.player != null) {
                    data.player = this.player;
                }
                if (this.cancelable != null) {
                    data.cancelable = this.cancelable;
                }
                if (this.min != null) {
                    data.min = this.min;
                }
                if (this.max != null) {
                    data.max = this.max;
                }
                if (this.selectable_cards != null) {
                    data.selectable_cards = this.selectable_cards.map((item: StocGameMessage.MsgSelectTribute.Info) => item.toObject());
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.player != 0)
                    writer.writeInt32(1, this.player);
                if (this.cancelable != false)
                    writer.writeBool(2, this.cancelable);
                if (this.min != 0)
                    writer.writeInt32(3, this.min);
                if (this.max != 0)
                    writer.writeInt32(4, this.max);
                if (this.selectable_cards.length)
                    writer.writeRepeatedMessage(5, this.selectable_cards, (item: StocGameMessage.MsgSelectTribute.Info) => item.serialize(writer));
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgSelectTribute {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgSelectTribute();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.player = reader.readInt32();
                            break;
                        case 2:
                            message.cancelable = reader.readBool();
                            break;
                        case 3:
                            message.min = reader.readInt32();
                            break;
                        case 4:
                            message.max = reader.readInt32();
                            break;
                        case 5:
                            reader.readMessage(message.selectable_cards, () => pb_1.Message.addToRepeatedWrapperField(message, 5, StocGameMessage.MsgSelectTribute.Info.deserialize(reader), StocGameMessage.MsgSelectTribute.Info));
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): MsgSelectTribute {
                return MsgSelectTribute.deserialize(bytes);
            }
        }
        export namespace MsgSelectTribute {
            export class Info extends pb_1.Message {
                #one_of_decls: number[][] = [];
                constructor(data?: any[] | {
                    code?: number;
                    location?: CardLocation;
                    level?: number;
                    response?: number;
                }) {
                    super();
                    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                    if (!Array.isArray(data) && typeof data == "object") {
                        if ("code" in data && data.code != undefined) {
                            this.code = data.code;
                        }
                        if ("location" in data && data.location != undefined) {
                            this.location = data.location;
                        }
                        if ("level" in data && data.level != undefined) {
                            this.level = data.level;
                        }
                        if ("response" in data && data.response != undefined) {
                            this.response = data.response;
                        }
                    }
                }
                get code() {
                    return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
                }
                set code(value: number) {
                    pb_1.Message.setField(this, 1, value);
                }
                get location() {
                    return pb_1.Message.getWrapperField(this, CardLocation, 2) as CardLocation;
                }
                set location(value: CardLocation) {
                    pb_1.Message.setWrapperField(this, 2, value);
                }
                get has_location() {
                    return pb_1.Message.getField(this, 2) != null;
                }
                get level() {
                    return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
                }
                set level(value: number) {
                    pb_1.Message.setField(this, 3, value);
                }
                get response() {
                    return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
                }
                set response(value: number) {
                    pb_1.Message.setField(this, 4, value);
                }
                static fromObject(data: {
                    code?: number;
                    location?: ReturnType<typeof CardLocation.prototype.toObject>;
                    level?: number;
                    response?: number;
                }): Info {
                    const message = new Info({});
                    if (data.code != null) {
                        message.code = data.code;
                    }
                    if (data.location != null) {
                        message.location = CardLocation.fromObject(data.location);
                    }
                    if (data.level != null) {
                        message.level = data.level;
                    }
                    if (data.response != null) {
                        message.response = data.response;
                    }
                    return message;
                }
                toObject() {
                    const data: {
                        code?: number;
                        location?: ReturnType<typeof CardLocation.prototype.toObject>;
                        level?: number;
                        response?: number;
                    } = {};
                    if (this.code != null) {
                        data.code = this.code;
                    }
                    if (this.location != null) {
                        data.location = this.location.toObject();
                    }
                    if (this.level != null) {
                        data.level = this.level;
                    }
                    if (this.response != null) {
                        data.response = this.response;
                    }
                    return data;
                }
                serialize(): Uint8Array;
                serialize(w: pb_1.BinaryWriter): void;
                serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                    const writer = w || new pb_1.BinaryWriter();
                    if (this.code != 0)
                        writer.writeInt32(1, this.code);
                    if (this.has_location)
                        writer.writeMessage(2, this.location, () => this.location.serialize(writer));
                    if (this.level != 0)
                        writer.writeInt32(3, this.level);
                    if (this.response != 0)
                        writer.writeInt32(4, this.response);
                    if (!w)
                        return writer.getResultBuffer();
                }
                static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Info {
                    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Info();
                    while (reader.nextField()) {
                        if (reader.isEndGroup())
                            break;
                        switch (reader.getFieldNumber()) {
                            case 1:
                                message.code = reader.readInt32();
                                break;
                            case 2:
                                reader.readMessage(message.location, () => message.location = CardLocation.deserialize(reader));
                                break;
                            case 3:
                                message.level = reader.readInt32();
                                break;
                            case 4:
                                message.response = reader.readInt32();
                                break;
                            default: reader.skipField();
                        }
                    }
                    return message;
                }
                serializeBinary(): Uint8Array {
                    return this.serialize();
                }
                static deserializeBinary(bytes: Uint8Array): Info {
                    return Info.deserialize(bytes);
                }
            }
        }
        export class MsgSelectSum extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                overflow?: number;
                player?: number;
                level_sum?: number;
                min?: number;
                max?: number;
                must_select_cards?: StocGameMessage.MsgSelectSum.Info[];
                selectable_cards?: StocGameMessage.MsgSelectSum.Info[];
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [6, 7], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("overflow" in data && data.overflow != undefined) {
                        this.overflow = data.overflow;
                    }
                    if ("player" in data && data.player != undefined) {
                        this.player = data.player;
                    }
                    if ("level_sum" in data && data.level_sum != undefined) {
                        this.level_sum = data.level_sum;
                    }
                    if ("min" in data && data.min != undefined) {
                        this.min = data.min;
                    }
                    if ("max" in data && data.max != undefined) {
                        this.max = data.max;
                    }
                    if ("must_select_cards" in data && data.must_select_cards != undefined) {
                        this.must_select_cards = data.must_select_cards;
                    }
                    if ("selectable_cards" in data && data.selectable_cards != undefined) {
                        this.selectable_cards = data.selectable_cards;
                    }
                }
            }
            get overflow() {
                return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
            }
            set overflow(value: number) {
                pb_1.Message.setField(this, 1, value);
            }
            get player() {
                return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
            }
            set player(value: number) {
                pb_1.Message.setField(this, 2, value);
            }
            get level_sum() {
                return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
            }
            set level_sum(value: number) {
                pb_1.Message.setField(this, 3, value);
            }
            get min() {
                return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
            }
            set min(value: number) {
                pb_1.Message.setField(this, 4, value);
            }
            get max() {
                return pb_1.Message.getFieldWithDefault(this, 5, 0) as number;
            }
            set max(value: number) {
                pb_1.Message.setField(this, 5, value);
            }
            get must_select_cards() {
                return pb_1.Message.getRepeatedWrapperField(this, StocGameMessage.MsgSelectSum.Info, 6) as StocGameMessage.MsgSelectSum.Info[];
            }
            set must_select_cards(value: StocGameMessage.MsgSelectSum.Info[]) {
                pb_1.Message.setRepeatedWrapperField(this, 6, value);
            }
            get selectable_cards() {
                return pb_1.Message.getRepeatedWrapperField(this, StocGameMessage.MsgSelectSum.Info, 7) as StocGameMessage.MsgSelectSum.Info[];
            }
            set selectable_cards(value: StocGameMessage.MsgSelectSum.Info[]) {
                pb_1.Message.setRepeatedWrapperField(this, 7, value);
            }
            static fromObject(data: {
                overflow?: number;
                player?: number;
                level_sum?: number;
                min?: number;
                max?: number;
                must_select_cards?: ReturnType<typeof StocGameMessage.MsgSelectSum.Info.prototype.toObject>[];
                selectable_cards?: ReturnType<typeof StocGameMessage.MsgSelectSum.Info.prototype.toObject>[];
            }): MsgSelectSum {
                const message = new MsgSelectSum({});
                if (data.overflow != null) {
                    message.overflow = data.overflow;
                }
                if (data.player != null) {
                    message.player = data.player;
                }
                if (data.level_sum != null) {
                    message.level_sum = data.level_sum;
                }
                if (data.min != null) {
                    message.min = data.min;
                }
                if (data.max != null) {
                    message.max = data.max;
                }
                if (data.must_select_cards != null) {
                    message.must_select_cards = data.must_select_cards.map(item => StocGameMessage.MsgSelectSum.Info.fromObject(item));
                }
                if (data.selectable_cards != null) {
                    message.selectable_cards = data.selectable_cards.map(item => StocGameMessage.MsgSelectSum.Info.fromObject(item));
                }
                return message;
            }
            toObject() {
                const data: {
                    overflow?: number;
                    player?: number;
                    level_sum?: number;
                    min?: number;
                    max?: number;
                    must_select_cards?: ReturnType<typeof StocGameMessage.MsgSelectSum.Info.prototype.toObject>[];
                    selectable_cards?: ReturnType<typeof StocGameMessage.MsgSelectSum.Info.prototype.toObject>[];
                } = {};
                if (this.overflow != null) {
                    data.overflow = this.overflow;
                }
                if (this.player != null) {
                    data.player = this.player;
                }
                if (this.level_sum != null) {
                    data.level_sum = this.level_sum;
                }
                if (this.min != null) {
                    data.min = this.min;
                }
                if (this.max != null) {
                    data.max = this.max;
                }
                if (this.must_select_cards != null) {
                    data.must_select_cards = this.must_select_cards.map((item: StocGameMessage.MsgSelectSum.Info) => item.toObject());
                }
                if (this.selectable_cards != null) {
                    data.selectable_cards = this.selectable_cards.map((item: StocGameMessage.MsgSelectSum.Info) => item.toObject());
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.overflow != 0)
                    writer.writeInt32(1, this.overflow);
                if (this.player != 0)
                    writer.writeInt32(2, this.player);
                if (this.level_sum != 0)
                    writer.writeInt32(3, this.level_sum);
                if (this.min != 0)
                    writer.writeInt32(4, this.min);
                if (this.max != 0)
                    writer.writeInt32(5, this.max);
                if (this.must_select_cards.length)
                    writer.writeRepeatedMessage(6, this.must_select_cards, (item: StocGameMessage.MsgSelectSum.Info) => item.serialize(writer));
                if (this.selectable_cards.length)
                    writer.writeRepeatedMessage(7, this.selectable_cards, (item: StocGameMessage.MsgSelectSum.Info) => item.serialize(writer));
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgSelectSum {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgSelectSum();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.overflow = reader.readInt32();
                            break;
                        case 2:
                            message.player = reader.readInt32();
                            break;
                        case 3:
                            message.level_sum = reader.readInt32();
                            break;
                        case 4:
                            message.min = reader.readInt32();
                            break;
                        case 5:
                            message.max = reader.readInt32();
                            break;
                        case 6:
                            reader.readMessage(message.must_select_cards, () => pb_1.Message.addToRepeatedWrapperField(message, 6, StocGameMessage.MsgSelectSum.Info.deserialize(reader), StocGameMessage.MsgSelectSum.Info));
                            break;
                        case 7:
                            reader.readMessage(message.selectable_cards, () => pb_1.Message.addToRepeatedWrapperField(message, 7, StocGameMessage.MsgSelectSum.Info.deserialize(reader), StocGameMessage.MsgSelectSum.Info));
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): MsgSelectSum {
                return MsgSelectSum.deserialize(bytes);
            }
        }
        export namespace MsgSelectSum {
            export class Info extends pb_1.Message {
                #one_of_decls: number[][] = [];
                constructor(data?: any[] | {
                    code?: number;
                    location?: CardLocation;
                    level1?: number;
                    level2?: number;
                    response?: number;
                }) {
                    super();
                    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                    if (!Array.isArray(data) && typeof data == "object") {
                        if ("code" in data && data.code != undefined) {
                            this.code = data.code;
                        }
                        if ("location" in data && data.location != undefined) {
                            this.location = data.location;
                        }
                        if ("level1" in data && data.level1 != undefined) {
                            this.level1 = data.level1;
                        }
                        if ("level2" in data && data.level2 != undefined) {
                            this.level2 = data.level2;
                        }
                        if ("response" in data && data.response != undefined) {
                            this.response = data.response;
                        }
                    }
                }
                get code() {
                    return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
                }
                set code(value: number) {
                    pb_1.Message.setField(this, 1, value);
                }
                get location() {
                    return pb_1.Message.getWrapperField(this, CardLocation, 2) as CardLocation;
                }
                set location(value: CardLocation) {
                    pb_1.Message.setWrapperField(this, 2, value);
                }
                get has_location() {
                    return pb_1.Message.getField(this, 2) != null;
                }
                get level1() {
                    return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
                }
                set level1(value: number) {
                    pb_1.Message.setField(this, 3, value);
                }
                get level2() {
                    return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
                }
                set level2(value: number) {
                    pb_1.Message.setField(this, 4, value);
                }
                get response() {
                    return pb_1.Message.getFieldWithDefault(this, 5, 0) as number;
                }
                set response(value: number) {
                    pb_1.Message.setField(this, 5, value);
                }
                static fromObject(data: {
                    code?: number;
                    location?: ReturnType<typeof CardLocation.prototype.toObject>;
                    level1?: number;
                    level2?: number;
                    response?: number;
                }): Info {
                    const message = new Info({});
                    if (data.code != null) {
                        message.code = data.code;
                    }
                    if (data.location != null) {
                        message.location = CardLocation.fromObject(data.location);
                    }
                    if (data.level1 != null) {
                        message.level1 = data.level1;
                    }
                    if (data.level2 != null) {
                        message.level2 = data.level2;
                    }
                    if (data.response != null) {
                        message.response = data.response;
                    }
                    return message;
                }
                toObject() {
                    const data: {
                        code?: number;
                        location?: ReturnType<typeof CardLocation.prototype.toObject>;
                        level1?: number;
                        level2?: number;
                        response?: number;
                    } = {};
                    if (this.code != null) {
                        data.code = this.code;
                    }
                    if (this.location != null) {
                        data.location = this.location.toObject();
                    }
                    if (this.level1 != null) {
                        data.level1 = this.level1;
                    }
                    if (this.level2 != null) {
                        data.level2 = this.level2;
                    }
                    if (this.response != null) {
                        data.response = this.response;
                    }
                    return data;
                }
                serialize(): Uint8Array;
                serialize(w: pb_1.BinaryWriter): void;
                serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                    const writer = w || new pb_1.BinaryWriter();
                    if (this.code != 0)
                        writer.writeInt32(1, this.code);
                    if (this.has_location)
                        writer.writeMessage(2, this.location, () => this.location.serialize(writer));
                    if (this.level1 != 0)
                        writer.writeInt32(3, this.level1);
                    if (this.level2 != 0)
                        writer.writeInt32(4, this.level2);
                    if (this.response != 0)
                        writer.writeInt32(5, this.response);
                    if (!w)
                        return writer.getResultBuffer();
                }
                static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Info {
                    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Info();
                    while (reader.nextField()) {
                        if (reader.isEndGroup())
                            break;
                        switch (reader.getFieldNumber()) {
                            case 1:
                                message.code = reader.readInt32();
                                break;
                            case 2:
                                reader.readMessage(message.location, () => message.location = CardLocation.deserialize(reader));
                                break;
                            case 3:
                                message.level1 = reader.readInt32();
                                break;
                            case 4:
                                message.level2 = reader.readInt32();
                                break;
                            case 5:
                                message.response = reader.readInt32();
                                break;
                            default: reader.skipField();
                        }
                    }
                    return message;
                }
                serializeBinary(): Uint8Array {
                    return this.serialize();
                }
                static deserializeBinary(bytes: Uint8Array): Info {
                    return Info.deserialize(bytes);
                }
            }
        }
        export class MsgSelectYesNo extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                player?: number;
                effect_description?: number;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("player" in data && data.player != undefined) {
                        this.player = data.player;
                    }
                    if ("effect_description" in data && data.effect_description != undefined) {
                        this.effect_description = data.effect_description;
                    }
                }
            }
            get player() {
                return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
            }
            set player(value: number) {
                pb_1.Message.setField(this, 1, value);
            }
            get effect_description() {
                return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
            }
            set effect_description(value: number) {
                pb_1.Message.setField(this, 2, value);
            }
            static fromObject(data: {
                player?: number;
                effect_description?: number;
            }): MsgSelectYesNo {
                const message = new MsgSelectYesNo({});
                if (data.player != null) {
                    message.player = data.player;
                }
                if (data.effect_description != null) {
                    message.effect_description = data.effect_description;
                }
                return message;
            }
            toObject() {
                const data: {
                    player?: number;
                    effect_description?: number;
                } = {};
                if (this.player != null) {
                    data.player = this.player;
                }
                if (this.effect_description != null) {
                    data.effect_description = this.effect_description;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.player != 0)
                    writer.writeInt32(1, this.player);
                if (this.effect_description != 0)
                    writer.writeInt32(2, this.effect_description);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgSelectYesNo {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgSelectYesNo();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.player = reader.readInt32();
                            break;
                        case 2:
                            message.effect_description = reader.readInt32();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): MsgSelectYesNo {
                return MsgSelectYesNo.deserialize(bytes);
            }
        }
        export class MsgUpdateHp extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                player?: number;
                type_?: StocGameMessage.MsgUpdateHp.ActionType;
                value?: number;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("player" in data && data.player != undefined) {
                        this.player = data.player;
                    }
                    if ("type_" in data && data.type_ != undefined) {
                        this.type_ = data.type_;
                    }
                    if ("value" in data && data.value != undefined) {
                        this.value = data.value;
                    }
                }
            }
            get player() {
                return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
            }
            set player(value: number) {
                pb_1.Message.setField(this, 1, value);
            }
            get type_() {
                return pb_1.Message.getFieldWithDefault(this, 2, StocGameMessage.MsgUpdateHp.ActionType.UNKNOWN) as StocGameMessage.MsgUpdateHp.ActionType;
            }
            set type_(value: StocGameMessage.MsgUpdateHp.ActionType) {
                pb_1.Message.setField(this, 2, value);
            }
            get value() {
                return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
            }
            set value(value: number) {
                pb_1.Message.setField(this, 3, value);
            }
            static fromObject(data: {
                player?: number;
                type_?: StocGameMessage.MsgUpdateHp.ActionType;
                value?: number;
            }): MsgUpdateHp {
                const message = new MsgUpdateHp({});
                if (data.player != null) {
                    message.player = data.player;
                }
                if (data.type_ != null) {
                    message.type_ = data.type_;
                }
                if (data.value != null) {
                    message.value = data.value;
                }
                return message;
            }
            toObject() {
                const data: {
                    player?: number;
                    type_?: StocGameMessage.MsgUpdateHp.ActionType;
                    value?: number;
                } = {};
                if (this.player != null) {
                    data.player = this.player;
                }
                if (this.type_ != null) {
                    data.type_ = this.type_;
                }
                if (this.value != null) {
                    data.value = this.value;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.player != 0)
                    writer.writeInt32(1, this.player);
                if (this.type_ != StocGameMessage.MsgUpdateHp.ActionType.UNKNOWN)
                    writer.writeEnum(2, this.type_);
                if (this.value != 0)
                    writer.writeInt32(3, this.value);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgUpdateHp {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgUpdateHp();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.player = reader.readInt32();
                            break;
                        case 2:
                            message.type_ = reader.readEnum();
                            break;
                        case 3:
                            message.value = reader.readInt32();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): MsgUpdateHp {
                return MsgUpdateHp.deserialize(bytes);
            }
        }
        export namespace MsgUpdateHp {
            export enum ActionType {
                UNKNOWN = 0,
                DAMAGE = 1,
                RECOVER = 2
            }
        }
        export class MsgWin extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                win_player?: number;
                reason?: number;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("win_player" in data && data.win_player != undefined) {
                        this.win_player = data.win_player;
                    }
                    if ("reason" in data && data.reason != undefined) {
                        this.reason = data.reason;
                    }
                }
            }
            get win_player() {
                return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
            }
            set win_player(value: number) {
                pb_1.Message.setField(this, 1, value);
            }
            get reason() {
                return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
            }
            set reason(value: number) {
                pb_1.Message.setField(this, 2, value);
            }
            static fromObject(data: {
                win_player?: number;
                reason?: number;
            }): MsgWin {
                const message = new MsgWin({});
                if (data.win_player != null) {
                    message.win_player = data.win_player;
                }
                if (data.reason != null) {
                    message.reason = data.reason;
                }
                return message;
            }
            toObject() {
                const data: {
                    win_player?: number;
                    reason?: number;
                } = {};
                if (this.win_player != null) {
                    data.win_player = this.win_player;
                }
                if (this.reason != null) {
                    data.reason = this.reason;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.win_player != 0)
                    writer.writeInt32(1, this.win_player);
                if (this.reason != 0)
                    writer.writeInt32(2, this.reason);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgWin {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgWin();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.win_player = reader.readInt32();
                            break;
                        case 2:
                            message.reason = reader.readInt32();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): MsgWin {
                return MsgWin.deserialize(bytes);
            }
        }
        export class MsgWait extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {}) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") { }
            }
            static fromObject(data: {}): MsgWait {
                const message = new MsgWait({});
                return message;
            }
            toObject() {
                const data: {} = {};
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgWait {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgWait();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): MsgWait {
                return MsgWait.deserialize(bytes);
            }
        }
        export class MsgUnimplemented extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                command?: number;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("command" in data && data.command != undefined) {
                        this.command = data.command;
                    }
                }
            }
            get command() {
                return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
            }
            set command(value: number) {
                pb_1.Message.setField(this, 1, value);
            }
            static fromObject(data: {
                command?: number;
            }): MsgUnimplemented {
                const message = new MsgUnimplemented({});
                if (data.command != null) {
                    message.command = data.command;
                }
                return message;
            }
            toObject() {
                const data: {
                    command?: number;
                } = {};
                if (this.command != null) {
                    data.command = this.command;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.command != 0)
                    writer.writeInt32(1, this.command);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgUnimplemented {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgUnimplemented();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.command = reader.readInt32();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): MsgUnimplemented {
                return MsgUnimplemented.deserialize(bytes);
            }
        }
        export class MsgUpdateData extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                player?: number;
                zone?: CardZone;
                actions?: StocGameMessage.MsgUpdateData.Action[];
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [3], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("player" in data && data.player != undefined) {
                        this.player = data.player;
                    }
                    if ("zone" in data && data.zone != undefined) {
                        this.zone = data.zone;
                    }
                    if ("actions" in data && data.actions != undefined) {
                        this.actions = data.actions;
                    }
                }
            }
            get player() {
                return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
            }
            set player(value: number) {
                pb_1.Message.setField(this, 1, value);
            }
            get zone() {
                return pb_1.Message.getFieldWithDefault(this, 2, CardZone.DECK) as CardZone;
            }
            set zone(value: CardZone) {
                pb_1.Message.setField(this, 2, value);
            }
            get actions() {
                return pb_1.Message.getRepeatedWrapperField(this, StocGameMessage.MsgUpdateData.Action, 3) as StocGameMessage.MsgUpdateData.Action[];
            }
            set actions(value: StocGameMessage.MsgUpdateData.Action[]) {
                pb_1.Message.setRepeatedWrapperField(this, 3, value);
            }
            static fromObject(data: {
                player?: number;
                zone?: CardZone;
                actions?: ReturnType<typeof StocGameMessage.MsgUpdateData.Action.prototype.toObject>[];
            }): MsgUpdateData {
                const message = new MsgUpdateData({});
                if (data.player != null) {
                    message.player = data.player;
                }
                if (data.zone != null) {
                    message.zone = data.zone;
                }
                if (data.actions != null) {
                    message.actions = data.actions.map(item => StocGameMessage.MsgUpdateData.Action.fromObject(item));
                }
                return message;
            }
            toObject() {
                const data: {
                    player?: number;
                    zone?: CardZone;
                    actions?: ReturnType<typeof StocGameMessage.MsgUpdateData.Action.prototype.toObject>[];
                } = {};
                if (this.player != null) {
                    data.player = this.player;
                }
                if (this.zone != null) {
                    data.zone = this.zone;
                }
                if (this.actions != null) {
                    data.actions = this.actions.map((item: StocGameMessage.MsgUpdateData.Action) => item.toObject());
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.player != 0)
                    writer.writeInt32(1, this.player);
                if (this.zone != CardZone.DECK)
                    writer.writeEnum(2, this.zone);
                if (this.actions.length)
                    writer.writeRepeatedMessage(3, this.actions, (item: StocGameMessage.MsgUpdateData.Action) => item.serialize(writer));
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgUpdateData {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgUpdateData();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.player = reader.readInt32();
                            break;
                        case 2:
                            message.zone = reader.readEnum();
                            break;
                        case 3:
                            reader.readMessage(message.actions, () => pb_1.Message.addToRepeatedWrapperField(message, 3, StocGameMessage.MsgUpdateData.Action.deserialize(reader), StocGameMessage.MsgUpdateData.Action));
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): MsgUpdateData {
                return MsgUpdateData.deserialize(bytes);
            }
        }
        export namespace MsgUpdateData {
            export class Action extends pb_1.Message {
                #one_of_decls: number[][] = [];
                constructor(data?: any[] | {
                    code?: number;
                    location?: CardLocation;
                    alias?: number;
                    type_?: number;
                    level?: number;
                    rank?: number;
                    attribute?: number;
                    race?: number;
                    attack?: number;
                    defense?: number;
                    base_attack?: number;
                    base_defense?: number;
                    reason?: number;
                    reason_card?: number;
                    equip_card?: CardLocation;
                    target_cards?: CardLocation[];
                    overlay_cards?: number[];
                    counters?: Map<number, number>;
                    owner?: number;
                    status?: number;
                    lscale?: number;
                    rscale?: number;
                    link?: number;
                }) {
                    super();
                    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [16, 17], this.#one_of_decls);
                    if (!Array.isArray(data) && typeof data == "object") {
                        if ("code" in data && data.code != undefined) {
                            this.code = data.code;
                        }
                        if ("location" in data && data.location != undefined) {
                            this.location = data.location;
                        }
                        if ("alias" in data && data.alias != undefined) {
                            this.alias = data.alias;
                        }
                        if ("type_" in data && data.type_ != undefined) {
                            this.type_ = data.type_;
                        }
                        if ("level" in data && data.level != undefined) {
                            this.level = data.level;
                        }
                        if ("rank" in data && data.rank != undefined) {
                            this.rank = data.rank;
                        }
                        if ("attribute" in data && data.attribute != undefined) {
                            this.attribute = data.attribute;
                        }
                        if ("race" in data && data.race != undefined) {
                            this.race = data.race;
                        }
                        if ("attack" in data && data.attack != undefined) {
                            this.attack = data.attack;
                        }
                        if ("defense" in data && data.defense != undefined) {
                            this.defense = data.defense;
                        }
                        if ("base_attack" in data && data.base_attack != undefined) {
                            this.base_attack = data.base_attack;
                        }
                        if ("base_defense" in data && data.base_defense != undefined) {
                            this.base_defense = data.base_defense;
                        }
                        if ("reason" in data && data.reason != undefined) {
                            this.reason = data.reason;
                        }
                        if ("reason_card" in data && data.reason_card != undefined) {
                            this.reason_card = data.reason_card;
                        }
                        if ("equip_card" in data && data.equip_card != undefined) {
                            this.equip_card = data.equip_card;
                        }
                        if ("target_cards" in data && data.target_cards != undefined) {
                            this.target_cards = data.target_cards;
                        }
                        if ("overlay_cards" in data && data.overlay_cards != undefined) {
                            this.overlay_cards = data.overlay_cards;
                        }
                        if ("counters" in data && data.counters != undefined) {
                            this.counters = data.counters;
                        }
                        if ("owner" in data && data.owner != undefined) {
                            this.owner = data.owner;
                        }
                        if ("status" in data && data.status != undefined) {
                            this.status = data.status;
                        }
                        if ("lscale" in data && data.lscale != undefined) {
                            this.lscale = data.lscale;
                        }
                        if ("rscale" in data && data.rscale != undefined) {
                            this.rscale = data.rscale;
                        }
                        if ("link" in data && data.link != undefined) {
                            this.link = data.link;
                        }
                    }
                    if (!this.counters)
                        this.counters = new Map();
                }
                get code() {
                    return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
                }
                set code(value: number) {
                    pb_1.Message.setField(this, 1, value);
                }
                get location() {
                    return pb_1.Message.getWrapperField(this, CardLocation, 2) as CardLocation;
                }
                set location(value: CardLocation) {
                    pb_1.Message.setWrapperField(this, 2, value);
                }
                get has_location() {
                    return pb_1.Message.getField(this, 2) != null;
                }
                get alias() {
                    return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
                }
                set alias(value: number) {
                    pb_1.Message.setField(this, 3, value);
                }
                get type_() {
                    return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
                }
                set type_(value: number) {
                    pb_1.Message.setField(this, 4, value);
                }
                get level() {
                    return pb_1.Message.getFieldWithDefault(this, 5, 0) as number;
                }
                set level(value: number) {
                    pb_1.Message.setField(this, 5, value);
                }
                get rank() {
                    return pb_1.Message.getFieldWithDefault(this, 6, 0) as number;
                }
                set rank(value: number) {
                    pb_1.Message.setField(this, 6, value);
                }
                get attribute() {
                    return pb_1.Message.getFieldWithDefault(this, 7, 0) as number;
                }
                set attribute(value: number) {
                    pb_1.Message.setField(this, 7, value);
                }
                get race() {
                    return pb_1.Message.getFieldWithDefault(this, 8, 0) as number;
                }
                set race(value: number) {
                    pb_1.Message.setField(this, 8, value);
                }
                get attack() {
                    return pb_1.Message.getFieldWithDefault(this, 9, 0) as number;
                }
                set attack(value: number) {
                    pb_1.Message.setField(this, 9, value);
                }
                get defense() {
                    return pb_1.Message.getFieldWithDefault(this, 10, 0) as number;
                }
                set defense(value: number) {
                    pb_1.Message.setField(this, 10, value);
                }
                get base_attack() {
                    return pb_1.Message.getFieldWithDefault(this, 11, 0) as number;
                }
                set base_attack(value: number) {
                    pb_1.Message.setField(this, 11, value);
                }
                get base_defense() {
                    return pb_1.Message.getFieldWithDefault(this, 12, 0) as number;
                }
                set base_defense(value: number) {
                    pb_1.Message.setField(this, 12, value);
                }
                get reason() {
                    return pb_1.Message.getFieldWithDefault(this, 13, 0) as number;
                }
                set reason(value: number) {
                    pb_1.Message.setField(this, 13, value);
                }
                get reason_card() {
                    return pb_1.Message.getFieldWithDefault(this, 14, 0) as number;
                }
                set reason_card(value: number) {
                    pb_1.Message.setField(this, 14, value);
                }
                get equip_card() {
                    return pb_1.Message.getWrapperField(this, CardLocation, 15) as CardLocation;
                }
                set equip_card(value: CardLocation) {
                    pb_1.Message.setWrapperField(this, 15, value);
                }
                get has_equip_card() {
                    return pb_1.Message.getField(this, 15) != null;
                }
                get target_cards() {
                    return pb_1.Message.getRepeatedWrapperField(this, CardLocation, 16) as CardLocation[];
                }
                set target_cards(value: CardLocation[]) {
                    pb_1.Message.setRepeatedWrapperField(this, 16, value);
                }
                get overlay_cards() {
                    return pb_1.Message.getFieldWithDefault(this, 17, []) as number[];
                }
                set overlay_cards(value: number[]) {
                    pb_1.Message.setField(this, 17, value);
                }
                get counters() {
                    return pb_1.Message.getField(this, 18) as any as Map<number, number>;
                }
                set counters(value: Map<number, number>) {
                    pb_1.Message.setField(this, 18, value as any);
                }
                get owner() {
                    return pb_1.Message.getFieldWithDefault(this, 19, 0) as number;
                }
                set owner(value: number) {
                    pb_1.Message.setField(this, 19, value);
                }
                get status() {
                    return pb_1.Message.getFieldWithDefault(this, 20, 0) as number;
                }
                set status(value: number) {
                    pb_1.Message.setField(this, 20, value);
                }
                get lscale() {
                    return pb_1.Message.getFieldWithDefault(this, 21, 0) as number;
                }
                set lscale(value: number) {
                    pb_1.Message.setField(this, 21, value);
                }
                get rscale() {
                    return pb_1.Message.getFieldWithDefault(this, 22, 0) as number;
                }
                set rscale(value: number) {
                    pb_1.Message.setField(this, 22, value);
                }
                get link() {
                    return pb_1.Message.getFieldWithDefault(this, 23, 0) as number;
                }
                set link(value: number) {
                    pb_1.Message.setField(this, 23, value);
                }
                static fromObject(data: {
                    code?: number;
                    location?: ReturnType<typeof CardLocation.prototype.toObject>;
                    alias?: number;
                    type_?: number;
                    level?: number;
                    rank?: number;
                    attribute?: number;
                    race?: number;
                    attack?: number;
                    defense?: number;
                    base_attack?: number;
                    base_defense?: number;
                    reason?: number;
                    reason_card?: number;
                    equip_card?: ReturnType<typeof CardLocation.prototype.toObject>;
                    target_cards?: ReturnType<typeof CardLocation.prototype.toObject>[];
                    overlay_cards?: number[];
                    counters?: {
                        [key: number]: number;
                    };
                    owner?: number;
                    status?: number;
                    lscale?: number;
                    rscale?: number;
                    link?: number;
                }): Action {
                    const message = new Action({});
                    if (data.code != null) {
                        message.code = data.code;
                    }
                    if (data.location != null) {
                        message.location = CardLocation.fromObject(data.location);
                    }
                    if (data.alias != null) {
                        message.alias = data.alias;
                    }
                    if (data.type_ != null) {
                        message.type_ = data.type_;
                    }
                    if (data.level != null) {
                        message.level = data.level;
                    }
                    if (data.rank != null) {
                        message.rank = data.rank;
                    }
                    if (data.attribute != null) {
                        message.attribute = data.attribute;
                    }
                    if (data.race != null) {
                        message.race = data.race;
                    }
                    if (data.attack != null) {
                        message.attack = data.attack;
                    }
                    if (data.defense != null) {
                        message.defense = data.defense;
                    }
                    if (data.base_attack != null) {
                        message.base_attack = data.base_attack;
                    }
                    if (data.base_defense != null) {
                        message.base_defense = data.base_defense;
                    }
                    if (data.reason != null) {
                        message.reason = data.reason;
                    }
                    if (data.reason_card != null) {
                        message.reason_card = data.reason_card;
                    }
                    if (data.equip_card != null) {
                        message.equip_card = CardLocation.fromObject(data.equip_card);
                    }
                    if (data.target_cards != null) {
                        message.target_cards = data.target_cards.map(item => CardLocation.fromObject(item));
                    }
                    if (data.overlay_cards != null) {
                        message.overlay_cards = data.overlay_cards;
                    }
                    if (typeof data.counters == "object") {
                        message.counters = new Map(Object.entries(data.counters).map(([key, value]) => [Number(key), value]));
                    }
                    if (data.owner != null) {
                        message.owner = data.owner;
                    }
                    if (data.status != null) {
                        message.status = data.status;
                    }
                    if (data.lscale != null) {
                        message.lscale = data.lscale;
                    }
                    if (data.rscale != null) {
                        message.rscale = data.rscale;
                    }
                    if (data.link != null) {
                        message.link = data.link;
                    }
                    return message;
                }
                toObject() {
                    const data: {
                        code?: number;
                        location?: ReturnType<typeof CardLocation.prototype.toObject>;
                        alias?: number;
                        type_?: number;
                        level?: number;
                        rank?: number;
                        attribute?: number;
                        race?: number;
                        attack?: number;
                        defense?: number;
                        base_attack?: number;
                        base_defense?: number;
                        reason?: number;
                        reason_card?: number;
                        equip_card?: ReturnType<typeof CardLocation.prototype.toObject>;
                        target_cards?: ReturnType<typeof CardLocation.prototype.toObject>[];
                        overlay_cards?: number[];
                        counters?: {
                            [key: number]: number;
                        };
                        owner?: number;
                        status?: number;
                        lscale?: number;
                        rscale?: number;
                        link?: number;
                    } = {};
                    if (this.code != null) {
                        data.code = this.code;
                    }
                    if (this.location != null) {
                        data.location = this.location.toObject();
                    }
                    if (this.alias != null) {
                        data.alias = this.alias;
                    }
                    if (this.type_ != null) {
                        data.type_ = this.type_;
                    }
                    if (this.level != null) {
                        data.level = this.level;
                    }
                    if (this.rank != null) {
                        data.rank = this.rank;
                    }
                    if (this.attribute != null) {
                        data.attribute = this.attribute;
                    }
                    if (this.race != null) {
                        data.race = this.race;
                    }
                    if (this.attack != null) {
                        data.attack = this.attack;
                    }
                    if (this.defense != null) {
                        data.defense = this.defense;
                    }
                    if (this.base_attack != null) {
                        data.base_attack = this.base_attack;
                    }
                    if (this.base_defense != null) {
                        data.base_defense = this.base_defense;
                    }
                    if (this.reason != null) {
                        data.reason = this.reason;
                    }
                    if (this.reason_card != null) {
                        data.reason_card = this.reason_card;
                    }
                    if (this.equip_card != null) {
                        data.equip_card = this.equip_card.toObject();
                    }
                    if (this.target_cards != null) {
                        data.target_cards = this.target_cards.map((item: CardLocation) => item.toObject());
                    }
                    if (this.overlay_cards != null) {
                        data.overlay_cards = this.overlay_cards;
                    }
                    if (this.counters.size > 0) {
                        data.counters = (Object.fromEntries)(this.counters);
                    }
                    if (this.owner != null) {
                        data.owner = this.owner;
                    }
                    if (this.status != null) {
                        data.status = this.status;
                    }
                    if (this.lscale != null) {
                        data.lscale = this.lscale;
                    }
                    if (this.rscale != null) {
                        data.rscale = this.rscale;
                    }
                    if (this.link != null) {
                        data.link = this.link;
                    }
                    return data;
                }
                serialize(): Uint8Array;
                serialize(w: pb_1.BinaryWriter): void;
                serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                    const writer = w || new pb_1.BinaryWriter();
                    if (this.code != 0)
                        writer.writeInt32(1, this.code);
                    if (this.has_location)
                        writer.writeMessage(2, this.location, () => this.location.serialize(writer));
                    if (this.alias != 0)
                        writer.writeInt32(3, this.alias);
                    if (this.type_ != 0)
                        writer.writeInt32(4, this.type_);
                    if (this.level != 0)
                        writer.writeInt32(5, this.level);
                    if (this.rank != 0)
                        writer.writeInt32(6, this.rank);
                    if (this.attribute != 0)
                        writer.writeInt32(7, this.attribute);
                    if (this.race != 0)
                        writer.writeInt32(8, this.race);
                    if (this.attack != 0)
                        writer.writeInt32(9, this.attack);
                    if (this.defense != 0)
                        writer.writeInt32(10, this.defense);
                    if (this.base_attack != 0)
                        writer.writeInt32(11, this.base_attack);
                    if (this.base_defense != 0)
                        writer.writeInt32(12, this.base_defense);
                    if (this.reason != 0)
                        writer.writeInt32(13, this.reason);
                    if (this.reason_card != 0)
                        writer.writeInt32(14, this.reason_card);
                    if (this.has_equip_card)
                        writer.writeMessage(15, this.equip_card, () => this.equip_card.serialize(writer));
                    if (this.target_cards.length)
                        writer.writeRepeatedMessage(16, this.target_cards, (item: CardLocation) => item.serialize(writer));
                    if (this.overlay_cards.length)
                        writer.writePackedInt32(17, this.overlay_cards);
                    for (const [key, value] of this.counters) {
                        writer.writeMessage(18, this.counters, () => {
                            writer.writeInt32(1, key);
                            writer.writeInt32(2, value);
                        });
                    }
                    if (this.owner != 0)
                        writer.writeInt32(19, this.owner);
                    if (this.status != 0)
                        writer.writeInt32(20, this.status);
                    if (this.lscale != 0)
                        writer.writeInt32(21, this.lscale);
                    if (this.rscale != 0)
                        writer.writeInt32(22, this.rscale);
                    if (this.link != 0)
                        writer.writeInt32(23, this.link);
                    if (!w)
                        return writer.getResultBuffer();
                }
                static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Action {
                    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Action();
                    while (reader.nextField()) {
                        if (reader.isEndGroup())
                            break;
                        switch (reader.getFieldNumber()) {
                            case 1:
                                message.code = reader.readInt32();
                                break;
                            case 2:
                                reader.readMessage(message.location, () => message.location = CardLocation.deserialize(reader));
                                break;
                            case 3:
                                message.alias = reader.readInt32();
                                break;
                            case 4:
                                message.type_ = reader.readInt32();
                                break;
                            case 5:
                                message.level = reader.readInt32();
                                break;
                            case 6:
                                message.rank = reader.readInt32();
                                break;
                            case 7:
                                message.attribute = reader.readInt32();
                                break;
                            case 8:
                                message.race = reader.readInt32();
                                break;
                            case 9:
                                message.attack = reader.readInt32();
                                break;
                            case 10:
                                message.defense = reader.readInt32();
                                break;
                            case 11:
                                message.base_attack = reader.readInt32();
                                break;
                            case 12:
                                message.base_defense = reader.readInt32();
                                break;
                            case 13:
                                message.reason = reader.readInt32();
                                break;
                            case 14:
                                message.reason_card = reader.readInt32();
                                break;
                            case 15:
                                reader.readMessage(message.equip_card, () => message.equip_card = CardLocation.deserialize(reader));
                                break;
                            case 16:
                                reader.readMessage(message.target_cards, () => pb_1.Message.addToRepeatedWrapperField(message, 16, CardLocation.deserialize(reader), CardLocation));
                                break;
                            case 17:
                                message.overlay_cards = reader.readPackedInt32();
                                break;
                            case 18:
                                reader.readMessage(message, () => pb_1.Map.deserializeBinary(message.counters as any, reader, reader.readInt32, reader.readInt32));
                                break;
                            case 19:
                                message.owner = reader.readInt32();
                                break;
                            case 20:
                                message.status = reader.readInt32();
                                break;
                            case 21:
                                message.lscale = reader.readInt32();
                                break;
                            case 22:
                                message.rscale = reader.readInt32();
                                break;
                            case 23:
                                message.link = reader.readInt32();
                                break;
                            default: reader.skipField();
                        }
                    }
                    return message;
                }
                serializeBinary(): Uint8Array {
                    return this.serialize();
                }
                static deserializeBinary(bytes: Uint8Array): Action {
                    return Action.deserialize(bytes);
                }
            }
        }
        export class MsgUpdateCounter extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                counter_type?: number;
                location?: CardLocation;
                action_type?: StocGameMessage.MsgUpdateCounter.ActionType;
                count?: number;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("counter_type" in data && data.counter_type != undefined) {
                        this.counter_type = data.counter_type;
                    }
                    if ("location" in data && data.location != undefined) {
                        this.location = data.location;
                    }
                    if ("action_type" in data && data.action_type != undefined) {
                        this.action_type = data.action_type;
                    }
                    if ("count" in data && data.count != undefined) {
                        this.count = data.count;
                    }
                }
            }
            get counter_type() {
                return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
            }
            set counter_type(value: number) {
                pb_1.Message.setField(this, 1, value);
            }
            get location() {
                return pb_1.Message.getWrapperField(this, CardLocation, 2) as CardLocation;
            }
            set location(value: CardLocation) {
                pb_1.Message.setWrapperField(this, 2, value);
            }
            get has_location() {
                return pb_1.Message.getField(this, 2) != null;
            }
            get action_type() {
                return pb_1.Message.getFieldWithDefault(this, 3, StocGameMessage.MsgUpdateCounter.ActionType.UNKNOWN) as StocGameMessage.MsgUpdateCounter.ActionType;
            }
            set action_type(value: StocGameMessage.MsgUpdateCounter.ActionType) {
                pb_1.Message.setField(this, 3, value);
            }
            get count() {
                return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
            }
            set count(value: number) {
                pb_1.Message.setField(this, 4, value);
            }
            static fromObject(data: {
                counter_type?: number;
                location?: ReturnType<typeof CardLocation.prototype.toObject>;
                action_type?: StocGameMessage.MsgUpdateCounter.ActionType;
                count?: number;
            }): MsgUpdateCounter {
                const message = new MsgUpdateCounter({});
                if (data.counter_type != null) {
                    message.counter_type = data.counter_type;
                }
                if (data.location != null) {
                    message.location = CardLocation.fromObject(data.location);
                }
                if (data.action_type != null) {
                    message.action_type = data.action_type;
                }
                if (data.count != null) {
                    message.count = data.count;
                }
                return message;
            }
            toObject() {
                const data: {
                    counter_type?: number;
                    location?: ReturnType<typeof CardLocation.prototype.toObject>;
                    action_type?: StocGameMessage.MsgUpdateCounter.ActionType;
                    count?: number;
                } = {};
                if (this.counter_type != null) {
                    data.counter_type = this.counter_type;
                }
                if (this.location != null) {
                    data.location = this.location.toObject();
                }
                if (this.action_type != null) {
                    data.action_type = this.action_type;
                }
                if (this.count != null) {
                    data.count = this.count;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.counter_type != 0)
                    writer.writeInt32(1, this.counter_type);
                if (this.has_location)
                    writer.writeMessage(2, this.location, () => this.location.serialize(writer));
                if (this.action_type != StocGameMessage.MsgUpdateCounter.ActionType.UNKNOWN)
                    writer.writeEnum(3, this.action_type);
                if (this.count != 0)
                    writer.writeInt32(4, this.count);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgUpdateCounter {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgUpdateCounter();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.counter_type = reader.readInt32();
                            break;
                        case 2:
                            reader.readMessage(message.location, () => message.location = CardLocation.deserialize(reader));
                            break;
                        case 3:
                            message.action_type = reader.readEnum();
                            break;
                        case 4:
                            message.count = reader.readInt32();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): MsgUpdateCounter {
                return MsgUpdateCounter.deserialize(bytes);
            }
        }
        export namespace MsgUpdateCounter {
            export enum ActionType {
                UNKNOWN = 0,
                ADD = 1,
                REMOVE = 2
            }
        }
        export class MsgSelectCounter extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                player?: number;
                counter_type?: number;
                min?: number;
                options?: StocGameMessage.MsgSelectCounter.Info[];
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [4], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("player" in data && data.player != undefined) {
                        this.player = data.player;
                    }
                    if ("counter_type" in data && data.counter_type != undefined) {
                        this.counter_type = data.counter_type;
                    }
                    if ("min" in data && data.min != undefined) {
                        this.min = data.min;
                    }
                    if ("options" in data && data.options != undefined) {
                        this.options = data.options;
                    }
                }
            }
            get player() {
                return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
            }
            set player(value: number) {
                pb_1.Message.setField(this, 1, value);
            }
            get counter_type() {
                return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
            }
            set counter_type(value: number) {
                pb_1.Message.setField(this, 2, value);
            }
            get min() {
                return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
            }
            set min(value: number) {
                pb_1.Message.setField(this, 3, value);
            }
            get options() {
                return pb_1.Message.getRepeatedWrapperField(this, StocGameMessage.MsgSelectCounter.Info, 4) as StocGameMessage.MsgSelectCounter.Info[];
            }
            set options(value: StocGameMessage.MsgSelectCounter.Info[]) {
                pb_1.Message.setRepeatedWrapperField(this, 4, value);
            }
            static fromObject(data: {
                player?: number;
                counter_type?: number;
                min?: number;
                options?: ReturnType<typeof StocGameMessage.MsgSelectCounter.Info.prototype.toObject>[];
            }): MsgSelectCounter {
                const message = new MsgSelectCounter({});
                if (data.player != null) {
                    message.player = data.player;
                }
                if (data.counter_type != null) {
                    message.counter_type = data.counter_type;
                }
                if (data.min != null) {
                    message.min = data.min;
                }
                if (data.options != null) {
                    message.options = data.options.map(item => StocGameMessage.MsgSelectCounter.Info.fromObject(item));
                }
                return message;
            }
            toObject() {
                const data: {
                    player?: number;
                    counter_type?: number;
                    min?: number;
                    options?: ReturnType<typeof StocGameMessage.MsgSelectCounter.Info.prototype.toObject>[];
                } = {};
                if (this.player != null) {
                    data.player = this.player;
                }
                if (this.counter_type != null) {
                    data.counter_type = this.counter_type;
                }
                if (this.min != null) {
                    data.min = this.min;
                }
                if (this.options != null) {
                    data.options = this.options.map((item: StocGameMessage.MsgSelectCounter.Info) => item.toObject());
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.player != 0)
                    writer.writeInt32(1, this.player);
                if (this.counter_type != 0)
                    writer.writeInt32(2, this.counter_type);
                if (this.min != 0)
                    writer.writeInt32(3, this.min);
                if (this.options.length)
                    writer.writeRepeatedMessage(4, this.options, (item: StocGameMessage.MsgSelectCounter.Info) => item.serialize(writer));
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgSelectCounter {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgSelectCounter();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.player = reader.readInt32();
                            break;
                        case 2:
                            message.counter_type = reader.readInt32();
                            break;
                        case 3:
                            message.min = reader.readInt32();
                            break;
                        case 4:
                            reader.readMessage(message.options, () => pb_1.Message.addToRepeatedWrapperField(message, 4, StocGameMessage.MsgSelectCounter.Info.deserialize(reader), StocGameMessage.MsgSelectCounter.Info));
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): MsgSelectCounter {
                return MsgSelectCounter.deserialize(bytes);
            }
        }
        export namespace MsgSelectCounter {
            export class Info extends pb_1.Message {
                #one_of_decls: number[][] = [];
                constructor(data?: any[] | {
                    code?: number;
                    location?: CardLocation;
                    counter_count?: number;
                }) {
                    super();
                    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                    if (!Array.isArray(data) && typeof data == "object") {
                        if ("code" in data && data.code != undefined) {
                            this.code = data.code;
                        }
                        if ("location" in data && data.location != undefined) {
                            this.location = data.location;
                        }
                        if ("counter_count" in data && data.counter_count != undefined) {
                            this.counter_count = data.counter_count;
                        }
                    }
                }
                get code() {
                    return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
                }
                set code(value: number) {
                    pb_1.Message.setField(this, 1, value);
                }
                get location() {
                    return pb_1.Message.getWrapperField(this, CardLocation, 2) as CardLocation;
                }
                set location(value: CardLocation) {
                    pb_1.Message.setWrapperField(this, 2, value);
                }
                get has_location() {
                    return pb_1.Message.getField(this, 2) != null;
                }
                get counter_count() {
                    return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
                }
                set counter_count(value: number) {
                    pb_1.Message.setField(this, 3, value);
                }
                static fromObject(data: {
                    code?: number;
                    location?: ReturnType<typeof CardLocation.prototype.toObject>;
                    counter_count?: number;
                }): Info {
                    const message = new Info({});
                    if (data.code != null) {
                        message.code = data.code;
                    }
                    if (data.location != null) {
                        message.location = CardLocation.fromObject(data.location);
                    }
                    if (data.counter_count != null) {
                        message.counter_count = data.counter_count;
                    }
                    return message;
                }
                toObject() {
                    const data: {
                        code?: number;
                        location?: ReturnType<typeof CardLocation.prototype.toObject>;
                        counter_count?: number;
                    } = {};
                    if (this.code != null) {
                        data.code = this.code;
                    }
                    if (this.location != null) {
                        data.location = this.location.toObject();
                    }
                    if (this.counter_count != null) {
                        data.counter_count = this.counter_count;
                    }
                    return data;
                }
                serialize(): Uint8Array;
                serialize(w: pb_1.BinaryWriter): void;
                serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                    const writer = w || new pb_1.BinaryWriter();
                    if (this.code != 0)
                        writer.writeInt32(1, this.code);
                    if (this.has_location)
                        writer.writeMessage(2, this.location, () => this.location.serialize(writer));
                    if (this.counter_count != 0)
                        writer.writeInt32(3, this.counter_count);
                    if (!w)
                        return writer.getResultBuffer();
                }
                static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Info {
                    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Info();
                    while (reader.nextField()) {
                        if (reader.isEndGroup())
                            break;
                        switch (reader.getFieldNumber()) {
                            case 1:
                                message.code = reader.readInt32();
                                break;
                            case 2:
                                reader.readMessage(message.location, () => message.location = CardLocation.deserialize(reader));
                                break;
                            case 3:
                                message.counter_count = reader.readInt32();
                                break;
                            default: reader.skipField();
                        }
                    }
                    return message;
                }
                serializeBinary(): Uint8Array {
                    return this.serialize();
                }
                static deserializeBinary(bytes: Uint8Array): Info {
                    return Info.deserialize(bytes);
                }
            }
        }
        export class MsgSortCard extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                player?: number;
                options?: StocGameMessage.MsgSortCard.Info[];
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("player" in data && data.player != undefined) {
                        this.player = data.player;
                    }
                    if ("options" in data && data.options != undefined) {
                        this.options = data.options;
                    }
                }
            }
            get player() {
                return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
            }
            set player(value: number) {
                pb_1.Message.setField(this, 1, value);
            }
            get options() {
                return pb_1.Message.getRepeatedWrapperField(this, StocGameMessage.MsgSortCard.Info, 2) as StocGameMessage.MsgSortCard.Info[];
            }
            set options(value: StocGameMessage.MsgSortCard.Info[]) {
                pb_1.Message.setRepeatedWrapperField(this, 2, value);
            }
            static fromObject(data: {
                player?: number;
                options?: ReturnType<typeof StocGameMessage.MsgSortCard.Info.prototype.toObject>[];
            }): MsgSortCard {
                const message = new MsgSortCard({});
                if (data.player != null) {
                    message.player = data.player;
                }
                if (data.options != null) {
                    message.options = data.options.map(item => StocGameMessage.MsgSortCard.Info.fromObject(item));
                }
                return message;
            }
            toObject() {
                const data: {
                    player?: number;
                    options?: ReturnType<typeof StocGameMessage.MsgSortCard.Info.prototype.toObject>[];
                } = {};
                if (this.player != null) {
                    data.player = this.player;
                }
                if (this.options != null) {
                    data.options = this.options.map((item: StocGameMessage.MsgSortCard.Info) => item.toObject());
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.player != 0)
                    writer.writeInt32(1, this.player);
                if (this.options.length)
                    writer.writeRepeatedMessage(2, this.options, (item: StocGameMessage.MsgSortCard.Info) => item.serialize(writer));
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgSortCard {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgSortCard();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.player = reader.readInt32();
                            break;
                        case 2:
                            reader.readMessage(message.options, () => pb_1.Message.addToRepeatedWrapperField(message, 2, StocGameMessage.MsgSortCard.Info.deserialize(reader), StocGameMessage.MsgSortCard.Info));
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): MsgSortCard {
                return MsgSortCard.deserialize(bytes);
            }
        }
        export namespace MsgSortCard {
            export class Info extends pb_1.Message {
                #one_of_decls: number[][] = [];
                constructor(data?: any[] | {
                    code?: number;
                    location?: CardLocation;
                    response?: number;
                }) {
                    super();
                    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                    if (!Array.isArray(data) && typeof data == "object") {
                        if ("code" in data && data.code != undefined) {
                            this.code = data.code;
                        }
                        if ("location" in data && data.location != undefined) {
                            this.location = data.location;
                        }
                        if ("response" in data && data.response != undefined) {
                            this.response = data.response;
                        }
                    }
                }
                get code() {
                    return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
                }
                set code(value: number) {
                    pb_1.Message.setField(this, 1, value);
                }
                get location() {
                    return pb_1.Message.getWrapperField(this, CardLocation, 2) as CardLocation;
                }
                set location(value: CardLocation) {
                    pb_1.Message.setWrapperField(this, 2, value);
                }
                get has_location() {
                    return pb_1.Message.getField(this, 2) != null;
                }
                get response() {
                    return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
                }
                set response(value: number) {
                    pb_1.Message.setField(this, 3, value);
                }
                static fromObject(data: {
                    code?: number;
                    location?: ReturnType<typeof CardLocation.prototype.toObject>;
                    response?: number;
                }): Info {
                    const message = new Info({});
                    if (data.code != null) {
                        message.code = data.code;
                    }
                    if (data.location != null) {
                        message.location = CardLocation.fromObject(data.location);
                    }
                    if (data.response != null) {
                        message.response = data.response;
                    }
                    return message;
                }
                toObject() {
                    const data: {
                        code?: number;
                        location?: ReturnType<typeof CardLocation.prototype.toObject>;
                        response?: number;
                    } = {};
                    if (this.code != null) {
                        data.code = this.code;
                    }
                    if (this.location != null) {
                        data.location = this.location.toObject();
                    }
                    if (this.response != null) {
                        data.response = this.response;
                    }
                    return data;
                }
                serialize(): Uint8Array;
                serialize(w: pb_1.BinaryWriter): void;
                serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                    const writer = w || new pb_1.BinaryWriter();
                    if (this.code != 0)
                        writer.writeInt32(1, this.code);
                    if (this.has_location)
                        writer.writeMessage(2, this.location, () => this.location.serialize(writer));
                    if (this.response != 0)
                        writer.writeInt32(3, this.response);
                    if (!w)
                        return writer.getResultBuffer();
                }
                static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Info {
                    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Info();
                    while (reader.nextField()) {
                        if (reader.isEndGroup())
                            break;
                        switch (reader.getFieldNumber()) {
                            case 1:
                                message.code = reader.readInt32();
                                break;
                            case 2:
                                reader.readMessage(message.location, () => message.location = CardLocation.deserialize(reader));
                                break;
                            case 3:
                                message.response = reader.readInt32();
                                break;
                            default: reader.skipField();
                        }
                    }
                    return message;
                }
                serializeBinary(): Uint8Array {
                    return this.serialize();
                }
                static deserializeBinary(bytes: Uint8Array): Info {
                    return Info.deserialize(bytes);
                }
            }
        }
        export class MsgSet extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {}) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") { }
            }
            static fromObject(data: {}): MsgSet {
                const message = new MsgSet({});
                return message;
            }
            toObject() {
                const data: {} = {};
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgSet {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgSet();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): MsgSet {
                return MsgSet.deserialize(bytes);
            }
        }
        export class MsgSwap extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {}) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") { }
            }
            static fromObject(data: {}): MsgSwap {
                const message = new MsgSwap({});
                return message;
            }
            toObject() {
                const data: {} = {};
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgSwap {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgSwap();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): MsgSwap {
                return MsgSwap.deserialize(bytes);
            }
        }
        export class MsgSummoning extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                code?: number;
                location?: CardLocation;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("code" in data && data.code != undefined) {
                        this.code = data.code;
                    }
                    if ("location" in data && data.location != undefined) {
                        this.location = data.location;
                    }
                }
            }
            get code() {
                return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
            }
            set code(value: number) {
                pb_1.Message.setField(this, 1, value);
            }
            get location() {
                return pb_1.Message.getWrapperField(this, CardLocation, 2) as CardLocation;
            }
            set location(value: CardLocation) {
                pb_1.Message.setWrapperField(this, 2, value);
            }
            get has_location() {
                return pb_1.Message.getField(this, 2) != null;
            }
            static fromObject(data: {
                code?: number;
                location?: ReturnType<typeof CardLocation.prototype.toObject>;
            }): MsgSummoning {
                const message = new MsgSummoning({});
                if (data.code != null) {
                    message.code = data.code;
                }
                if (data.location != null) {
                    message.location = CardLocation.fromObject(data.location);
                }
                return message;
            }
            toObject() {
                const data: {
                    code?: number;
                    location?: ReturnType<typeof CardLocation.prototype.toObject>;
                } = {};
                if (this.code != null) {
                    data.code = this.code;
                }
                if (this.location != null) {
                    data.location = this.location.toObject();
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.code != 0)
                    writer.writeInt32(1, this.code);
                if (this.has_location)
                    writer.writeMessage(2, this.location, () => this.location.serialize(writer));
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgSummoning {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgSummoning();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.code = reader.readInt32();
                            break;
                        case 2:
                            reader.readMessage(message.location, () => message.location = CardLocation.deserialize(reader));
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): MsgSummoning {
                return MsgSummoning.deserialize(bytes);
            }
        }
        export class MsgSummoned extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {}) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") { }
            }
            static fromObject(data: {}): MsgSummoned {
                const message = new MsgSummoned({});
                return message;
            }
            toObject() {
                const data: {} = {};
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgSummoned {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgSummoned();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): MsgSummoned {
                return MsgSummoned.deserialize(bytes);
            }
        }
        export class MsgFlipSummoning extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                code?: number;
                location?: CardLocation;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("code" in data && data.code != undefined) {
                        this.code = data.code;
                    }
                    if ("location" in data && data.location != undefined) {
                        this.location = data.location;
                    }
                }
            }
            get code() {
                return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
            }
            set code(value: number) {
                pb_1.Message.setField(this, 1, value);
            }
            get location() {
                return pb_1.Message.getWrapperField(this, CardLocation, 2) as CardLocation;
            }
            set location(value: CardLocation) {
                pb_1.Message.setWrapperField(this, 2, value);
            }
            get has_location() {
                return pb_1.Message.getField(this, 2) != null;
            }
            static fromObject(data: {
                code?: number;
                location?: ReturnType<typeof CardLocation.prototype.toObject>;
            }): MsgFlipSummoning {
                const message = new MsgFlipSummoning({});
                if (data.code != null) {
                    message.code = data.code;
                }
                if (data.location != null) {
                    message.location = CardLocation.fromObject(data.location);
                }
                return message;
            }
            toObject() {
                const data: {
                    code?: number;
                    location?: ReturnType<typeof CardLocation.prototype.toObject>;
                } = {};
                if (this.code != null) {
                    data.code = this.code;
                }
                if (this.location != null) {
                    data.location = this.location.toObject();
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.code != 0)
                    writer.writeInt32(1, this.code);
                if (this.has_location)
                    writer.writeMessage(2, this.location, () => this.location.serialize(writer));
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgFlipSummoning {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgFlipSummoning();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.code = reader.readInt32();
                            break;
                        case 2:
                            reader.readMessage(message.location, () => message.location = CardLocation.deserialize(reader));
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): MsgFlipSummoning {
                return MsgFlipSummoning.deserialize(bytes);
            }
        }
        export class MsgFlipSummoned extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {}) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") { }
            }
            static fromObject(data: {}): MsgFlipSummoned {
                const message = new MsgFlipSummoned({});
                return message;
            }
            toObject() {
                const data: {} = {};
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgFlipSummoned {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgFlipSummoned();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): MsgFlipSummoned {
                return MsgFlipSummoned.deserialize(bytes);
            }
        }
        export class MsgSpSummoning extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                code?: number;
                location?: CardLocation;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("code" in data && data.code != undefined) {
                        this.code = data.code;
                    }
                    if ("location" in data && data.location != undefined) {
                        this.location = data.location;
                    }
                }
            }
            get code() {
                return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
            }
            set code(value: number) {
                pb_1.Message.setField(this, 1, value);
            }
            get location() {
                return pb_1.Message.getWrapperField(this, CardLocation, 2) as CardLocation;
            }
            set location(value: CardLocation) {
                pb_1.Message.setWrapperField(this, 2, value);
            }
            get has_location() {
                return pb_1.Message.getField(this, 2) != null;
            }
            static fromObject(data: {
                code?: number;
                location?: ReturnType<typeof CardLocation.prototype.toObject>;
            }): MsgSpSummoning {
                const message = new MsgSpSummoning({});
                if (data.code != null) {
                    message.code = data.code;
                }
                if (data.location != null) {
                    message.location = CardLocation.fromObject(data.location);
                }
                return message;
            }
            toObject() {
                const data: {
                    code?: number;
                    location?: ReturnType<typeof CardLocation.prototype.toObject>;
                } = {};
                if (this.code != null) {
                    data.code = this.code;
                }
                if (this.location != null) {
                    data.location = this.location.toObject();
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.code != 0)
                    writer.writeInt32(1, this.code);
                if (this.has_location)
                    writer.writeMessage(2, this.location, () => this.location.serialize(writer));
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgSpSummoning {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgSpSummoning();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.code = reader.readInt32();
                            break;
                        case 2:
                            reader.readMessage(message.location, () => message.location = CardLocation.deserialize(reader));
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): MsgSpSummoning {
                return MsgSpSummoning.deserialize(bytes);
            }
        }
        export class MsgSpSummoned extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {}) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") { }
            }
            static fromObject(data: {}): MsgSpSummoned {
                const message = new MsgSpSummoned({});
                return message;
            }
            toObject() {
                const data: {} = {};
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgSpSummoned {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgSpSummoned();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): MsgSpSummoned {
                return MsgSpSummoned.deserialize(bytes);
            }
        }
        export class MsgChaining extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                code?: number;
                location?: CardLocation;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("code" in data && data.code != undefined) {
                        this.code = data.code;
                    }
                    if ("location" in data && data.location != undefined) {
                        this.location = data.location;
                    }
                }
            }
            get code() {
                return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
            }
            set code(value: number) {
                pb_1.Message.setField(this, 1, value);
            }
            get location() {
                return pb_1.Message.getWrapperField(this, CardLocation, 2) as CardLocation;
            }
            set location(value: CardLocation) {
                pb_1.Message.setWrapperField(this, 2, value);
            }
            get has_location() {
                return pb_1.Message.getField(this, 2) != null;
            }
            static fromObject(data: {
                code?: number;
                location?: ReturnType<typeof CardLocation.prototype.toObject>;
            }): MsgChaining {
                const message = new MsgChaining({});
                if (data.code != null) {
                    message.code = data.code;
                }
                if (data.location != null) {
                    message.location = CardLocation.fromObject(data.location);
                }
                return message;
            }
            toObject() {
                const data: {
                    code?: number;
                    location?: ReturnType<typeof CardLocation.prototype.toObject>;
                } = {};
                if (this.code != null) {
                    data.code = this.code;
                }
                if (this.location != null) {
                    data.location = this.location.toObject();
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.code != 0)
                    writer.writeInt32(1, this.code);
                if (this.has_location)
                    writer.writeMessage(2, this.location, () => this.location.serialize(writer));
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgChaining {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgChaining();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.code = reader.readInt32();
                            break;
                        case 2:
                            reader.readMessage(message.location, () => message.location = CardLocation.deserialize(reader));
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): MsgChaining {
                return MsgChaining.deserialize(bytes);
            }
        }
        export class MsgChainSolved extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                solved_index?: number;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("solved_index" in data && data.solved_index != undefined) {
                        this.solved_index = data.solved_index;
                    }
                }
            }
            get solved_index() {
                return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
            }
            set solved_index(value: number) {
                pb_1.Message.setField(this, 1, value);
            }
            static fromObject(data: {
                solved_index?: number;
            }): MsgChainSolved {
                const message = new MsgChainSolved({});
                if (data.solved_index != null) {
                    message.solved_index = data.solved_index;
                }
                return message;
            }
            toObject() {
                const data: {
                    solved_index?: number;
                } = {};
                if (this.solved_index != null) {
                    data.solved_index = this.solved_index;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.solved_index != 0)
                    writer.writeInt32(1, this.solved_index);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgChainSolved {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgChainSolved();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.solved_index = reader.readInt32();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): MsgChainSolved {
                return MsgChainSolved.deserialize(bytes);
            }
        }
        export class MsgChainEnd extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {}) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") { }
            }
            static fromObject(data: {}): MsgChainEnd {
                const message = new MsgChainEnd({});
                return message;
            }
            toObject() {
                const data: {} = {};
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgChainEnd {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgChainEnd();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): MsgChainEnd {
                return MsgChainEnd.deserialize(bytes);
            }
        }
        export class MsgAttack extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                direct_attack?: boolean;
                attacker_location?: CardLocation;
                target_location?: CardLocation;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("direct_attack" in data && data.direct_attack != undefined) {
                        this.direct_attack = data.direct_attack;
                    }
                    if ("attacker_location" in data && data.attacker_location != undefined) {
                        this.attacker_location = data.attacker_location;
                    }
                    if ("target_location" in data && data.target_location != undefined) {
                        this.target_location = data.target_location;
                    }
                }
            }
            get direct_attack() {
                return pb_1.Message.getFieldWithDefault(this, 1, false) as boolean;
            }
            set direct_attack(value: boolean) {
                pb_1.Message.setField(this, 1, value);
            }
            get attacker_location() {
                return pb_1.Message.getWrapperField(this, CardLocation, 2) as CardLocation;
            }
            set attacker_location(value: CardLocation) {
                pb_1.Message.setWrapperField(this, 2, value);
            }
            get has_attacker_location() {
                return pb_1.Message.getField(this, 2) != null;
            }
            get target_location() {
                return pb_1.Message.getWrapperField(this, CardLocation, 3) as CardLocation;
            }
            set target_location(value: CardLocation) {
                pb_1.Message.setWrapperField(this, 3, value);
            }
            get has_target_location() {
                return pb_1.Message.getField(this, 3) != null;
            }
            static fromObject(data: {
                direct_attack?: boolean;
                attacker_location?: ReturnType<typeof CardLocation.prototype.toObject>;
                target_location?: ReturnType<typeof CardLocation.prototype.toObject>;
            }): MsgAttack {
                const message = new MsgAttack({});
                if (data.direct_attack != null) {
                    message.direct_attack = data.direct_attack;
                }
                if (data.attacker_location != null) {
                    message.attacker_location = CardLocation.fromObject(data.attacker_location);
                }
                if (data.target_location != null) {
                    message.target_location = CardLocation.fromObject(data.target_location);
                }
                return message;
            }
            toObject() {
                const data: {
                    direct_attack?: boolean;
                    attacker_location?: ReturnType<typeof CardLocation.prototype.toObject>;
                    target_location?: ReturnType<typeof CardLocation.prototype.toObject>;
                } = {};
                if (this.direct_attack != null) {
                    data.direct_attack = this.direct_attack;
                }
                if (this.attacker_location != null) {
                    data.attacker_location = this.attacker_location.toObject();
                }
                if (this.target_location != null) {
                    data.target_location = this.target_location.toObject();
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.direct_attack != false)
                    writer.writeBool(1, this.direct_attack);
                if (this.has_attacker_location)
                    writer.writeMessage(2, this.attacker_location, () => this.attacker_location.serialize(writer));
                if (this.has_target_location)
                    writer.writeMessage(3, this.target_location, () => this.target_location.serialize(writer));
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgAttack {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgAttack();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.direct_attack = reader.readBool();
                            break;
                        case 2:
                            reader.readMessage(message.attacker_location, () => message.attacker_location = CardLocation.deserialize(reader));
                            break;
                        case 3:
                            reader.readMessage(message.target_location, () => message.target_location = CardLocation.deserialize(reader));
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): MsgAttack {
                return MsgAttack.deserialize(bytes);
            }
        }
        export class MsgAttackDisabled extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {}) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") { }
            }
            static fromObject(data: {}): MsgAttackDisabled {
                const message = new MsgAttackDisabled({});
                return message;
            }
            toObject() {
                const data: {} = {};
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgAttackDisabled {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgAttackDisabled();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): MsgAttackDisabled {
                return MsgAttackDisabled.deserialize(bytes);
            }
        }
        export class MsgAnnounce extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                player?: number;
                announce_type?: StocGameMessage.MsgAnnounce.AnnounceType;
                min?: number;
                options?: StocGameMessage.MsgAnnounce.Option[];
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [4], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("player" in data && data.player != undefined) {
                        this.player = data.player;
                    }
                    if ("announce_type" in data && data.announce_type != undefined) {
                        this.announce_type = data.announce_type;
                    }
                    if ("min" in data && data.min != undefined) {
                        this.min = data.min;
                    }
                    if ("options" in data && data.options != undefined) {
                        this.options = data.options;
                    }
                }
            }
            get player() {
                return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
            }
            set player(value: number) {
                pb_1.Message.setField(this, 1, value);
            }
            get announce_type() {
                return pb_1.Message.getFieldWithDefault(this, 2, StocGameMessage.MsgAnnounce.AnnounceType.UNKNOWN) as StocGameMessage.MsgAnnounce.AnnounceType;
            }
            set announce_type(value: StocGameMessage.MsgAnnounce.AnnounceType) {
                pb_1.Message.setField(this, 2, value);
            }
            get min() {
                return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
            }
            set min(value: number) {
                pb_1.Message.setField(this, 3, value);
            }
            get options() {
                return pb_1.Message.getRepeatedWrapperField(this, StocGameMessage.MsgAnnounce.Option, 4) as StocGameMessage.MsgAnnounce.Option[];
            }
            set options(value: StocGameMessage.MsgAnnounce.Option[]) {
                pb_1.Message.setRepeatedWrapperField(this, 4, value);
            }
            static fromObject(data: {
                player?: number;
                announce_type?: StocGameMessage.MsgAnnounce.AnnounceType;
                min?: number;
                options?: ReturnType<typeof StocGameMessage.MsgAnnounce.Option.prototype.toObject>[];
            }): MsgAnnounce {
                const message = new MsgAnnounce({});
                if (data.player != null) {
                    message.player = data.player;
                }
                if (data.announce_type != null) {
                    message.announce_type = data.announce_type;
                }
                if (data.min != null) {
                    message.min = data.min;
                }
                if (data.options != null) {
                    message.options = data.options.map(item => StocGameMessage.MsgAnnounce.Option.fromObject(item));
                }
                return message;
            }
            toObject() {
                const data: {
                    player?: number;
                    announce_type?: StocGameMessage.MsgAnnounce.AnnounceType;
                    min?: number;
                    options?: ReturnType<typeof StocGameMessage.MsgAnnounce.Option.prototype.toObject>[];
                } = {};
                if (this.player != null) {
                    data.player = this.player;
                }
                if (this.announce_type != null) {
                    data.announce_type = this.announce_type;
                }
                if (this.min != null) {
                    data.min = this.min;
                }
                if (this.options != null) {
                    data.options = this.options.map((item: StocGameMessage.MsgAnnounce.Option) => item.toObject());
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.player != 0)
                    writer.writeInt32(1, this.player);
                if (this.announce_type != StocGameMessage.MsgAnnounce.AnnounceType.UNKNOWN)
                    writer.writeEnum(2, this.announce_type);
                if (this.min != 0)
                    writer.writeInt32(3, this.min);
                if (this.options.length)
                    writer.writeRepeatedMessage(4, this.options, (item: StocGameMessage.MsgAnnounce.Option) => item.serialize(writer));
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgAnnounce {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgAnnounce();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.player = reader.readInt32();
                            break;
                        case 2:
                            message.announce_type = reader.readEnum();
                            break;
                        case 3:
                            message.min = reader.readInt32();
                            break;
                        case 4:
                            reader.readMessage(message.options, () => pb_1.Message.addToRepeatedWrapperField(message, 4, StocGameMessage.MsgAnnounce.Option.deserialize(reader), StocGameMessage.MsgAnnounce.Option));
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): MsgAnnounce {
                return MsgAnnounce.deserialize(bytes);
            }
        }
        export namespace MsgAnnounce {
            export enum AnnounceType {
                UNKNOWN = 0,
                RACE = 1,
                Attribute = 2,
                Card = 3,
                Number = 4
            }
            export class Option extends pb_1.Message {
                #one_of_decls: number[][] = [];
                constructor(data?: any[] | {
                    code?: number;
                    response?: number;
                }) {
                    super();
                    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                    if (!Array.isArray(data) && typeof data == "object") {
                        if ("code" in data && data.code != undefined) {
                            this.code = data.code;
                        }
                        if ("response" in data && data.response != undefined) {
                            this.response = data.response;
                        }
                    }
                }
                get code() {
                    return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
                }
                set code(value: number) {
                    pb_1.Message.setField(this, 1, value);
                }
                get response() {
                    return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
                }
                set response(value: number) {
                    pb_1.Message.setField(this, 2, value);
                }
                static fromObject(data: {
                    code?: number;
                    response?: number;
                }): Option {
                    const message = new Option({});
                    if (data.code != null) {
                        message.code = data.code;
                    }
                    if (data.response != null) {
                        message.response = data.response;
                    }
                    return message;
                }
                toObject() {
                    const data: {
                        code?: number;
                        response?: number;
                    } = {};
                    if (this.code != null) {
                        data.code = this.code;
                    }
                    if (this.response != null) {
                        data.response = this.response;
                    }
                    return data;
                }
                serialize(): Uint8Array;
                serialize(w: pb_1.BinaryWriter): void;
                serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                    const writer = w || new pb_1.BinaryWriter();
                    if (this.code != 0)
                        writer.writeInt32(1, this.code);
                    if (this.response != 0)
                        writer.writeInt32(2, this.response);
                    if (!w)
                        return writer.getResultBuffer();
                }
                static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Option {
                    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Option();
                    while (reader.nextField()) {
                        if (reader.isEndGroup())
                            break;
                        switch (reader.getFieldNumber()) {
                            case 1:
                                message.code = reader.readInt32();
                                break;
                            case 2:
                                message.response = reader.readInt32();
                                break;
                            default: reader.skipField();
                        }
                    }
                    return message;
                }
                serializeBinary(): Uint8Array {
                    return this.serialize();
                }
                static deserializeBinary(bytes: Uint8Array): Option {
                    return Option.deserialize(bytes);
                }
            }
        }
        export class MsgLpUpdate extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                player?: number;
                new_lp?: number;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("player" in data && data.player != undefined) {
                        this.player = data.player;
                    }
                    if ("new_lp" in data && data.new_lp != undefined) {
                        this.new_lp = data.new_lp;
                    }
                }
            }
            get player() {
                return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
            }
            set player(value: number) {
                pb_1.Message.setField(this, 1, value);
            }
            get new_lp() {
                return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
            }
            set new_lp(value: number) {
                pb_1.Message.setField(this, 2, value);
            }
            static fromObject(data: {
                player?: number;
                new_lp?: number;
            }): MsgLpUpdate {
                const message = new MsgLpUpdate({});
                if (data.player != null) {
                    message.player = data.player;
                }
                if (data.new_lp != null) {
                    message.new_lp = data.new_lp;
                }
                return message;
            }
            toObject() {
                const data: {
                    player?: number;
                    new_lp?: number;
                } = {};
                if (this.player != null) {
                    data.player = this.player;
                }
                if (this.new_lp != null) {
                    data.new_lp = this.new_lp;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.player != 0)
                    writer.writeInt32(1, this.player);
                if (this.new_lp != 0)
                    writer.writeInt32(2, this.new_lp);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgLpUpdate {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgLpUpdate();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.player = reader.readInt32();
                            break;
                        case 2:
                            message.new_lp = reader.readInt32();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): MsgLpUpdate {
                return MsgLpUpdate.deserialize(bytes);
            }
        }
        export class MsgConfirmCards extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                player?: number;
                cards?: CardInfo[];
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("player" in data && data.player != undefined) {
                        this.player = data.player;
                    }
                    if ("cards" in data && data.cards != undefined) {
                        this.cards = data.cards;
                    }
                }
            }
            get player() {
                return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
            }
            set player(value: number) {
                pb_1.Message.setField(this, 1, value);
            }
            get cards() {
                return pb_1.Message.getRepeatedWrapperField(this, CardInfo, 2) as CardInfo[];
            }
            set cards(value: CardInfo[]) {
                pb_1.Message.setRepeatedWrapperField(this, 2, value);
            }
            static fromObject(data: {
                player?: number;
                cards?: ReturnType<typeof CardInfo.prototype.toObject>[];
            }): MsgConfirmCards {
                const message = new MsgConfirmCards({});
                if (data.player != null) {
                    message.player = data.player;
                }
                if (data.cards != null) {
                    message.cards = data.cards.map(item => CardInfo.fromObject(item));
                }
                return message;
            }
            toObject() {
                const data: {
                    player?: number;
                    cards?: ReturnType<typeof CardInfo.prototype.toObject>[];
                } = {};
                if (this.player != null) {
                    data.player = this.player;
                }
                if (this.cards != null) {
                    data.cards = this.cards.map((item: CardInfo) => item.toObject());
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.player != 0)
                    writer.writeInt32(1, this.player);
                if (this.cards.length)
                    writer.writeRepeatedMessage(2, this.cards, (item: CardInfo) => item.serialize(writer));
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgConfirmCards {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgConfirmCards();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.player = reader.readInt32();
                            break;
                        case 2:
                            reader.readMessage(message.cards, () => pb_1.Message.addToRepeatedWrapperField(message, 2, CardInfo.deserialize(reader), CardInfo));
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): MsgConfirmCards {
                return MsgConfirmCards.deserialize(bytes);
            }
        }
        export class MsgBecomeTarget extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                locations?: CardLocation[];
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("locations" in data && data.locations != undefined) {
                        this.locations = data.locations;
                    }
                }
            }
            get locations() {
                return pb_1.Message.getRepeatedWrapperField(this, CardLocation, 1) as CardLocation[];
            }
            set locations(value: CardLocation[]) {
                pb_1.Message.setRepeatedWrapperField(this, 1, value);
            }
            static fromObject(data: {
                locations?: ReturnType<typeof CardLocation.prototype.toObject>[];
            }): MsgBecomeTarget {
                const message = new MsgBecomeTarget({});
                if (data.locations != null) {
                    message.locations = data.locations.map(item => CardLocation.fromObject(item));
                }
                return message;
            }
            toObject() {
                const data: {
                    locations?: ReturnType<typeof CardLocation.prototype.toObject>[];
                } = {};
                if (this.locations != null) {
                    data.locations = this.locations.map((item: CardLocation) => item.toObject());
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.locations.length)
                    writer.writeRepeatedMessage(1, this.locations, (item: CardLocation) => item.serialize(writer));
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgBecomeTarget {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgBecomeTarget();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            reader.readMessage(message.locations, () => pb_1.Message.addToRepeatedWrapperField(message, 1, CardLocation.deserialize(reader), CardLocation));
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): MsgBecomeTarget {
                return MsgBecomeTarget.deserialize(bytes);
            }
        }
        export class MsgToss extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                player?: number;
                toss_type?: StocGameMessage.MsgToss.TossType;
                res?: number[];
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [3], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("player" in data && data.player != undefined) {
                        this.player = data.player;
                    }
                    if ("toss_type" in data && data.toss_type != undefined) {
                        this.toss_type = data.toss_type;
                    }
                    if ("res" in data && data.res != undefined) {
                        this.res = data.res;
                    }
                }
            }
            get player() {
                return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
            }
            set player(value: number) {
                pb_1.Message.setField(this, 1, value);
            }
            get toss_type() {
                return pb_1.Message.getFieldWithDefault(this, 2, StocGameMessage.MsgToss.TossType.UNKNOWN) as StocGameMessage.MsgToss.TossType;
            }
            set toss_type(value: StocGameMessage.MsgToss.TossType) {
                pb_1.Message.setField(this, 2, value);
            }
            get res() {
                return pb_1.Message.getFieldWithDefault(this, 3, []) as number[];
            }
            set res(value: number[]) {
                pb_1.Message.setField(this, 3, value);
            }
            static fromObject(data: {
                player?: number;
                toss_type?: StocGameMessage.MsgToss.TossType;
                res?: number[];
            }): MsgToss {
                const message = new MsgToss({});
                if (data.player != null) {
                    message.player = data.player;
                }
                if (data.toss_type != null) {
                    message.toss_type = data.toss_type;
                }
                if (data.res != null) {
                    message.res = data.res;
                }
                return message;
            }
            toObject() {
                const data: {
                    player?: number;
                    toss_type?: StocGameMessage.MsgToss.TossType;
                    res?: number[];
                } = {};
                if (this.player != null) {
                    data.player = this.player;
                }
                if (this.toss_type != null) {
                    data.toss_type = this.toss_type;
                }
                if (this.res != null) {
                    data.res = this.res;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.player != 0)
                    writer.writeInt32(1, this.player);
                if (this.toss_type != StocGameMessage.MsgToss.TossType.UNKNOWN)
                    writer.writeEnum(2, this.toss_type);
                if (this.res.length)
                    writer.writePackedInt32(3, this.res);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgToss {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgToss();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.player = reader.readInt32();
                            break;
                        case 2:
                            message.toss_type = reader.readEnum();
                            break;
                        case 3:
                            message.res = reader.readPackedInt32();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): MsgToss {
                return MsgToss.deserialize(bytes);
            }
        }
        export namespace MsgToss {
            export enum TossType {
                UNKNOWN = 0,
                COIN = 1,
                DICE = 2
            }
        }
        export class MsgFieldDisabled extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                actions?: StocGameMessage.MsgFieldDisabled.Action[];
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("actions" in data && data.actions != undefined) {
                        this.actions = data.actions;
                    }
                }
            }
            get actions() {
                return pb_1.Message.getRepeatedWrapperField(this, StocGameMessage.MsgFieldDisabled.Action, 1) as StocGameMessage.MsgFieldDisabled.Action[];
            }
            set actions(value: StocGameMessage.MsgFieldDisabled.Action[]) {
                pb_1.Message.setRepeatedWrapperField(this, 1, value);
            }
            static fromObject(data: {
                actions?: ReturnType<typeof StocGameMessage.MsgFieldDisabled.Action.prototype.toObject>[];
            }): MsgFieldDisabled {
                const message = new MsgFieldDisabled({});
                if (data.actions != null) {
                    message.actions = data.actions.map(item => StocGameMessage.MsgFieldDisabled.Action.fromObject(item));
                }
                return message;
            }
            toObject() {
                const data: {
                    actions?: ReturnType<typeof StocGameMessage.MsgFieldDisabled.Action.prototype.toObject>[];
                } = {};
                if (this.actions != null) {
                    data.actions = this.actions.map((item: StocGameMessage.MsgFieldDisabled.Action) => item.toObject());
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.actions.length)
                    writer.writeRepeatedMessage(1, this.actions, (item: StocGameMessage.MsgFieldDisabled.Action) => item.serialize(writer));
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgFieldDisabled {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgFieldDisabled();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            reader.readMessage(message.actions, () => pb_1.Message.addToRepeatedWrapperField(message, 1, StocGameMessage.MsgFieldDisabled.Action.deserialize(reader), StocGameMessage.MsgFieldDisabled.Action));
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): MsgFieldDisabled {
                return MsgFieldDisabled.deserialize(bytes);
            }
        }
        export namespace MsgFieldDisabled {
            export class Action extends pb_1.Message {
                #one_of_decls: number[][] = [];
                constructor(data?: any[] | {
                    controller?: number;
                    zone?: CardZone;
                    sequence?: number;
                    disabled?: boolean;
                }) {
                    super();
                    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                    if (!Array.isArray(data) && typeof data == "object") {
                        if ("controller" in data && data.controller != undefined) {
                            this.controller = data.controller;
                        }
                        if ("zone" in data && data.zone != undefined) {
                            this.zone = data.zone;
                        }
                        if ("sequence" in data && data.sequence != undefined) {
                            this.sequence = data.sequence;
                        }
                        if ("disabled" in data && data.disabled != undefined) {
                            this.disabled = data.disabled;
                        }
                    }
                }
                get controller() {
                    return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
                }
                set controller(value: number) {
                    pb_1.Message.setField(this, 1, value);
                }
                get zone() {
                    return pb_1.Message.getFieldWithDefault(this, 2, CardZone.DECK) as CardZone;
                }
                set zone(value: CardZone) {
                    pb_1.Message.setField(this, 2, value);
                }
                get sequence() {
                    return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
                }
                set sequence(value: number) {
                    pb_1.Message.setField(this, 3, value);
                }
                get disabled() {
                    return pb_1.Message.getFieldWithDefault(this, 4, false) as boolean;
                }
                set disabled(value: boolean) {
                    pb_1.Message.setField(this, 4, value);
                }
                static fromObject(data: {
                    controller?: number;
                    zone?: CardZone;
                    sequence?: number;
                    disabled?: boolean;
                }): Action {
                    const message = new Action({});
                    if (data.controller != null) {
                        message.controller = data.controller;
                    }
                    if (data.zone != null) {
                        message.zone = data.zone;
                    }
                    if (data.sequence != null) {
                        message.sequence = data.sequence;
                    }
                    if (data.disabled != null) {
                        message.disabled = data.disabled;
                    }
                    return message;
                }
                toObject() {
                    const data: {
                        controller?: number;
                        zone?: CardZone;
                        sequence?: number;
                        disabled?: boolean;
                    } = {};
                    if (this.controller != null) {
                        data.controller = this.controller;
                    }
                    if (this.zone != null) {
                        data.zone = this.zone;
                    }
                    if (this.sequence != null) {
                        data.sequence = this.sequence;
                    }
                    if (this.disabled != null) {
                        data.disabled = this.disabled;
                    }
                    return data;
                }
                serialize(): Uint8Array;
                serialize(w: pb_1.BinaryWriter): void;
                serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                    const writer = w || new pb_1.BinaryWriter();
                    if (this.controller != 0)
                        writer.writeInt32(1, this.controller);
                    if (this.zone != CardZone.DECK)
                        writer.writeEnum(2, this.zone);
                    if (this.sequence != 0)
                        writer.writeInt32(3, this.sequence);
                    if (this.disabled != false)
                        writer.writeBool(4, this.disabled);
                    if (!w)
                        return writer.getResultBuffer();
                }
                static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Action {
                    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Action();
                    while (reader.nextField()) {
                        if (reader.isEndGroup())
                            break;
                        switch (reader.getFieldNumber()) {
                            case 1:
                                message.controller = reader.readInt32();
                                break;
                            case 2:
                                message.zone = reader.readEnum();
                                break;
                            case 3:
                                message.sequence = reader.readInt32();
                                break;
                            case 4:
                                message.disabled = reader.readBool();
                                break;
                            default: reader.skipField();
                        }
                    }
                    return message;
                }
                serializeBinary(): Uint8Array {
                    return this.serialize();
                }
                static deserializeBinary(bytes: Uint8Array): Action {
                    return Action.deserialize(bytes);
                }
            }
        }
        export class MsgShuffleDeck extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                player?: number;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("player" in data && data.player != undefined) {
                        this.player = data.player;
                    }
                }
            }
            get player() {
                return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
            }
            set player(value: number) {
                pb_1.Message.setField(this, 1, value);
            }
            static fromObject(data: {
                player?: number;
            }): MsgShuffleDeck {
                const message = new MsgShuffleDeck({});
                if (data.player != null) {
                    message.player = data.player;
                }
                return message;
            }
            toObject() {
                const data: {
                    player?: number;
                } = {};
                if (this.player != null) {
                    data.player = this.player;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.player != 0)
                    writer.writeInt32(1, this.player);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgShuffleDeck {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgShuffleDeck();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.player = reader.readInt32();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): MsgShuffleDeck {
                return MsgShuffleDeck.deserialize(bytes);
            }
        }
        export class MsgRockPaperScissors extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                player?: number;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("player" in data && data.player != undefined) {
                        this.player = data.player;
                    }
                }
            }
            get player() {
                return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
            }
            set player(value: number) {
                pb_1.Message.setField(this, 1, value);
            }
            static fromObject(data: {
                player?: number;
            }): MsgRockPaperScissors {
                const message = new MsgRockPaperScissors({});
                if (data.player != null) {
                    message.player = data.player;
                }
                return message;
            }
            toObject() {
                const data: {
                    player?: number;
                } = {};
                if (this.player != null) {
                    data.player = this.player;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.player != 0)
                    writer.writeInt32(1, this.player);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgRockPaperScissors {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgRockPaperScissors();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.player = reader.readInt32();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): MsgRockPaperScissors {
                return MsgRockPaperScissors.deserialize(bytes);
            }
        }
        export class MsgHandResult extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                result1?: number;
                result2?: number;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("result1" in data && data.result1 != undefined) {
                        this.result1 = data.result1;
                    }
                    if ("result2" in data && data.result2 != undefined) {
                        this.result2 = data.result2;
                    }
                }
            }
            get result1() {
                return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
            }
            set result1(value: number) {
                pb_1.Message.setField(this, 1, value);
            }
            get result2() {
                return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
            }
            set result2(value: number) {
                pb_1.Message.setField(this, 2, value);
            }
            static fromObject(data: {
                result1?: number;
                result2?: number;
            }): MsgHandResult {
                const message = new MsgHandResult({});
                if (data.result1 != null) {
                    message.result1 = data.result1;
                }
                if (data.result2 != null) {
                    message.result2 = data.result2;
                }
                return message;
            }
            toObject() {
                const data: {
                    result1?: number;
                    result2?: number;
                } = {};
                if (this.result1 != null) {
                    data.result1 = this.result1;
                }
                if (this.result2 != null) {
                    data.result2 = this.result2;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.result1 != 0)
                    writer.writeInt32(1, this.result1);
                if (this.result2 != 0)
                    writer.writeInt32(2, this.result2);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgHandResult {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgHandResult();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.result1 = reader.readInt32();
                            break;
                        case 2:
                            message.result2 = reader.readInt32();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): MsgHandResult {
                return MsgHandResult.deserialize(bytes);
            }
        }
        export class MsgSwapGraveDeck extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                player?: number;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("player" in data && data.player != undefined) {
                        this.player = data.player;
                    }
                }
            }
            get player() {
                return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
            }
            set player(value: number) {
                pb_1.Message.setField(this, 1, value);
            }
            static fromObject(data: {
                player?: number;
            }): MsgSwapGraveDeck {
                const message = new MsgSwapGraveDeck({});
                if (data.player != null) {
                    message.player = data.player;
                }
                return message;
            }
            toObject() {
                const data: {
                    player?: number;
                } = {};
                if (this.player != null) {
                    data.player = this.player;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.player != 0)
                    writer.writeInt32(1, this.player);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgSwapGraveDeck {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgSwapGraveDeck();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.player = reader.readInt32();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): MsgSwapGraveDeck {
                return MsgSwapGraveDeck.deserialize(bytes);
            }
        }
        export class MsgSibylName extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                name_0?: string;
                name_0_tag?: string;
                name_0_c?: string;
                name_1?: string;
                name_1_tag?: string;
                name_1_c?: string;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("name_0" in data && data.name_0 != undefined) {
                        this.name_0 = data.name_0;
                    }
                    if ("name_0_tag" in data && data.name_0_tag != undefined) {
                        this.name_0_tag = data.name_0_tag;
                    }
                    if ("name_0_c" in data && data.name_0_c != undefined) {
                        this.name_0_c = data.name_0_c;
                    }
                    if ("name_1" in data && data.name_1 != undefined) {
                        this.name_1 = data.name_1;
                    }
                    if ("name_1_tag" in data && data.name_1_tag != undefined) {
                        this.name_1_tag = data.name_1_tag;
                    }
                    if ("name_1_c" in data && data.name_1_c != undefined) {
                        this.name_1_c = data.name_1_c;
                    }
                }
            }
            get name_0() {
                return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
            }
            set name_0(value: string) {
                pb_1.Message.setField(this, 1, value);
            }
            get name_0_tag() {
                return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
            }
            set name_0_tag(value: string) {
                pb_1.Message.setField(this, 2, value);
            }
            get name_0_c() {
                return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
            }
            set name_0_c(value: string) {
                pb_1.Message.setField(this, 3, value);
            }
            get name_1() {
                return pb_1.Message.getFieldWithDefault(this, 4, "") as string;
            }
            set name_1(value: string) {
                pb_1.Message.setField(this, 4, value);
            }
            get name_1_tag() {
                return pb_1.Message.getFieldWithDefault(this, 5, "") as string;
            }
            set name_1_tag(value: string) {
                pb_1.Message.setField(this, 5, value);
            }
            get name_1_c() {
                return pb_1.Message.getFieldWithDefault(this, 6, "") as string;
            }
            set name_1_c(value: string) {
                pb_1.Message.setField(this, 6, value);
            }
            static fromObject(data: {
                name_0?: string;
                name_0_tag?: string;
                name_0_c?: string;
                name_1?: string;
                name_1_tag?: string;
                name_1_c?: string;
            }): MsgSibylName {
                const message = new MsgSibylName({});
                if (data.name_0 != null) {
                    message.name_0 = data.name_0;
                }
                if (data.name_0_tag != null) {
                    message.name_0_tag = data.name_0_tag;
                }
                if (data.name_0_c != null) {
                    message.name_0_c = data.name_0_c;
                }
                if (data.name_1 != null) {
                    message.name_1 = data.name_1;
                }
                if (data.name_1_tag != null) {
                    message.name_1_tag = data.name_1_tag;
                }
                if (data.name_1_c != null) {
                    message.name_1_c = data.name_1_c;
                }
                return message;
            }
            toObject() {
                const data: {
                    name_0?: string;
                    name_0_tag?: string;
                    name_0_c?: string;
                    name_1?: string;
                    name_1_tag?: string;
                    name_1_c?: string;
                } = {};
                if (this.name_0 != null) {
                    data.name_0 = this.name_0;
                }
                if (this.name_0_tag != null) {
                    data.name_0_tag = this.name_0_tag;
                }
                if (this.name_0_c != null) {
                    data.name_0_c = this.name_0_c;
                }
                if (this.name_1 != null) {
                    data.name_1 = this.name_1;
                }
                if (this.name_1_tag != null) {
                    data.name_1_tag = this.name_1_tag;
                }
                if (this.name_1_c != null) {
                    data.name_1_c = this.name_1_c;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.name_0.length)
                    writer.writeString(1, this.name_0);
                if (this.name_0_tag.length)
                    writer.writeString(2, this.name_0_tag);
                if (this.name_0_c.length)
                    writer.writeString(3, this.name_0_c);
                if (this.name_1.length)
                    writer.writeString(4, this.name_1);
                if (this.name_1_tag.length)
                    writer.writeString(5, this.name_1_tag);
                if (this.name_1_c.length)
                    writer.writeString(6, this.name_1_c);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgSibylName {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgSibylName();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.name_0 = reader.readString();
                            break;
                        case 2:
                            message.name_0_tag = reader.readString();
                            break;
                        case 3:
                            message.name_0_c = reader.readString();
                            break;
                        case 4:
                            message.name_1 = reader.readString();
                            break;
                        case 5:
                            message.name_1_tag = reader.readString();
                            break;
                        case 6:
                            message.name_1_c = reader.readString();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): MsgSibylName {
                return MsgSibylName.deserialize(bytes);
            }
        }
        export class MsgReloadField extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                duel_rule?: number;
                actions?: StocGameMessage.MsgReloadField.Action[];
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("duel_rule" in data && data.duel_rule != undefined) {
                        this.duel_rule = data.duel_rule;
                    }
                    if ("actions" in data && data.actions != undefined) {
                        this.actions = data.actions;
                    }
                }
            }
            get duel_rule() {
                return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
            }
            set duel_rule(value: number) {
                pb_1.Message.setField(this, 1, value);
            }
            get actions() {
                return pb_1.Message.getRepeatedWrapperField(this, StocGameMessage.MsgReloadField.Action, 2) as StocGameMessage.MsgReloadField.Action[];
            }
            set actions(value: StocGameMessage.MsgReloadField.Action[]) {
                pb_1.Message.setRepeatedWrapperField(this, 2, value);
            }
            static fromObject(data: {
                duel_rule?: number;
                actions?: ReturnType<typeof StocGameMessage.MsgReloadField.Action.prototype.toObject>[];
            }): MsgReloadField {
                const message = new MsgReloadField({});
                if (data.duel_rule != null) {
                    message.duel_rule = data.duel_rule;
                }
                if (data.actions != null) {
                    message.actions = data.actions.map(item => StocGameMessage.MsgReloadField.Action.fromObject(item));
                }
                return message;
            }
            toObject() {
                const data: {
                    duel_rule?: number;
                    actions?: ReturnType<typeof StocGameMessage.MsgReloadField.Action.prototype.toObject>[];
                } = {};
                if (this.duel_rule != null) {
                    data.duel_rule = this.duel_rule;
                }
                if (this.actions != null) {
                    data.actions = this.actions.map((item: StocGameMessage.MsgReloadField.Action) => item.toObject());
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.duel_rule != 0)
                    writer.writeInt32(1, this.duel_rule);
                if (this.actions.length)
                    writer.writeRepeatedMessage(2, this.actions, (item: StocGameMessage.MsgReloadField.Action) => item.serialize(writer));
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgReloadField {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgReloadField();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.duel_rule = reader.readInt32();
                            break;
                        case 2:
                            reader.readMessage(message.actions, () => pb_1.Message.addToRepeatedWrapperField(message, 2, StocGameMessage.MsgReloadField.Action.deserialize(reader), StocGameMessage.MsgReloadField.Action));
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): MsgReloadField {
                return MsgReloadField.deserialize(bytes);
            }
        }
        export namespace MsgReloadField {
            export class ZoneAction extends pb_1.Message {
                #one_of_decls: number[][] = [];
                constructor(data?: any[] | {
                    zone?: CardZone;
                    sequence?: number;
                    position?: number;
                    overlay_count?: number;
                }) {
                    super();
                    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                    if (!Array.isArray(data) && typeof data == "object") {
                        if ("zone" in data && data.zone != undefined) {
                            this.zone = data.zone;
                        }
                        if ("sequence" in data && data.sequence != undefined) {
                            this.sequence = data.sequence;
                        }
                        if ("position" in data && data.position != undefined) {
                            this.position = data.position;
                        }
                        if ("overlay_count" in data && data.overlay_count != undefined) {
                            this.overlay_count = data.overlay_count;
                        }
                    }
                }
                get zone() {
                    return pb_1.Message.getFieldWithDefault(this, 1, CardZone.DECK) as CardZone;
                }
                set zone(value: CardZone) {
                    pb_1.Message.setField(this, 1, value);
                }
                get sequence() {
                    return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
                }
                set sequence(value: number) {
                    pb_1.Message.setField(this, 2, value);
                }
                get position() {
                    return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
                }
                set position(value: number) {
                    pb_1.Message.setField(this, 3, value);
                }
                get overlay_count() {
                    return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
                }
                set overlay_count(value: number) {
                    pb_1.Message.setField(this, 4, value);
                }
                static fromObject(data: {
                    zone?: CardZone;
                    sequence?: number;
                    position?: number;
                    overlay_count?: number;
                }): ZoneAction {
                    const message = new ZoneAction({});
                    if (data.zone != null) {
                        message.zone = data.zone;
                    }
                    if (data.sequence != null) {
                        message.sequence = data.sequence;
                    }
                    if (data.position != null) {
                        message.position = data.position;
                    }
                    if (data.overlay_count != null) {
                        message.overlay_count = data.overlay_count;
                    }
                    return message;
                }
                toObject() {
                    const data: {
                        zone?: CardZone;
                        sequence?: number;
                        position?: number;
                        overlay_count?: number;
                    } = {};
                    if (this.zone != null) {
                        data.zone = this.zone;
                    }
                    if (this.sequence != null) {
                        data.sequence = this.sequence;
                    }
                    if (this.position != null) {
                        data.position = this.position;
                    }
                    if (this.overlay_count != null) {
                        data.overlay_count = this.overlay_count;
                    }
                    return data;
                }
                serialize(): Uint8Array;
                serialize(w: pb_1.BinaryWriter): void;
                serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                    const writer = w || new pb_1.BinaryWriter();
                    if (this.zone != CardZone.DECK)
                        writer.writeEnum(1, this.zone);
                    if (this.sequence != 0)
                        writer.writeInt32(2, this.sequence);
                    if (this.position != 0)
                        writer.writeInt32(3, this.position);
                    if (this.overlay_count != 0)
                        writer.writeInt32(4, this.overlay_count);
                    if (!w)
                        return writer.getResultBuffer();
                }
                static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ZoneAction {
                    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ZoneAction();
                    while (reader.nextField()) {
                        if (reader.isEndGroup())
                            break;
                        switch (reader.getFieldNumber()) {
                            case 1:
                                message.zone = reader.readEnum();
                                break;
                            case 2:
                                message.sequence = reader.readInt32();
                                break;
                            case 3:
                                message.position = reader.readInt32();
                                break;
                            case 4:
                                message.overlay_count = reader.readInt32();
                                break;
                            default: reader.skipField();
                        }
                    }
                    return message;
                }
                serializeBinary(): Uint8Array {
                    return this.serialize();
                }
                static deserializeBinary(bytes: Uint8Array): ZoneAction {
                    return ZoneAction.deserialize(bytes);
                }
            }
            export class ChainAction extends pb_1.Message {
                #one_of_decls: number[][] = [];
                constructor(data?: any[] | {
                    chain_code?: number;
                    location?: CardLocation;
                    triggering_controller?: number;
                    triggering_location?: number;
                    triggering_sequence?: number;
                    effect_description?: number;
                }) {
                    super();
                    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                    if (!Array.isArray(data) && typeof data == "object") {
                        if ("chain_code" in data && data.chain_code != undefined) {
                            this.chain_code = data.chain_code;
                        }
                        if ("location" in data && data.location != undefined) {
                            this.location = data.location;
                        }
                        if ("triggering_controller" in data && data.triggering_controller != undefined) {
                            this.triggering_controller = data.triggering_controller;
                        }
                        if ("triggering_location" in data && data.triggering_location != undefined) {
                            this.triggering_location = data.triggering_location;
                        }
                        if ("triggering_sequence" in data && data.triggering_sequence != undefined) {
                            this.triggering_sequence = data.triggering_sequence;
                        }
                        if ("effect_description" in data && data.effect_description != undefined) {
                            this.effect_description = data.effect_description;
                        }
                    }
                }
                get chain_code() {
                    return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
                }
                set chain_code(value: number) {
                    pb_1.Message.setField(this, 1, value);
                }
                get location() {
                    return pb_1.Message.getWrapperField(this, CardLocation, 2) as CardLocation;
                }
                set location(value: CardLocation) {
                    pb_1.Message.setWrapperField(this, 2, value);
                }
                get has_location() {
                    return pb_1.Message.getField(this, 2) != null;
                }
                get triggering_controller() {
                    return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
                }
                set triggering_controller(value: number) {
                    pb_1.Message.setField(this, 3, value);
                }
                get triggering_location() {
                    return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
                }
                set triggering_location(value: number) {
                    pb_1.Message.setField(this, 4, value);
                }
                get triggering_sequence() {
                    return pb_1.Message.getFieldWithDefault(this, 5, 0) as number;
                }
                set triggering_sequence(value: number) {
                    pb_1.Message.setField(this, 5, value);
                }
                get effect_description() {
                    return pb_1.Message.getFieldWithDefault(this, 6, 0) as number;
                }
                set effect_description(value: number) {
                    pb_1.Message.setField(this, 6, value);
                }
                static fromObject(data: {
                    chain_code?: number;
                    location?: ReturnType<typeof CardLocation.prototype.toObject>;
                    triggering_controller?: number;
                    triggering_location?: number;
                    triggering_sequence?: number;
                    effect_description?: number;
                }): ChainAction {
                    const message = new ChainAction({});
                    if (data.chain_code != null) {
                        message.chain_code = data.chain_code;
                    }
                    if (data.location != null) {
                        message.location = CardLocation.fromObject(data.location);
                    }
                    if (data.triggering_controller != null) {
                        message.triggering_controller = data.triggering_controller;
                    }
                    if (data.triggering_location != null) {
                        message.triggering_location = data.triggering_location;
                    }
                    if (data.triggering_sequence != null) {
                        message.triggering_sequence = data.triggering_sequence;
                    }
                    if (data.effect_description != null) {
                        message.effect_description = data.effect_description;
                    }
                    return message;
                }
                toObject() {
                    const data: {
                        chain_code?: number;
                        location?: ReturnType<typeof CardLocation.prototype.toObject>;
                        triggering_controller?: number;
                        triggering_location?: number;
                        triggering_sequence?: number;
                        effect_description?: number;
                    } = {};
                    if (this.chain_code != null) {
                        data.chain_code = this.chain_code;
                    }
                    if (this.location != null) {
                        data.location = this.location.toObject();
                    }
                    if (this.triggering_controller != null) {
                        data.triggering_controller = this.triggering_controller;
                    }
                    if (this.triggering_location != null) {
                        data.triggering_location = this.triggering_location;
                    }
                    if (this.triggering_sequence != null) {
                        data.triggering_sequence = this.triggering_sequence;
                    }
                    if (this.effect_description != null) {
                        data.effect_description = this.effect_description;
                    }
                    return data;
                }
                serialize(): Uint8Array;
                serialize(w: pb_1.BinaryWriter): void;
                serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                    const writer = w || new pb_1.BinaryWriter();
                    if (this.chain_code != 0)
                        writer.writeInt32(1, this.chain_code);
                    if (this.has_location)
                        writer.writeMessage(2, this.location, () => this.location.serialize(writer));
                    if (this.triggering_controller != 0)
                        writer.writeInt32(3, this.triggering_controller);
                    if (this.triggering_location != 0)
                        writer.writeInt32(4, this.triggering_location);
                    if (this.triggering_sequence != 0)
                        writer.writeInt32(5, this.triggering_sequence);
                    if (this.effect_description != 0)
                        writer.writeInt32(6, this.effect_description);
                    if (!w)
                        return writer.getResultBuffer();
                }
                static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ChainAction {
                    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ChainAction();
                    while (reader.nextField()) {
                        if (reader.isEndGroup())
                            break;
                        switch (reader.getFieldNumber()) {
                            case 1:
                                message.chain_code = reader.readInt32();
                                break;
                            case 2:
                                reader.readMessage(message.location, () => message.location = CardLocation.deserialize(reader));
                                break;
                            case 3:
                                message.triggering_controller = reader.readInt32();
                                break;
                            case 4:
                                message.triggering_location = reader.readInt32();
                                break;
                            case 5:
                                message.triggering_sequence = reader.readInt32();
                                break;
                            case 6:
                                message.effect_description = reader.readInt32();
                                break;
                            default: reader.skipField();
                        }
                    }
                    return message;
                }
                serializeBinary(): Uint8Array {
                    return this.serialize();
                }
                static deserializeBinary(bytes: Uint8Array): ChainAction {
                    return ChainAction.deserialize(bytes);
                }
            }
            export class Action extends pb_1.Message {
                #one_of_decls: number[][] = [];
                constructor(data?: any[] | {
                    player?: number;
                    lp?: number;
                    zone_actions?: StocGameMessage.MsgReloadField.ZoneAction[];
                    chain_actions?: StocGameMessage.MsgReloadField.ChainAction[];
                }) {
                    super();
                    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [3, 4], this.#one_of_decls);
                    if (!Array.isArray(data) && typeof data == "object") {
                        if ("player" in data && data.player != undefined) {
                            this.player = data.player;
                        }
                        if ("lp" in data && data.lp != undefined) {
                            this.lp = data.lp;
                        }
                        if ("zone_actions" in data && data.zone_actions != undefined) {
                            this.zone_actions = data.zone_actions;
                        }
                        if ("chain_actions" in data && data.chain_actions != undefined) {
                            this.chain_actions = data.chain_actions;
                        }
                    }
                }
                get player() {
                    return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
                }
                set player(value: number) {
                    pb_1.Message.setField(this, 1, value);
                }
                get lp() {
                    return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
                }
                set lp(value: number) {
                    pb_1.Message.setField(this, 2, value);
                }
                get zone_actions() {
                    return pb_1.Message.getRepeatedWrapperField(this, StocGameMessage.MsgReloadField.ZoneAction, 3) as StocGameMessage.MsgReloadField.ZoneAction[];
                }
                set zone_actions(value: StocGameMessage.MsgReloadField.ZoneAction[]) {
                    pb_1.Message.setRepeatedWrapperField(this, 3, value);
                }
                get chain_actions() {
                    return pb_1.Message.getRepeatedWrapperField(this, StocGameMessage.MsgReloadField.ChainAction, 4) as StocGameMessage.MsgReloadField.ChainAction[];
                }
                set chain_actions(value: StocGameMessage.MsgReloadField.ChainAction[]) {
                    pb_1.Message.setRepeatedWrapperField(this, 4, value);
                }
                static fromObject(data: {
                    player?: number;
                    lp?: number;
                    zone_actions?: ReturnType<typeof StocGameMessage.MsgReloadField.ZoneAction.prototype.toObject>[];
                    chain_actions?: ReturnType<typeof StocGameMessage.MsgReloadField.ChainAction.prototype.toObject>[];
                }): Action {
                    const message = new Action({});
                    if (data.player != null) {
                        message.player = data.player;
                    }
                    if (data.lp != null) {
                        message.lp = data.lp;
                    }
                    if (data.zone_actions != null) {
                        message.zone_actions = data.zone_actions.map(item => StocGameMessage.MsgReloadField.ZoneAction.fromObject(item));
                    }
                    if (data.chain_actions != null) {
                        message.chain_actions = data.chain_actions.map(item => StocGameMessage.MsgReloadField.ChainAction.fromObject(item));
                    }
                    return message;
                }
                toObject() {
                    const data: {
                        player?: number;
                        lp?: number;
                        zone_actions?: ReturnType<typeof StocGameMessage.MsgReloadField.ZoneAction.prototype.toObject>[];
                        chain_actions?: ReturnType<typeof StocGameMessage.MsgReloadField.ChainAction.prototype.toObject>[];
                    } = {};
                    if (this.player != null) {
                        data.player = this.player;
                    }
                    if (this.lp != null) {
                        data.lp = this.lp;
                    }
                    if (this.zone_actions != null) {
                        data.zone_actions = this.zone_actions.map((item: StocGameMessage.MsgReloadField.ZoneAction) => item.toObject());
                    }
                    if (this.chain_actions != null) {
                        data.chain_actions = this.chain_actions.map((item: StocGameMessage.MsgReloadField.ChainAction) => item.toObject());
                    }
                    return data;
                }
                serialize(): Uint8Array;
                serialize(w: pb_1.BinaryWriter): void;
                serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                    const writer = w || new pb_1.BinaryWriter();
                    if (this.player != 0)
                        writer.writeInt32(1, this.player);
                    if (this.lp != 0)
                        writer.writeInt32(2, this.lp);
                    if (this.zone_actions.length)
                        writer.writeRepeatedMessage(3, this.zone_actions, (item: StocGameMessage.MsgReloadField.ZoneAction) => item.serialize(writer));
                    if (this.chain_actions.length)
                        writer.writeRepeatedMessage(4, this.chain_actions, (item: StocGameMessage.MsgReloadField.ChainAction) => item.serialize(writer));
                    if (!w)
                        return writer.getResultBuffer();
                }
                static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Action {
                    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Action();
                    while (reader.nextField()) {
                        if (reader.isEndGroup())
                            break;
                        switch (reader.getFieldNumber()) {
                            case 1:
                                message.player = reader.readInt32();
                                break;
                            case 2:
                                message.lp = reader.readInt32();
                                break;
                            case 3:
                                reader.readMessage(message.zone_actions, () => pb_1.Message.addToRepeatedWrapperField(message, 3, StocGameMessage.MsgReloadField.ZoneAction.deserialize(reader), StocGameMessage.MsgReloadField.ZoneAction));
                                break;
                            case 4:
                                reader.readMessage(message.chain_actions, () => pb_1.Message.addToRepeatedWrapperField(message, 4, StocGameMessage.MsgReloadField.ChainAction.deserialize(reader), StocGameMessage.MsgReloadField.ChainAction));
                                break;
                            default: reader.skipField();
                        }
                    }
                    return message;
                }
                serializeBinary(): Uint8Array {
                    return this.serialize();
                }
                static deserializeBinary(bytes: Uint8Array): Action {
                    return Action.deserialize(bytes);
                }
            }
        }
    }
}
