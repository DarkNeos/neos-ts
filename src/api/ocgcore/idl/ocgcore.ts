/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 3.19.4
 * source: idl/ocgcore.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as pb_1 from "google-protobuf";
export namespace ygopro {
  export enum HandType {
    UNKNOWN = 0,
    SCISSORS = 1,
    ROCK = 2,
    PAPER = 3,
  }
  export enum CardZone {
    DECK = 0,
    HAND = 1,
    MZONE = 2,
    SZONE = 3,
    GRAVE = 4,
    REMOVED = 5,
    EXTRA = 6,
    OVERLAY = 7,
    ONFIELD = 8,
    FZONE = 9,
    PZONE = 10,
  }
  export enum CardPosition {
    FACEUP_ATTACK = 0,
    FACEDOWN_ATTACK = 1,
    FACEUP_DEFENSE = 2,
    FACEDOWN_DEFENSE = 3,
    FACEUP = 4,
    FACEDOWN = 5,
    ATTACK = 6,
    DEFENSE = 7,
  }
  export class CardInfo extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(
      data?:
        | any[]
        | {
            code?: number;
            controler?: number;
            location?: CardZone;
            sequence?: number;
          }
    ) {
      super();
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [],
        this.#one_of_decls
      );
      if (!Array.isArray(data) && typeof data == "object") {
        if ("code" in data && data.code != undefined) {
          this.code = data.code;
        }
        if ("controler" in data && data.controler != undefined) {
          this.controler = data.controler;
        }
        if ("location" in data && data.location != undefined) {
          this.location = data.location;
        }
        if ("sequence" in data && data.sequence != undefined) {
          this.sequence = data.sequence;
        }
      }
    }
    get code() {
      return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
    }
    set code(value: number) {
      pb_1.Message.setField(this, 1, value);
    }
    get controler() {
      return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
    }
    set controler(value: number) {
      pb_1.Message.setField(this, 2, value);
    }
    get location() {
      return pb_1.Message.getFieldWithDefault(
        this,
        3,
        CardZone.DECK
      ) as CardZone;
    }
    set location(value: CardZone) {
      pb_1.Message.setField(this, 3, value);
    }
    get sequence() {
      return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
    }
    set sequence(value: number) {
      pb_1.Message.setField(this, 4, value);
    }
    static fromObject(data: {
      code?: number;
      controler?: number;
      location?: CardZone;
      sequence?: number;
    }): CardInfo {
      const message = new CardInfo({});
      if (data.code != null) {
        message.code = data.code;
      }
      if (data.controler != null) {
        message.controler = data.controler;
      }
      if (data.location != null) {
        message.location = data.location;
      }
      if (data.sequence != null) {
        message.sequence = data.sequence;
      }
      return message;
    }
    toObject() {
      const data: {
        code?: number;
        controler?: number;
        location?: CardZone;
        sequence?: number;
      } = {};
      if (this.code != null) {
        data.code = this.code;
      }
      if (this.controler != null) {
        data.controler = this.controler;
      }
      if (this.location != null) {
        data.location = this.location;
      }
      if (this.sequence != null) {
        data.sequence = this.sequence;
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.code != 0) writer.writeInt32(1, this.code);
      if (this.controler != 0) writer.writeInt32(2, this.controler);
      if (this.location != CardZone.DECK) writer.writeEnum(3, this.location);
      if (this.sequence != 0) writer.writeInt32(4, this.sequence);
      if (!w) return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): CardInfo {
      const reader =
          bytes instanceof pb_1.BinaryReader
            ? bytes
            : new pb_1.BinaryReader(bytes),
        message = new CardInfo();
      while (reader.nextField()) {
        if (reader.isEndGroup()) break;
        switch (reader.getFieldNumber()) {
          case 1:
            message.code = reader.readInt32();
            break;
          case 2:
            message.controler = reader.readInt32();
            break;
          case 3:
            message.location = reader.readEnum();
            break;
          case 4:
            message.sequence = reader.readInt32();
            break;
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): CardInfo {
      return CardInfo.deserialize(bytes);
    }
  }
  export class CardLocation extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(
      data?:
        | any[]
        | {
            controler?: number;
            location?: CardZone;
            sequence?: number;
            position?: CardPosition;
            overlay_sequence?: number;
          }
    ) {
      super();
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [],
        this.#one_of_decls
      );
      if (!Array.isArray(data) && typeof data == "object") {
        if ("controler" in data && data.controler != undefined) {
          this.controler = data.controler;
        }
        if ("location" in data && data.location != undefined) {
          this.location = data.location;
        }
        if ("sequence" in data && data.sequence != undefined) {
          this.sequence = data.sequence;
        }
        if ("position" in data && data.position != undefined) {
          this.position = data.position;
        }
        if ("overlay_sequence" in data && data.overlay_sequence != undefined) {
          this.overlay_sequence = data.overlay_sequence;
        }
      }
    }
    get controler() {
      return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
    }
    set controler(value: number) {
      pb_1.Message.setField(this, 1, value);
    }
    get location() {
      return pb_1.Message.getFieldWithDefault(
        this,
        2,
        CardZone.DECK
      ) as CardZone;
    }
    set location(value: CardZone) {
      pb_1.Message.setField(this, 2, value);
    }
    get sequence() {
      return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
    }
    set sequence(value: number) {
      pb_1.Message.setField(this, 3, value);
    }
    get position() {
      return pb_1.Message.getFieldWithDefault(
        this,
        4,
        CardPosition.FACEUP_ATTACK
      ) as CardPosition;
    }
    set position(value: CardPosition) {
      pb_1.Message.setField(this, 4, value);
    }
    get overlay_sequence() {
      return pb_1.Message.getFieldWithDefault(this, 5, 0) as number;
    }
    set overlay_sequence(value: number) {
      pb_1.Message.setField(this, 5, value);
    }
    static fromObject(data: {
      controler?: number;
      location?: CardZone;
      sequence?: number;
      position?: CardPosition;
      overlay_sequence?: number;
    }): CardLocation {
      const message = new CardLocation({});
      if (data.controler != null) {
        message.controler = data.controler;
      }
      if (data.location != null) {
        message.location = data.location;
      }
      if (data.sequence != null) {
        message.sequence = data.sequence;
      }
      if (data.position != null) {
        message.position = data.position;
      }
      if (data.overlay_sequence != null) {
        message.overlay_sequence = data.overlay_sequence;
      }
      return message;
    }
    toObject() {
      const data: {
        controler?: number;
        location?: CardZone;
        sequence?: number;
        position?: CardPosition;
        overlay_sequence?: number;
      } = {};
      if (this.controler != null) {
        data.controler = this.controler;
      }
      if (this.location != null) {
        data.location = this.location;
      }
      if (this.sequence != null) {
        data.sequence = this.sequence;
      }
      if (this.position != null) {
        data.position = this.position;
      }
      if (this.overlay_sequence != null) {
        data.overlay_sequence = this.overlay_sequence;
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.controler != 0) writer.writeInt32(1, this.controler);
      if (this.location != CardZone.DECK) writer.writeEnum(2, this.location);
      if (this.sequence != 0) writer.writeInt32(3, this.sequence);
      if (this.position != CardPosition.FACEUP_ATTACK)
        writer.writeEnum(4, this.position);
      if (this.overlay_sequence != 0)
        writer.writeInt32(5, this.overlay_sequence);
      if (!w) return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): CardLocation {
      const reader =
          bytes instanceof pb_1.BinaryReader
            ? bytes
            : new pb_1.BinaryReader(bytes),
        message = new CardLocation();
      while (reader.nextField()) {
        if (reader.isEndGroup()) break;
        switch (reader.getFieldNumber()) {
          case 1:
            message.controler = reader.readInt32();
            break;
          case 2:
            message.location = reader.readEnum();
            break;
          case 3:
            message.sequence = reader.readInt32();
            break;
          case 4:
            message.position = reader.readEnum();
            break;
          case 5:
            message.overlay_sequence = reader.readInt32();
            break;
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): CardLocation {
      return CardLocation.deserialize(bytes);
    }
  }
  export class YgoCtosMsg extends pb_1.Message {
    #one_of_decls: number[][] = [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]];
    constructor(
      data?:
        | any[]
        | ({} & (
            | {
                ctos_player_info?: CtosPlayerInfo;
                ctos_join_game?: never;
                ctos_update_deck?: never;
                ctos_hs_ready?: never;
                ctos_hs_start?: never;
                ctos_hs_not_ready?: never;
                ctos_hand_result?: never;
                ctos_tp_result?: never;
                ctos_time_confirm?: never;
                ctos_response?: never;
              }
            | {
                ctos_player_info?: never;
                ctos_join_game?: CtosJoinGame;
                ctos_update_deck?: never;
                ctos_hs_ready?: never;
                ctos_hs_start?: never;
                ctos_hs_not_ready?: never;
                ctos_hand_result?: never;
                ctos_tp_result?: never;
                ctos_time_confirm?: never;
                ctos_response?: never;
              }
            | {
                ctos_player_info?: never;
                ctos_join_game?: never;
                ctos_update_deck?: CtosUpdateDeck;
                ctos_hs_ready?: never;
                ctos_hs_start?: never;
                ctos_hs_not_ready?: never;
                ctos_hand_result?: never;
                ctos_tp_result?: never;
                ctos_time_confirm?: never;
                ctos_response?: never;
              }
            | {
                ctos_player_info?: never;
                ctos_join_game?: never;
                ctos_update_deck?: never;
                ctos_hs_ready?: CtosHsReady;
                ctos_hs_start?: never;
                ctos_hs_not_ready?: never;
                ctos_hand_result?: never;
                ctos_tp_result?: never;
                ctos_time_confirm?: never;
                ctos_response?: never;
              }
            | {
                ctos_player_info?: never;
                ctos_join_game?: never;
                ctos_update_deck?: never;
                ctos_hs_ready?: never;
                ctos_hs_start?: CtosHsStart;
                ctos_hs_not_ready?: never;
                ctos_hand_result?: never;
                ctos_tp_result?: never;
                ctos_time_confirm?: never;
                ctos_response?: never;
              }
            | {
                ctos_player_info?: never;
                ctos_join_game?: never;
                ctos_update_deck?: never;
                ctos_hs_ready?: never;
                ctos_hs_start?: never;
                ctos_hs_not_ready?: CtosHsNotReady;
                ctos_hand_result?: never;
                ctos_tp_result?: never;
                ctos_time_confirm?: never;
                ctos_response?: never;
              }
            | {
                ctos_player_info?: never;
                ctos_join_game?: never;
                ctos_update_deck?: never;
                ctos_hs_ready?: never;
                ctos_hs_start?: never;
                ctos_hs_not_ready?: never;
                ctos_hand_result?: CtosHandResult;
                ctos_tp_result?: never;
                ctos_time_confirm?: never;
                ctos_response?: never;
              }
            | {
                ctos_player_info?: never;
                ctos_join_game?: never;
                ctos_update_deck?: never;
                ctos_hs_ready?: never;
                ctos_hs_start?: never;
                ctos_hs_not_ready?: never;
                ctos_hand_result?: never;
                ctos_tp_result?: CtosTpResult;
                ctos_time_confirm?: never;
                ctos_response?: never;
              }
            | {
                ctos_player_info?: never;
                ctos_join_game?: never;
                ctos_update_deck?: never;
                ctos_hs_ready?: never;
                ctos_hs_start?: never;
                ctos_hs_not_ready?: never;
                ctos_hand_result?: never;
                ctos_tp_result?: never;
                ctos_time_confirm?: CtosTimeConfirm;
                ctos_response?: never;
              }
            | {
                ctos_player_info?: never;
                ctos_join_game?: never;
                ctos_update_deck?: never;
                ctos_hs_ready?: never;
                ctos_hs_start?: never;
                ctos_hs_not_ready?: never;
                ctos_hand_result?: never;
                ctos_tp_result?: never;
                ctos_time_confirm?: never;
                ctos_response?: CtosGameMsgResponse;
              }
          ))
    ) {
      super();
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [],
        this.#one_of_decls
      );
      if (!Array.isArray(data) && typeof data == "object") {
        if ("ctos_player_info" in data && data.ctos_player_info != undefined) {
          this.ctos_player_info = data.ctos_player_info;
        }
        if ("ctos_join_game" in data && data.ctos_join_game != undefined) {
          this.ctos_join_game = data.ctos_join_game;
        }
        if ("ctos_update_deck" in data && data.ctos_update_deck != undefined) {
          this.ctos_update_deck = data.ctos_update_deck;
        }
        if ("ctos_hs_ready" in data && data.ctos_hs_ready != undefined) {
          this.ctos_hs_ready = data.ctos_hs_ready;
        }
        if ("ctos_hs_start" in data && data.ctos_hs_start != undefined) {
          this.ctos_hs_start = data.ctos_hs_start;
        }
        if (
          "ctos_hs_not_ready" in data &&
          data.ctos_hs_not_ready != undefined
        ) {
          this.ctos_hs_not_ready = data.ctos_hs_not_ready;
        }
        if ("ctos_hand_result" in data && data.ctos_hand_result != undefined) {
          this.ctos_hand_result = data.ctos_hand_result;
        }
        if ("ctos_tp_result" in data && data.ctos_tp_result != undefined) {
          this.ctos_tp_result = data.ctos_tp_result;
        }
        if (
          "ctos_time_confirm" in data &&
          data.ctos_time_confirm != undefined
        ) {
          this.ctos_time_confirm = data.ctos_time_confirm;
        }
        if ("ctos_response" in data && data.ctos_response != undefined) {
          this.ctos_response = data.ctos_response;
        }
      }
    }
    get ctos_player_info() {
      return pb_1.Message.getWrapperField(
        this,
        CtosPlayerInfo,
        1
      ) as CtosPlayerInfo;
    }
    set ctos_player_info(value: CtosPlayerInfo) {
      pb_1.Message.setOneofWrapperField(this, 1, this.#one_of_decls[0], value);
    }
    get has_ctos_player_info() {
      return pb_1.Message.getField(this, 1) != null;
    }
    get ctos_join_game() {
      return pb_1.Message.getWrapperField(
        this,
        CtosJoinGame,
        2
      ) as CtosJoinGame;
    }
    set ctos_join_game(value: CtosJoinGame) {
      pb_1.Message.setOneofWrapperField(this, 2, this.#one_of_decls[0], value);
    }
    get has_ctos_join_game() {
      return pb_1.Message.getField(this, 2) != null;
    }
    get ctos_update_deck() {
      return pb_1.Message.getWrapperField(
        this,
        CtosUpdateDeck,
        3
      ) as CtosUpdateDeck;
    }
    set ctos_update_deck(value: CtosUpdateDeck) {
      pb_1.Message.setOneofWrapperField(this, 3, this.#one_of_decls[0], value);
    }
    get has_ctos_update_deck() {
      return pb_1.Message.getField(this, 3) != null;
    }
    get ctos_hs_ready() {
      return pb_1.Message.getWrapperField(this, CtosHsReady, 4) as CtosHsReady;
    }
    set ctos_hs_ready(value: CtosHsReady) {
      pb_1.Message.setOneofWrapperField(this, 4, this.#one_of_decls[0], value);
    }
    get has_ctos_hs_ready() {
      return pb_1.Message.getField(this, 4) != null;
    }
    get ctos_hs_start() {
      return pb_1.Message.getWrapperField(this, CtosHsStart, 5) as CtosHsStart;
    }
    set ctos_hs_start(value: CtosHsStart) {
      pb_1.Message.setOneofWrapperField(this, 5, this.#one_of_decls[0], value);
    }
    get has_ctos_hs_start() {
      return pb_1.Message.getField(this, 5) != null;
    }
    get ctos_hs_not_ready() {
      return pb_1.Message.getWrapperField(
        this,
        CtosHsNotReady,
        6
      ) as CtosHsNotReady;
    }
    set ctos_hs_not_ready(value: CtosHsNotReady) {
      pb_1.Message.setOneofWrapperField(this, 6, this.#one_of_decls[0], value);
    }
    get has_ctos_hs_not_ready() {
      return pb_1.Message.getField(this, 6) != null;
    }
    get ctos_hand_result() {
      return pb_1.Message.getWrapperField(
        this,
        CtosHandResult,
        7
      ) as CtosHandResult;
    }
    set ctos_hand_result(value: CtosHandResult) {
      pb_1.Message.setOneofWrapperField(this, 7, this.#one_of_decls[0], value);
    }
    get has_ctos_hand_result() {
      return pb_1.Message.getField(this, 7) != null;
    }
    get ctos_tp_result() {
      return pb_1.Message.getWrapperField(
        this,
        CtosTpResult,
        8
      ) as CtosTpResult;
    }
    set ctos_tp_result(value: CtosTpResult) {
      pb_1.Message.setOneofWrapperField(this, 8, this.#one_of_decls[0], value);
    }
    get has_ctos_tp_result() {
      return pb_1.Message.getField(this, 8) != null;
    }
    get ctos_time_confirm() {
      return pb_1.Message.getWrapperField(
        this,
        CtosTimeConfirm,
        9
      ) as CtosTimeConfirm;
    }
    set ctos_time_confirm(value: CtosTimeConfirm) {
      pb_1.Message.setOneofWrapperField(this, 9, this.#one_of_decls[0], value);
    }
    get has_ctos_time_confirm() {
      return pb_1.Message.getField(this, 9) != null;
    }
    get ctos_response() {
      return pb_1.Message.getWrapperField(
        this,
        CtosGameMsgResponse,
        10
      ) as CtosGameMsgResponse;
    }
    set ctos_response(value: CtosGameMsgResponse) {
      pb_1.Message.setOneofWrapperField(this, 10, this.#one_of_decls[0], value);
    }
    get has_ctos_response() {
      return pb_1.Message.getField(this, 10) != null;
    }
    get msg() {
      const cases: {
        [index: number]:
          | "none"
          | "ctos_player_info"
          | "ctos_join_game"
          | "ctos_update_deck"
          | "ctos_hs_ready"
          | "ctos_hs_start"
          | "ctos_hs_not_ready"
          | "ctos_hand_result"
          | "ctos_tp_result"
          | "ctos_time_confirm"
          | "ctos_response";
      } = {
        0: "none",
        1: "ctos_player_info",
        2: "ctos_join_game",
        3: "ctos_update_deck",
        4: "ctos_hs_ready",
        5: "ctos_hs_start",
        6: "ctos_hs_not_ready",
        7: "ctos_hand_result",
        8: "ctos_tp_result",
        9: "ctos_time_confirm",
        10: "ctos_response",
      };
      return cases[
        pb_1.Message.computeOneofCase(this, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
      ];
    }
    static fromObject(data: {
      ctos_player_info?: ReturnType<typeof CtosPlayerInfo.prototype.toObject>;
      ctos_join_game?: ReturnType<typeof CtosJoinGame.prototype.toObject>;
      ctos_update_deck?: ReturnType<typeof CtosUpdateDeck.prototype.toObject>;
      ctos_hs_ready?: ReturnType<typeof CtosHsReady.prototype.toObject>;
      ctos_hs_start?: ReturnType<typeof CtosHsStart.prototype.toObject>;
      ctos_hs_not_ready?: ReturnType<typeof CtosHsNotReady.prototype.toObject>;
      ctos_hand_result?: ReturnType<typeof CtosHandResult.prototype.toObject>;
      ctos_tp_result?: ReturnType<typeof CtosTpResult.prototype.toObject>;
      ctos_time_confirm?: ReturnType<typeof CtosTimeConfirm.prototype.toObject>;
      ctos_response?: ReturnType<typeof CtosGameMsgResponse.prototype.toObject>;
    }): YgoCtosMsg {
      const message = new YgoCtosMsg({});
      if (data.ctos_player_info != null) {
        message.ctos_player_info = CtosPlayerInfo.fromObject(
          data.ctos_player_info
        );
      }
      if (data.ctos_join_game != null) {
        message.ctos_join_game = CtosJoinGame.fromObject(data.ctos_join_game);
      }
      if (data.ctos_update_deck != null) {
        message.ctos_update_deck = CtosUpdateDeck.fromObject(
          data.ctos_update_deck
        );
      }
      if (data.ctos_hs_ready != null) {
        message.ctos_hs_ready = CtosHsReady.fromObject(data.ctos_hs_ready);
      }
      if (data.ctos_hs_start != null) {
        message.ctos_hs_start = CtosHsStart.fromObject(data.ctos_hs_start);
      }
      if (data.ctos_hs_not_ready != null) {
        message.ctos_hs_not_ready = CtosHsNotReady.fromObject(
          data.ctos_hs_not_ready
        );
      }
      if (data.ctos_hand_result != null) {
        message.ctos_hand_result = CtosHandResult.fromObject(
          data.ctos_hand_result
        );
      }
      if (data.ctos_tp_result != null) {
        message.ctos_tp_result = CtosTpResult.fromObject(data.ctos_tp_result);
      }
      if (data.ctos_time_confirm != null) {
        message.ctos_time_confirm = CtosTimeConfirm.fromObject(
          data.ctos_time_confirm
        );
      }
      if (data.ctos_response != null) {
        message.ctos_response = CtosGameMsgResponse.fromObject(
          data.ctos_response
        );
      }
      return message;
    }
    toObject() {
      const data: {
        ctos_player_info?: ReturnType<typeof CtosPlayerInfo.prototype.toObject>;
        ctos_join_game?: ReturnType<typeof CtosJoinGame.prototype.toObject>;
        ctos_update_deck?: ReturnType<typeof CtosUpdateDeck.prototype.toObject>;
        ctos_hs_ready?: ReturnType<typeof CtosHsReady.prototype.toObject>;
        ctos_hs_start?: ReturnType<typeof CtosHsStart.prototype.toObject>;
        ctos_hs_not_ready?: ReturnType<
          typeof CtosHsNotReady.prototype.toObject
        >;
        ctos_hand_result?: ReturnType<typeof CtosHandResult.prototype.toObject>;
        ctos_tp_result?: ReturnType<typeof CtosTpResult.prototype.toObject>;
        ctos_time_confirm?: ReturnType<
          typeof CtosTimeConfirm.prototype.toObject
        >;
        ctos_response?: ReturnType<
          typeof CtosGameMsgResponse.prototype.toObject
        >;
      } = {};
      if (this.ctos_player_info != null) {
        data.ctos_player_info = this.ctos_player_info.toObject();
      }
      if (this.ctos_join_game != null) {
        data.ctos_join_game = this.ctos_join_game.toObject();
      }
      if (this.ctos_update_deck != null) {
        data.ctos_update_deck = this.ctos_update_deck.toObject();
      }
      if (this.ctos_hs_ready != null) {
        data.ctos_hs_ready = this.ctos_hs_ready.toObject();
      }
      if (this.ctos_hs_start != null) {
        data.ctos_hs_start = this.ctos_hs_start.toObject();
      }
      if (this.ctos_hs_not_ready != null) {
        data.ctos_hs_not_ready = this.ctos_hs_not_ready.toObject();
      }
      if (this.ctos_hand_result != null) {
        data.ctos_hand_result = this.ctos_hand_result.toObject();
      }
      if (this.ctos_tp_result != null) {
        data.ctos_tp_result = this.ctos_tp_result.toObject();
      }
      if (this.ctos_time_confirm != null) {
        data.ctos_time_confirm = this.ctos_time_confirm.toObject();
      }
      if (this.ctos_response != null) {
        data.ctos_response = this.ctos_response.toObject();
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.has_ctos_player_info)
        writer.writeMessage(1, this.ctos_player_info, () =>
          this.ctos_player_info.serialize(writer)
        );
      if (this.has_ctos_join_game)
        writer.writeMessage(2, this.ctos_join_game, () =>
          this.ctos_join_game.serialize(writer)
        );
      if (this.has_ctos_update_deck)
        writer.writeMessage(3, this.ctos_update_deck, () =>
          this.ctos_update_deck.serialize(writer)
        );
      if (this.has_ctos_hs_ready)
        writer.writeMessage(4, this.ctos_hs_ready, () =>
          this.ctos_hs_ready.serialize(writer)
        );
      if (this.has_ctos_hs_start)
        writer.writeMessage(5, this.ctos_hs_start, () =>
          this.ctos_hs_start.serialize(writer)
        );
      if (this.has_ctos_hs_not_ready)
        writer.writeMessage(6, this.ctos_hs_not_ready, () =>
          this.ctos_hs_not_ready.serialize(writer)
        );
      if (this.has_ctos_hand_result)
        writer.writeMessage(7, this.ctos_hand_result, () =>
          this.ctos_hand_result.serialize(writer)
        );
      if (this.has_ctos_tp_result)
        writer.writeMessage(8, this.ctos_tp_result, () =>
          this.ctos_tp_result.serialize(writer)
        );
      if (this.has_ctos_time_confirm)
        writer.writeMessage(9, this.ctos_time_confirm, () =>
          this.ctos_time_confirm.serialize(writer)
        );
      if (this.has_ctos_response)
        writer.writeMessage(10, this.ctos_response, () =>
          this.ctos_response.serialize(writer)
        );
      if (!w) return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): YgoCtosMsg {
      const reader =
          bytes instanceof pb_1.BinaryReader
            ? bytes
            : new pb_1.BinaryReader(bytes),
        message = new YgoCtosMsg();
      while (reader.nextField()) {
        if (reader.isEndGroup()) break;
        switch (reader.getFieldNumber()) {
          case 1:
            reader.readMessage(
              message.ctos_player_info,
              () =>
                (message.ctos_player_info = CtosPlayerInfo.deserialize(reader))
            );
            break;
          case 2:
            reader.readMessage(
              message.ctos_join_game,
              () => (message.ctos_join_game = CtosJoinGame.deserialize(reader))
            );
            break;
          case 3:
            reader.readMessage(
              message.ctos_update_deck,
              () =>
                (message.ctos_update_deck = CtosUpdateDeck.deserialize(reader))
            );
            break;
          case 4:
            reader.readMessage(
              message.ctos_hs_ready,
              () => (message.ctos_hs_ready = CtosHsReady.deserialize(reader))
            );
            break;
          case 5:
            reader.readMessage(
              message.ctos_hs_start,
              () => (message.ctos_hs_start = CtosHsStart.deserialize(reader))
            );
            break;
          case 6:
            reader.readMessage(
              message.ctos_hs_not_ready,
              () =>
                (message.ctos_hs_not_ready = CtosHsNotReady.deserialize(reader))
            );
            break;
          case 7:
            reader.readMessage(
              message.ctos_hand_result,
              () =>
                (message.ctos_hand_result = CtosHandResult.deserialize(reader))
            );
            break;
          case 8:
            reader.readMessage(
              message.ctos_tp_result,
              () => (message.ctos_tp_result = CtosTpResult.deserialize(reader))
            );
            break;
          case 9:
            reader.readMessage(
              message.ctos_time_confirm,
              () =>
                (message.ctos_time_confirm =
                  CtosTimeConfirm.deserialize(reader))
            );
            break;
          case 10:
            reader.readMessage(
              message.ctos_response,
              () =>
                (message.ctos_response =
                  CtosGameMsgResponse.deserialize(reader))
            );
            break;
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): YgoCtosMsg {
      return YgoCtosMsg.deserialize(bytes);
    }
  }
  export class YgoStocMsg extends pb_1.Message {
    #one_of_decls: number[][] = [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]];
    constructor(
      data?:
        | any[]
        | ({} & (
            | {
                stoc_join_game?: StocJoinGame;
                stoc_chat?: never;
                stoc_hs_player_enter?: never;
                stoc_type_change?: never;
                stoc_hs_player_change?: never;
                stoc_hs_watch_change?: never;
                stoc_select_hand?: never;
                stoc_hand_result?: never;
                stoc_select_tp?: never;
                stoc_deck_count?: never;
                stoc_duel_start?: never;
                stoc_game_msg?: never;
                stoc_time_limit?: never;
              }
            | {
                stoc_join_game?: never;
                stoc_chat?: StocChat;
                stoc_hs_player_enter?: never;
                stoc_type_change?: never;
                stoc_hs_player_change?: never;
                stoc_hs_watch_change?: never;
                stoc_select_hand?: never;
                stoc_hand_result?: never;
                stoc_select_tp?: never;
                stoc_deck_count?: never;
                stoc_duel_start?: never;
                stoc_game_msg?: never;
                stoc_time_limit?: never;
              }
            | {
                stoc_join_game?: never;
                stoc_chat?: never;
                stoc_hs_player_enter?: StocHsPlayerEnter;
                stoc_type_change?: never;
                stoc_hs_player_change?: never;
                stoc_hs_watch_change?: never;
                stoc_select_hand?: never;
                stoc_hand_result?: never;
                stoc_select_tp?: never;
                stoc_deck_count?: never;
                stoc_duel_start?: never;
                stoc_game_msg?: never;
                stoc_time_limit?: never;
              }
            | {
                stoc_join_game?: never;
                stoc_chat?: never;
                stoc_hs_player_enter?: never;
                stoc_type_change?: StocTypeChange;
                stoc_hs_player_change?: never;
                stoc_hs_watch_change?: never;
                stoc_select_hand?: never;
                stoc_hand_result?: never;
                stoc_select_tp?: never;
                stoc_deck_count?: never;
                stoc_duel_start?: never;
                stoc_game_msg?: never;
                stoc_time_limit?: never;
              }
            | {
                stoc_join_game?: never;
                stoc_chat?: never;
                stoc_hs_player_enter?: never;
                stoc_type_change?: never;
                stoc_hs_player_change?: StocHsPlayerChange;
                stoc_hs_watch_change?: never;
                stoc_select_hand?: never;
                stoc_hand_result?: never;
                stoc_select_tp?: never;
                stoc_deck_count?: never;
                stoc_duel_start?: never;
                stoc_game_msg?: never;
                stoc_time_limit?: never;
              }
            | {
                stoc_join_game?: never;
                stoc_chat?: never;
                stoc_hs_player_enter?: never;
                stoc_type_change?: never;
                stoc_hs_player_change?: never;
                stoc_hs_watch_change?: StocHsWatchChange;
                stoc_select_hand?: never;
                stoc_hand_result?: never;
                stoc_select_tp?: never;
                stoc_deck_count?: never;
                stoc_duel_start?: never;
                stoc_game_msg?: never;
                stoc_time_limit?: never;
              }
            | {
                stoc_join_game?: never;
                stoc_chat?: never;
                stoc_hs_player_enter?: never;
                stoc_type_change?: never;
                stoc_hs_player_change?: never;
                stoc_hs_watch_change?: never;
                stoc_select_hand?: StocSelectHand;
                stoc_hand_result?: never;
                stoc_select_tp?: never;
                stoc_deck_count?: never;
                stoc_duel_start?: never;
                stoc_game_msg?: never;
                stoc_time_limit?: never;
              }
            | {
                stoc_join_game?: never;
                stoc_chat?: never;
                stoc_hs_player_enter?: never;
                stoc_type_change?: never;
                stoc_hs_player_change?: never;
                stoc_hs_watch_change?: never;
                stoc_select_hand?: never;
                stoc_hand_result?: StocHandResult;
                stoc_select_tp?: never;
                stoc_deck_count?: never;
                stoc_duel_start?: never;
                stoc_game_msg?: never;
                stoc_time_limit?: never;
              }
            | {
                stoc_join_game?: never;
                stoc_chat?: never;
                stoc_hs_player_enter?: never;
                stoc_type_change?: never;
                stoc_hs_player_change?: never;
                stoc_hs_watch_change?: never;
                stoc_select_hand?: never;
                stoc_hand_result?: never;
                stoc_select_tp?: StocSelectTp;
                stoc_deck_count?: never;
                stoc_duel_start?: never;
                stoc_game_msg?: never;
                stoc_time_limit?: never;
              }
            | {
                stoc_join_game?: never;
                stoc_chat?: never;
                stoc_hs_player_enter?: never;
                stoc_type_change?: never;
                stoc_hs_player_change?: never;
                stoc_hs_watch_change?: never;
                stoc_select_hand?: never;
                stoc_hand_result?: never;
                stoc_select_tp?: never;
                stoc_deck_count?: StocDeckCount;
                stoc_duel_start?: never;
                stoc_game_msg?: never;
                stoc_time_limit?: never;
              }
            | {
                stoc_join_game?: never;
                stoc_chat?: never;
                stoc_hs_player_enter?: never;
                stoc_type_change?: never;
                stoc_hs_player_change?: never;
                stoc_hs_watch_change?: never;
                stoc_select_hand?: never;
                stoc_hand_result?: never;
                stoc_select_tp?: never;
                stoc_deck_count?: never;
                stoc_duel_start?: StocDuelStart;
                stoc_game_msg?: never;
                stoc_time_limit?: never;
              }
            | {
                stoc_join_game?: never;
                stoc_chat?: never;
                stoc_hs_player_enter?: never;
                stoc_type_change?: never;
                stoc_hs_player_change?: never;
                stoc_hs_watch_change?: never;
                stoc_select_hand?: never;
                stoc_hand_result?: never;
                stoc_select_tp?: never;
                stoc_deck_count?: never;
                stoc_duel_start?: never;
                stoc_game_msg?: StocGameMessage;
                stoc_time_limit?: never;
              }
            | {
                stoc_join_game?: never;
                stoc_chat?: never;
                stoc_hs_player_enter?: never;
                stoc_type_change?: never;
                stoc_hs_player_change?: never;
                stoc_hs_watch_change?: never;
                stoc_select_hand?: never;
                stoc_hand_result?: never;
                stoc_select_tp?: never;
                stoc_deck_count?: never;
                stoc_duel_start?: never;
                stoc_game_msg?: never;
                stoc_time_limit?: StocTimeLimit;
              }
          ))
    ) {
      super();
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [],
        this.#one_of_decls
      );
      if (!Array.isArray(data) && typeof data == "object") {
        if ("stoc_join_game" in data && data.stoc_join_game != undefined) {
          this.stoc_join_game = data.stoc_join_game;
        }
        if ("stoc_chat" in data && data.stoc_chat != undefined) {
          this.stoc_chat = data.stoc_chat;
        }
        if (
          "stoc_hs_player_enter" in data &&
          data.stoc_hs_player_enter != undefined
        ) {
          this.stoc_hs_player_enter = data.stoc_hs_player_enter;
        }
        if ("stoc_type_change" in data && data.stoc_type_change != undefined) {
          this.stoc_type_change = data.stoc_type_change;
        }
        if (
          "stoc_hs_player_change" in data &&
          data.stoc_hs_player_change != undefined
        ) {
          this.stoc_hs_player_change = data.stoc_hs_player_change;
        }
        if (
          "stoc_hs_watch_change" in data &&
          data.stoc_hs_watch_change != undefined
        ) {
          this.stoc_hs_watch_change = data.stoc_hs_watch_change;
        }
        if ("stoc_select_hand" in data && data.stoc_select_hand != undefined) {
          this.stoc_select_hand = data.stoc_select_hand;
        }
        if ("stoc_hand_result" in data && data.stoc_hand_result != undefined) {
          this.stoc_hand_result = data.stoc_hand_result;
        }
        if ("stoc_select_tp" in data && data.stoc_select_tp != undefined) {
          this.stoc_select_tp = data.stoc_select_tp;
        }
        if ("stoc_deck_count" in data && data.stoc_deck_count != undefined) {
          this.stoc_deck_count = data.stoc_deck_count;
        }
        if ("stoc_duel_start" in data && data.stoc_duel_start != undefined) {
          this.stoc_duel_start = data.stoc_duel_start;
        }
        if ("stoc_game_msg" in data && data.stoc_game_msg != undefined) {
          this.stoc_game_msg = data.stoc_game_msg;
        }
        if ("stoc_time_limit" in data && data.stoc_time_limit != undefined) {
          this.stoc_time_limit = data.stoc_time_limit;
        }
      }
    }
    get stoc_join_game() {
      return pb_1.Message.getWrapperField(
        this,
        StocJoinGame,
        1
      ) as StocJoinGame;
    }
    set stoc_join_game(value: StocJoinGame) {
      pb_1.Message.setOneofWrapperField(this, 1, this.#one_of_decls[0], value);
    }
    get has_stoc_join_game() {
      return pb_1.Message.getField(this, 1) != null;
    }
    get stoc_chat() {
      return pb_1.Message.getWrapperField(this, StocChat, 2) as StocChat;
    }
    set stoc_chat(value: StocChat) {
      pb_1.Message.setOneofWrapperField(this, 2, this.#one_of_decls[0], value);
    }
    get has_stoc_chat() {
      return pb_1.Message.getField(this, 2) != null;
    }
    get stoc_hs_player_enter() {
      return pb_1.Message.getWrapperField(
        this,
        StocHsPlayerEnter,
        3
      ) as StocHsPlayerEnter;
    }
    set stoc_hs_player_enter(value: StocHsPlayerEnter) {
      pb_1.Message.setOneofWrapperField(this, 3, this.#one_of_decls[0], value);
    }
    get has_stoc_hs_player_enter() {
      return pb_1.Message.getField(this, 3) != null;
    }
    get stoc_type_change() {
      return pb_1.Message.getWrapperField(
        this,
        StocTypeChange,
        4
      ) as StocTypeChange;
    }
    set stoc_type_change(value: StocTypeChange) {
      pb_1.Message.setOneofWrapperField(this, 4, this.#one_of_decls[0], value);
    }
    get has_stoc_type_change() {
      return pb_1.Message.getField(this, 4) != null;
    }
    get stoc_hs_player_change() {
      return pb_1.Message.getWrapperField(
        this,
        StocHsPlayerChange,
        5
      ) as StocHsPlayerChange;
    }
    set stoc_hs_player_change(value: StocHsPlayerChange) {
      pb_1.Message.setOneofWrapperField(this, 5, this.#one_of_decls[0], value);
    }
    get has_stoc_hs_player_change() {
      return pb_1.Message.getField(this, 5) != null;
    }
    get stoc_hs_watch_change() {
      return pb_1.Message.getWrapperField(
        this,
        StocHsWatchChange,
        6
      ) as StocHsWatchChange;
    }
    set stoc_hs_watch_change(value: StocHsWatchChange) {
      pb_1.Message.setOneofWrapperField(this, 6, this.#one_of_decls[0], value);
    }
    get has_stoc_hs_watch_change() {
      return pb_1.Message.getField(this, 6) != null;
    }
    get stoc_select_hand() {
      return pb_1.Message.getWrapperField(
        this,
        StocSelectHand,
        7
      ) as StocSelectHand;
    }
    set stoc_select_hand(value: StocSelectHand) {
      pb_1.Message.setOneofWrapperField(this, 7, this.#one_of_decls[0], value);
    }
    get has_stoc_select_hand() {
      return pb_1.Message.getField(this, 7) != null;
    }
    get stoc_hand_result() {
      return pb_1.Message.getWrapperField(
        this,
        StocHandResult,
        8
      ) as StocHandResult;
    }
    set stoc_hand_result(value: StocHandResult) {
      pb_1.Message.setOneofWrapperField(this, 8, this.#one_of_decls[0], value);
    }
    get has_stoc_hand_result() {
      return pb_1.Message.getField(this, 8) != null;
    }
    get stoc_select_tp() {
      return pb_1.Message.getWrapperField(
        this,
        StocSelectTp,
        9
      ) as StocSelectTp;
    }
    set stoc_select_tp(value: StocSelectTp) {
      pb_1.Message.setOneofWrapperField(this, 9, this.#one_of_decls[0], value);
    }
    get has_stoc_select_tp() {
      return pb_1.Message.getField(this, 9) != null;
    }
    get stoc_deck_count() {
      return pb_1.Message.getWrapperField(
        this,
        StocDeckCount,
        10
      ) as StocDeckCount;
    }
    set stoc_deck_count(value: StocDeckCount) {
      pb_1.Message.setOneofWrapperField(this, 10, this.#one_of_decls[0], value);
    }
    get has_stoc_deck_count() {
      return pb_1.Message.getField(this, 10) != null;
    }
    get stoc_duel_start() {
      return pb_1.Message.getWrapperField(
        this,
        StocDuelStart,
        11
      ) as StocDuelStart;
    }
    set stoc_duel_start(value: StocDuelStart) {
      pb_1.Message.setOneofWrapperField(this, 11, this.#one_of_decls[0], value);
    }
    get has_stoc_duel_start() {
      return pb_1.Message.getField(this, 11) != null;
    }
    get stoc_game_msg() {
      return pb_1.Message.getWrapperField(
        this,
        StocGameMessage,
        12
      ) as StocGameMessage;
    }
    set stoc_game_msg(value: StocGameMessage) {
      pb_1.Message.setOneofWrapperField(this, 12, this.#one_of_decls[0], value);
    }
    get has_stoc_game_msg() {
      return pb_1.Message.getField(this, 12) != null;
    }
    get stoc_time_limit() {
      return pb_1.Message.getWrapperField(
        this,
        StocTimeLimit,
        13
      ) as StocTimeLimit;
    }
    set stoc_time_limit(value: StocTimeLimit) {
      pb_1.Message.setOneofWrapperField(this, 13, this.#one_of_decls[0], value);
    }
    get has_stoc_time_limit() {
      return pb_1.Message.getField(this, 13) != null;
    }
    get msg() {
      const cases: {
        [index: number]:
          | "none"
          | "stoc_join_game"
          | "stoc_chat"
          | "stoc_hs_player_enter"
          | "stoc_type_change"
          | "stoc_hs_player_change"
          | "stoc_hs_watch_change"
          | "stoc_select_hand"
          | "stoc_hand_result"
          | "stoc_select_tp"
          | "stoc_deck_count"
          | "stoc_duel_start"
          | "stoc_game_msg"
          | "stoc_time_limit";
      } = {
        0: "none",
        1: "stoc_join_game",
        2: "stoc_chat",
        3: "stoc_hs_player_enter",
        4: "stoc_type_change",
        5: "stoc_hs_player_change",
        6: "stoc_hs_watch_change",
        7: "stoc_select_hand",
        8: "stoc_hand_result",
        9: "stoc_select_tp",
        10: "stoc_deck_count",
        11: "stoc_duel_start",
        12: "stoc_game_msg",
        13: "stoc_time_limit",
      };
      return cases[
        pb_1.Message.computeOneofCase(
          this,
          [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]
        )
      ];
    }
    static fromObject(data: {
      stoc_join_game?: ReturnType<typeof StocJoinGame.prototype.toObject>;
      stoc_chat?: ReturnType<typeof StocChat.prototype.toObject>;
      stoc_hs_player_enter?: ReturnType<
        typeof StocHsPlayerEnter.prototype.toObject
      >;
      stoc_type_change?: ReturnType<typeof StocTypeChange.prototype.toObject>;
      stoc_hs_player_change?: ReturnType<
        typeof StocHsPlayerChange.prototype.toObject
      >;
      stoc_hs_watch_change?: ReturnType<
        typeof StocHsWatchChange.prototype.toObject
      >;
      stoc_select_hand?: ReturnType<typeof StocSelectHand.prototype.toObject>;
      stoc_hand_result?: ReturnType<typeof StocHandResult.prototype.toObject>;
      stoc_select_tp?: ReturnType<typeof StocSelectTp.prototype.toObject>;
      stoc_deck_count?: ReturnType<typeof StocDeckCount.prototype.toObject>;
      stoc_duel_start?: ReturnType<typeof StocDuelStart.prototype.toObject>;
      stoc_game_msg?: ReturnType<typeof StocGameMessage.prototype.toObject>;
      stoc_time_limit?: ReturnType<typeof StocTimeLimit.prototype.toObject>;
    }): YgoStocMsg {
      const message = new YgoStocMsg({});
      if (data.stoc_join_game != null) {
        message.stoc_join_game = StocJoinGame.fromObject(data.stoc_join_game);
      }
      if (data.stoc_chat != null) {
        message.stoc_chat = StocChat.fromObject(data.stoc_chat);
      }
      if (data.stoc_hs_player_enter != null) {
        message.stoc_hs_player_enter = StocHsPlayerEnter.fromObject(
          data.stoc_hs_player_enter
        );
      }
      if (data.stoc_type_change != null) {
        message.stoc_type_change = StocTypeChange.fromObject(
          data.stoc_type_change
        );
      }
      if (data.stoc_hs_player_change != null) {
        message.stoc_hs_player_change = StocHsPlayerChange.fromObject(
          data.stoc_hs_player_change
        );
      }
      if (data.stoc_hs_watch_change != null) {
        message.stoc_hs_watch_change = StocHsWatchChange.fromObject(
          data.stoc_hs_watch_change
        );
      }
      if (data.stoc_select_hand != null) {
        message.stoc_select_hand = StocSelectHand.fromObject(
          data.stoc_select_hand
        );
      }
      if (data.stoc_hand_result != null) {
        message.stoc_hand_result = StocHandResult.fromObject(
          data.stoc_hand_result
        );
      }
      if (data.stoc_select_tp != null) {
        message.stoc_select_tp = StocSelectTp.fromObject(data.stoc_select_tp);
      }
      if (data.stoc_deck_count != null) {
        message.stoc_deck_count = StocDeckCount.fromObject(
          data.stoc_deck_count
        );
      }
      if (data.stoc_duel_start != null) {
        message.stoc_duel_start = StocDuelStart.fromObject(
          data.stoc_duel_start
        );
      }
      if (data.stoc_game_msg != null) {
        message.stoc_game_msg = StocGameMessage.fromObject(data.stoc_game_msg);
      }
      if (data.stoc_time_limit != null) {
        message.stoc_time_limit = StocTimeLimit.fromObject(
          data.stoc_time_limit
        );
      }
      return message;
    }
    toObject() {
      const data: {
        stoc_join_game?: ReturnType<typeof StocJoinGame.prototype.toObject>;
        stoc_chat?: ReturnType<typeof StocChat.prototype.toObject>;
        stoc_hs_player_enter?: ReturnType<
          typeof StocHsPlayerEnter.prototype.toObject
        >;
        stoc_type_change?: ReturnType<typeof StocTypeChange.prototype.toObject>;
        stoc_hs_player_change?: ReturnType<
          typeof StocHsPlayerChange.prototype.toObject
        >;
        stoc_hs_watch_change?: ReturnType<
          typeof StocHsWatchChange.prototype.toObject
        >;
        stoc_select_hand?: ReturnType<typeof StocSelectHand.prototype.toObject>;
        stoc_hand_result?: ReturnType<typeof StocHandResult.prototype.toObject>;
        stoc_select_tp?: ReturnType<typeof StocSelectTp.prototype.toObject>;
        stoc_deck_count?: ReturnType<typeof StocDeckCount.prototype.toObject>;
        stoc_duel_start?: ReturnType<typeof StocDuelStart.prototype.toObject>;
        stoc_game_msg?: ReturnType<typeof StocGameMessage.prototype.toObject>;
        stoc_time_limit?: ReturnType<typeof StocTimeLimit.prototype.toObject>;
      } = {};
      if (this.stoc_join_game != null) {
        data.stoc_join_game = this.stoc_join_game.toObject();
      }
      if (this.stoc_chat != null) {
        data.stoc_chat = this.stoc_chat.toObject();
      }
      if (this.stoc_hs_player_enter != null) {
        data.stoc_hs_player_enter = this.stoc_hs_player_enter.toObject();
      }
      if (this.stoc_type_change != null) {
        data.stoc_type_change = this.stoc_type_change.toObject();
      }
      if (this.stoc_hs_player_change != null) {
        data.stoc_hs_player_change = this.stoc_hs_player_change.toObject();
      }
      if (this.stoc_hs_watch_change != null) {
        data.stoc_hs_watch_change = this.stoc_hs_watch_change.toObject();
      }
      if (this.stoc_select_hand != null) {
        data.stoc_select_hand = this.stoc_select_hand.toObject();
      }
      if (this.stoc_hand_result != null) {
        data.stoc_hand_result = this.stoc_hand_result.toObject();
      }
      if (this.stoc_select_tp != null) {
        data.stoc_select_tp = this.stoc_select_tp.toObject();
      }
      if (this.stoc_deck_count != null) {
        data.stoc_deck_count = this.stoc_deck_count.toObject();
      }
      if (this.stoc_duel_start != null) {
        data.stoc_duel_start = this.stoc_duel_start.toObject();
      }
      if (this.stoc_game_msg != null) {
        data.stoc_game_msg = this.stoc_game_msg.toObject();
      }
      if (this.stoc_time_limit != null) {
        data.stoc_time_limit = this.stoc_time_limit.toObject();
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.has_stoc_join_game)
        writer.writeMessage(1, this.stoc_join_game, () =>
          this.stoc_join_game.serialize(writer)
        );
      if (this.has_stoc_chat)
        writer.writeMessage(2, this.stoc_chat, () =>
          this.stoc_chat.serialize(writer)
        );
      if (this.has_stoc_hs_player_enter)
        writer.writeMessage(3, this.stoc_hs_player_enter, () =>
          this.stoc_hs_player_enter.serialize(writer)
        );
      if (this.has_stoc_type_change)
        writer.writeMessage(4, this.stoc_type_change, () =>
          this.stoc_type_change.serialize(writer)
        );
      if (this.has_stoc_hs_player_change)
        writer.writeMessage(5, this.stoc_hs_player_change, () =>
          this.stoc_hs_player_change.serialize(writer)
        );
      if (this.has_stoc_hs_watch_change)
        writer.writeMessage(6, this.stoc_hs_watch_change, () =>
          this.stoc_hs_watch_change.serialize(writer)
        );
      if (this.has_stoc_select_hand)
        writer.writeMessage(7, this.stoc_select_hand, () =>
          this.stoc_select_hand.serialize(writer)
        );
      if (this.has_stoc_hand_result)
        writer.writeMessage(8, this.stoc_hand_result, () =>
          this.stoc_hand_result.serialize(writer)
        );
      if (this.has_stoc_select_tp)
        writer.writeMessage(9, this.stoc_select_tp, () =>
          this.stoc_select_tp.serialize(writer)
        );
      if (this.has_stoc_deck_count)
        writer.writeMessage(10, this.stoc_deck_count, () =>
          this.stoc_deck_count.serialize(writer)
        );
      if (this.has_stoc_duel_start)
        writer.writeMessage(11, this.stoc_duel_start, () =>
          this.stoc_duel_start.serialize(writer)
        );
      if (this.has_stoc_game_msg)
        writer.writeMessage(12, this.stoc_game_msg, () =>
          this.stoc_game_msg.serialize(writer)
        );
      if (this.has_stoc_time_limit)
        writer.writeMessage(13, this.stoc_time_limit, () =>
          this.stoc_time_limit.serialize(writer)
        );
      if (!w) return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): YgoStocMsg {
      const reader =
          bytes instanceof pb_1.BinaryReader
            ? bytes
            : new pb_1.BinaryReader(bytes),
        message = new YgoStocMsg();
      while (reader.nextField()) {
        if (reader.isEndGroup()) break;
        switch (reader.getFieldNumber()) {
          case 1:
            reader.readMessage(
              message.stoc_join_game,
              () => (message.stoc_join_game = StocJoinGame.deserialize(reader))
            );
            break;
          case 2:
            reader.readMessage(
              message.stoc_chat,
              () => (message.stoc_chat = StocChat.deserialize(reader))
            );
            break;
          case 3:
            reader.readMessage(
              message.stoc_hs_player_enter,
              () =>
                (message.stoc_hs_player_enter =
                  StocHsPlayerEnter.deserialize(reader))
            );
            break;
          case 4:
            reader.readMessage(
              message.stoc_type_change,
              () =>
                (message.stoc_type_change = StocTypeChange.deserialize(reader))
            );
            break;
          case 5:
            reader.readMessage(
              message.stoc_hs_player_change,
              () =>
                (message.stoc_hs_player_change =
                  StocHsPlayerChange.deserialize(reader))
            );
            break;
          case 6:
            reader.readMessage(
              message.stoc_hs_watch_change,
              () =>
                (message.stoc_hs_watch_change =
                  StocHsWatchChange.deserialize(reader))
            );
            break;
          case 7:
            reader.readMessage(
              message.stoc_select_hand,
              () =>
                (message.stoc_select_hand = StocSelectHand.deserialize(reader))
            );
            break;
          case 8:
            reader.readMessage(
              message.stoc_hand_result,
              () =>
                (message.stoc_hand_result = StocHandResult.deserialize(reader))
            );
            break;
          case 9:
            reader.readMessage(
              message.stoc_select_tp,
              () => (message.stoc_select_tp = StocSelectTp.deserialize(reader))
            );
            break;
          case 10:
            reader.readMessage(
              message.stoc_deck_count,
              () =>
                (message.stoc_deck_count = StocDeckCount.deserialize(reader))
            );
            break;
          case 11:
            reader.readMessage(
              message.stoc_duel_start,
              () =>
                (message.stoc_duel_start = StocDuelStart.deserialize(reader))
            );
            break;
          case 12:
            reader.readMessage(
              message.stoc_game_msg,
              () =>
                (message.stoc_game_msg = StocGameMessage.deserialize(reader))
            );
            break;
          case 13:
            reader.readMessage(
              message.stoc_time_limit,
              () =>
                (message.stoc_time_limit = StocTimeLimit.deserialize(reader))
            );
            break;
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): YgoStocMsg {
      return YgoStocMsg.deserialize(bytes);
    }
  }
  export class CtosPlayerInfo extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(
      data?:
        | any[]
        | {
            name?: string;
          }
    ) {
      super();
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [],
        this.#one_of_decls
      );
      if (!Array.isArray(data) && typeof data == "object") {
        if ("name" in data && data.name != undefined) {
          this.name = data.name;
        }
      }
    }
    get name() {
      return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
    }
    set name(value: string) {
      pb_1.Message.setField(this, 1, value);
    }
    static fromObject(data: { name?: string }): CtosPlayerInfo {
      const message = new CtosPlayerInfo({});
      if (data.name != null) {
        message.name = data.name;
      }
      return message;
    }
    toObject() {
      const data: {
        name?: string;
      } = {};
      if (this.name != null) {
        data.name = this.name;
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.name.length) writer.writeString(1, this.name);
      if (!w) return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): CtosPlayerInfo {
      const reader =
          bytes instanceof pb_1.BinaryReader
            ? bytes
            : new pb_1.BinaryReader(bytes),
        message = new CtosPlayerInfo();
      while (reader.nextField()) {
        if (reader.isEndGroup()) break;
        switch (reader.getFieldNumber()) {
          case 1:
            message.name = reader.readString();
            break;
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): CtosPlayerInfo {
      return CtosPlayerInfo.deserialize(bytes);
    }
  }
  export class CtosJoinGame extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(
      data?:
        | any[]
        | {
            version?: number;
            gameid?: number;
            passwd?: string;
          }
    ) {
      super();
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [],
        this.#one_of_decls
      );
      if (!Array.isArray(data) && typeof data == "object") {
        if ("version" in data && data.version != undefined) {
          this.version = data.version;
        }
        if ("gameid" in data && data.gameid != undefined) {
          this.gameid = data.gameid;
        }
        if ("passwd" in data && data.passwd != undefined) {
          this.passwd = data.passwd;
        }
      }
    }
    get version() {
      return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
    }
    set version(value: number) {
      pb_1.Message.setField(this, 1, value);
    }
    get gameid() {
      return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
    }
    set gameid(value: number) {
      pb_1.Message.setField(this, 2, value);
    }
    get passwd() {
      return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
    }
    set passwd(value: string) {
      pb_1.Message.setField(this, 3, value);
    }
    static fromObject(data: {
      version?: number;
      gameid?: number;
      passwd?: string;
    }): CtosJoinGame {
      const message = new CtosJoinGame({});
      if (data.version != null) {
        message.version = data.version;
      }
      if (data.gameid != null) {
        message.gameid = data.gameid;
      }
      if (data.passwd != null) {
        message.passwd = data.passwd;
      }
      return message;
    }
    toObject() {
      const data: {
        version?: number;
        gameid?: number;
        passwd?: string;
      } = {};
      if (this.version != null) {
        data.version = this.version;
      }
      if (this.gameid != null) {
        data.gameid = this.gameid;
      }
      if (this.passwd != null) {
        data.passwd = this.passwd;
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.version != 0) writer.writeInt32(1, this.version);
      if (this.gameid != 0) writer.writeInt32(2, this.gameid);
      if (this.passwd.length) writer.writeString(3, this.passwd);
      if (!w) return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): CtosJoinGame {
      const reader =
          bytes instanceof pb_1.BinaryReader
            ? bytes
            : new pb_1.BinaryReader(bytes),
        message = new CtosJoinGame();
      while (reader.nextField()) {
        if (reader.isEndGroup()) break;
        switch (reader.getFieldNumber()) {
          case 1:
            message.version = reader.readInt32();
            break;
          case 2:
            message.gameid = reader.readInt32();
            break;
          case 3:
            message.passwd = reader.readString();
            break;
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): CtosJoinGame {
      return CtosJoinGame.deserialize(bytes);
    }
  }
  export class CtosUpdateDeck extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(
      data?:
        | any[]
        | {
            main?: number[];
            extra?: number[];
            side?: number[];
          }
    ) {
      super();
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [1, 2, 3],
        this.#one_of_decls
      );
      if (!Array.isArray(data) && typeof data == "object") {
        if ("main" in data && data.main != undefined) {
          this.main = data.main;
        }
        if ("extra" in data && data.extra != undefined) {
          this.extra = data.extra;
        }
        if ("side" in data && data.side != undefined) {
          this.side = data.side;
        }
      }
    }
    get main() {
      return pb_1.Message.getFieldWithDefault(this, 1, []) as number[];
    }
    set main(value: number[]) {
      pb_1.Message.setField(this, 1, value);
    }
    get extra() {
      return pb_1.Message.getFieldWithDefault(this, 2, []) as number[];
    }
    set extra(value: number[]) {
      pb_1.Message.setField(this, 2, value);
    }
    get side() {
      return pb_1.Message.getFieldWithDefault(this, 3, []) as number[];
    }
    set side(value: number[]) {
      pb_1.Message.setField(this, 3, value);
    }
    static fromObject(data: {
      main?: number[];
      extra?: number[];
      side?: number[];
    }): CtosUpdateDeck {
      const message = new CtosUpdateDeck({});
      if (data.main != null) {
        message.main = data.main;
      }
      if (data.extra != null) {
        message.extra = data.extra;
      }
      if (data.side != null) {
        message.side = data.side;
      }
      return message;
    }
    toObject() {
      const data: {
        main?: number[];
        extra?: number[];
        side?: number[];
      } = {};
      if (this.main != null) {
        data.main = this.main;
      }
      if (this.extra != null) {
        data.extra = this.extra;
      }
      if (this.side != null) {
        data.side = this.side;
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.main.length) writer.writePackedInt32(1, this.main);
      if (this.extra.length) writer.writePackedInt32(2, this.extra);
      if (this.side.length) writer.writePackedInt32(3, this.side);
      if (!w) return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): CtosUpdateDeck {
      const reader =
          bytes instanceof pb_1.BinaryReader
            ? bytes
            : new pb_1.BinaryReader(bytes),
        message = new CtosUpdateDeck();
      while (reader.nextField()) {
        if (reader.isEndGroup()) break;
        switch (reader.getFieldNumber()) {
          case 1:
            message.main = reader.readPackedInt32();
            break;
          case 2:
            message.extra = reader.readPackedInt32();
            break;
          case 3:
            message.side = reader.readPackedInt32();
            break;
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): CtosUpdateDeck {
      return CtosUpdateDeck.deserialize(bytes);
    }
  }
  export class CtosHsReady extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {}) {
      super();
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [],
        this.#one_of_decls
      );
      if (!Array.isArray(data) && typeof data == "object") {
      }
    }
    static fromObject(data: {}): CtosHsReady {
      const message = new CtosHsReady({});
      return message;
    }
    toObject() {
      const data: {} = {};
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (!w) return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): CtosHsReady {
      const reader =
          bytes instanceof pb_1.BinaryReader
            ? bytes
            : new pb_1.BinaryReader(bytes),
        message = new CtosHsReady();
      while (reader.nextField()) {
        if (reader.isEndGroup()) break;
        switch (reader.getFieldNumber()) {
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): CtosHsReady {
      return CtosHsReady.deserialize(bytes);
    }
  }
  export class CtosHsNotReady extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {}) {
      super();
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [],
        this.#one_of_decls
      );
      if (!Array.isArray(data) && typeof data == "object") {
      }
    }
    static fromObject(data: {}): CtosHsNotReady {
      const message = new CtosHsNotReady({});
      return message;
    }
    toObject() {
      const data: {} = {};
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (!w) return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): CtosHsNotReady {
      const reader =
          bytes instanceof pb_1.BinaryReader
            ? bytes
            : new pb_1.BinaryReader(bytes),
        message = new CtosHsNotReady();
      while (reader.nextField()) {
        if (reader.isEndGroup()) break;
        switch (reader.getFieldNumber()) {
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): CtosHsNotReady {
      return CtosHsNotReady.deserialize(bytes);
    }
  }
  export class CtosHsStart extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {}) {
      super();
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [],
        this.#one_of_decls
      );
      if (!Array.isArray(data) && typeof data == "object") {
      }
    }
    static fromObject(data: {}): CtosHsStart {
      const message = new CtosHsStart({});
      return message;
    }
    toObject() {
      const data: {} = {};
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (!w) return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): CtosHsStart {
      const reader =
          bytes instanceof pb_1.BinaryReader
            ? bytes
            : new pb_1.BinaryReader(bytes),
        message = new CtosHsStart();
      while (reader.nextField()) {
        if (reader.isEndGroup()) break;
        switch (reader.getFieldNumber()) {
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): CtosHsStart {
      return CtosHsStart.deserialize(bytes);
    }
  }
  export class CtosHandResult extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(
      data?:
        | any[]
        | {
            hand?: HandType;
          }
    ) {
      super();
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [],
        this.#one_of_decls
      );
      if (!Array.isArray(data) && typeof data == "object") {
        if ("hand" in data && data.hand != undefined) {
          this.hand = data.hand;
        }
      }
    }
    get hand() {
      return pb_1.Message.getFieldWithDefault(
        this,
        1,
        HandType.UNKNOWN
      ) as HandType;
    }
    set hand(value: HandType) {
      pb_1.Message.setField(this, 1, value);
    }
    static fromObject(data: { hand?: HandType }): CtosHandResult {
      const message = new CtosHandResult({});
      if (data.hand != null) {
        message.hand = data.hand;
      }
      return message;
    }
    toObject() {
      const data: {
        hand?: HandType;
      } = {};
      if (this.hand != null) {
        data.hand = this.hand;
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.hand != HandType.UNKNOWN) writer.writeEnum(1, this.hand);
      if (!w) return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): CtosHandResult {
      const reader =
          bytes instanceof pb_1.BinaryReader
            ? bytes
            : new pb_1.BinaryReader(bytes),
        message = new CtosHandResult();
      while (reader.nextField()) {
        if (reader.isEndGroup()) break;
        switch (reader.getFieldNumber()) {
          case 1:
            message.hand = reader.readEnum();
            break;
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): CtosHandResult {
      return CtosHandResult.deserialize(bytes);
    }
  }
  export class CtosTpResult extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(
      data?:
        | any[]
        | {
            tp?: CtosTpResult.TpType;
          }
    ) {
      super();
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [],
        this.#one_of_decls
      );
      if (!Array.isArray(data) && typeof data == "object") {
        if ("tp" in data && data.tp != undefined) {
          this.tp = data.tp;
        }
      }
    }
    get tp() {
      return pb_1.Message.getFieldWithDefault(
        this,
        1,
        CtosTpResult.TpType.UNKNOWN
      ) as CtosTpResult.TpType;
    }
    set tp(value: CtosTpResult.TpType) {
      pb_1.Message.setField(this, 1, value);
    }
    static fromObject(data: { tp?: CtosTpResult.TpType }): CtosTpResult {
      const message = new CtosTpResult({});
      if (data.tp != null) {
        message.tp = data.tp;
      }
      return message;
    }
    toObject() {
      const data: {
        tp?: CtosTpResult.TpType;
      } = {};
      if (this.tp != null) {
        data.tp = this.tp;
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.tp != CtosTpResult.TpType.UNKNOWN) writer.writeEnum(1, this.tp);
      if (!w) return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): CtosTpResult {
      const reader =
          bytes instanceof pb_1.BinaryReader
            ? bytes
            : new pb_1.BinaryReader(bytes),
        message = new CtosTpResult();
      while (reader.nextField()) {
        if (reader.isEndGroup()) break;
        switch (reader.getFieldNumber()) {
          case 1:
            message.tp = reader.readEnum();
            break;
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): CtosTpResult {
      return CtosTpResult.deserialize(bytes);
    }
  }
  export namespace CtosTpResult {
    export enum TpType {
      UNKNOWN = 0,
      FIRST = 1,
      SECOND = 2,
    }
  }
  export class CtosTimeConfirm extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {}) {
      super();
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [],
        this.#one_of_decls
      );
      if (!Array.isArray(data) && typeof data == "object") {
      }
    }
    static fromObject(data: {}): CtosTimeConfirm {
      const message = new CtosTimeConfirm({});
      return message;
    }
    toObject() {
      const data: {} = {};
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (!w) return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): CtosTimeConfirm {
      const reader =
          bytes instanceof pb_1.BinaryReader
            ? bytes
            : new pb_1.BinaryReader(bytes),
        message = new CtosTimeConfirm();
      while (reader.nextField()) {
        if (reader.isEndGroup()) break;
        switch (reader.getFieldNumber()) {
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): CtosTimeConfirm {
      return CtosTimeConfirm.deserialize(bytes);
    }
  }
  export class CtosGameMsgResponse extends pb_1.Message {
    #one_of_decls: number[][] = [[1, 2, 3, 4, 5, 6, 7, 8, 9]];
    constructor(
      data?:
        | any[]
        | ({} & (
            | {
                select_idle_cmd?: CtosGameMsgResponse.SelectIdleCmdResponse;
                select_place?: never;
                select_card?: never;
                select_chain?: never;
                select_effect_yn?: never;
                select_position?: never;
                select_option?: never;
                select_battle_cmd?: never;
                select_unselect_card?: never;
              }
            | {
                select_idle_cmd?: never;
                select_place?: CtosGameMsgResponse.SelectPlaceResponse;
                select_card?: never;
                select_chain?: never;
                select_effect_yn?: never;
                select_position?: never;
                select_option?: never;
                select_battle_cmd?: never;
                select_unselect_card?: never;
              }
            | {
                select_idle_cmd?: never;
                select_place?: never;
                select_card?: CtosGameMsgResponse.SelectCardResponse;
                select_chain?: never;
                select_effect_yn?: never;
                select_position?: never;
                select_option?: never;
                select_battle_cmd?: never;
                select_unselect_card?: never;
              }
            | {
                select_idle_cmd?: never;
                select_place?: never;
                select_card?: never;
                select_chain?: CtosGameMsgResponse.SelectChainResponse;
                select_effect_yn?: never;
                select_position?: never;
                select_option?: never;
                select_battle_cmd?: never;
                select_unselect_card?: never;
              }
            | {
                select_idle_cmd?: never;
                select_place?: never;
                select_card?: never;
                select_chain?: never;
                select_effect_yn?: CtosGameMsgResponse.SelectEffectYnResponse;
                select_position?: never;
                select_option?: never;
                select_battle_cmd?: never;
                select_unselect_card?: never;
              }
            | {
                select_idle_cmd?: never;
                select_place?: never;
                select_card?: never;
                select_chain?: never;
                select_effect_yn?: never;
                select_position?: CtosGameMsgResponse.SelectPositionResponse;
                select_option?: never;
                select_battle_cmd?: never;
                select_unselect_card?: never;
              }
            | {
                select_idle_cmd?: never;
                select_place?: never;
                select_card?: never;
                select_chain?: never;
                select_effect_yn?: never;
                select_position?: never;
                select_option?: CtosGameMsgResponse.SelectOptionResponse;
                select_battle_cmd?: never;
                select_unselect_card?: never;
              }
            | {
                select_idle_cmd?: never;
                select_place?: never;
                select_card?: never;
                select_chain?: never;
                select_effect_yn?: never;
                select_position?: never;
                select_option?: never;
                select_battle_cmd?: CtosGameMsgResponse.SelectBattleCmdResponse;
                select_unselect_card?: never;
              }
            | {
                select_idle_cmd?: never;
                select_place?: never;
                select_card?: never;
                select_chain?: never;
                select_effect_yn?: never;
                select_position?: never;
                select_option?: never;
                select_battle_cmd?: never;
                select_unselect_card?: CtosGameMsgResponse.SelectUnselectCardResponse;
              }
          ))
    ) {
      super();
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [],
        this.#one_of_decls
      );
      if (!Array.isArray(data) && typeof data == "object") {
        if ("select_idle_cmd" in data && data.select_idle_cmd != undefined) {
          this.select_idle_cmd = data.select_idle_cmd;
        }
        if ("select_place" in data && data.select_place != undefined) {
          this.select_place = data.select_place;
        }
        if ("select_card" in data && data.select_card != undefined) {
          this.select_card = data.select_card;
        }
        if ("select_chain" in data && data.select_chain != undefined) {
          this.select_chain = data.select_chain;
        }
        if ("select_effect_yn" in data && data.select_effect_yn != undefined) {
          this.select_effect_yn = data.select_effect_yn;
        }
        if ("select_position" in data && data.select_position != undefined) {
          this.select_position = data.select_position;
        }
        if ("select_option" in data && data.select_option != undefined) {
          this.select_option = data.select_option;
        }
        if (
          "select_battle_cmd" in data &&
          data.select_battle_cmd != undefined
        ) {
          this.select_battle_cmd = data.select_battle_cmd;
        }
        if (
          "select_unselect_card" in data &&
          data.select_unselect_card != undefined
        ) {
          this.select_unselect_card = data.select_unselect_card;
        }
      }
    }
    get select_idle_cmd() {
      return pb_1.Message.getWrapperField(
        this,
        CtosGameMsgResponse.SelectIdleCmdResponse,
        1
      ) as CtosGameMsgResponse.SelectIdleCmdResponse;
    }
    set select_idle_cmd(value: CtosGameMsgResponse.SelectIdleCmdResponse) {
      pb_1.Message.setOneofWrapperField(this, 1, this.#one_of_decls[0], value);
    }
    get has_select_idle_cmd() {
      return pb_1.Message.getField(this, 1) != null;
    }
    get select_place() {
      return pb_1.Message.getWrapperField(
        this,
        CtosGameMsgResponse.SelectPlaceResponse,
        2
      ) as CtosGameMsgResponse.SelectPlaceResponse;
    }
    set select_place(value: CtosGameMsgResponse.SelectPlaceResponse) {
      pb_1.Message.setOneofWrapperField(this, 2, this.#one_of_decls[0], value);
    }
    get has_select_place() {
      return pb_1.Message.getField(this, 2) != null;
    }
    get select_card() {
      return pb_1.Message.getWrapperField(
        this,
        CtosGameMsgResponse.SelectCardResponse,
        3
      ) as CtosGameMsgResponse.SelectCardResponse;
    }
    set select_card(value: CtosGameMsgResponse.SelectCardResponse) {
      pb_1.Message.setOneofWrapperField(this, 3, this.#one_of_decls[0], value);
    }
    get has_select_card() {
      return pb_1.Message.getField(this, 3) != null;
    }
    get select_chain() {
      return pb_1.Message.getWrapperField(
        this,
        CtosGameMsgResponse.SelectChainResponse,
        4
      ) as CtosGameMsgResponse.SelectChainResponse;
    }
    set select_chain(value: CtosGameMsgResponse.SelectChainResponse) {
      pb_1.Message.setOneofWrapperField(this, 4, this.#one_of_decls[0], value);
    }
    get has_select_chain() {
      return pb_1.Message.getField(this, 4) != null;
    }
    get select_effect_yn() {
      return pb_1.Message.getWrapperField(
        this,
        CtosGameMsgResponse.SelectEffectYnResponse,
        5
      ) as CtosGameMsgResponse.SelectEffectYnResponse;
    }
    set select_effect_yn(value: CtosGameMsgResponse.SelectEffectYnResponse) {
      pb_1.Message.setOneofWrapperField(this, 5, this.#one_of_decls[0], value);
    }
    get has_select_effect_yn() {
      return pb_1.Message.getField(this, 5) != null;
    }
    get select_position() {
      return pb_1.Message.getWrapperField(
        this,
        CtosGameMsgResponse.SelectPositionResponse,
        6
      ) as CtosGameMsgResponse.SelectPositionResponse;
    }
    set select_position(value: CtosGameMsgResponse.SelectPositionResponse) {
      pb_1.Message.setOneofWrapperField(this, 6, this.#one_of_decls[0], value);
    }
    get has_select_position() {
      return pb_1.Message.getField(this, 6) != null;
    }
    get select_option() {
      return pb_1.Message.getWrapperField(
        this,
        CtosGameMsgResponse.SelectOptionResponse,
        7
      ) as CtosGameMsgResponse.SelectOptionResponse;
    }
    set select_option(value: CtosGameMsgResponse.SelectOptionResponse) {
      pb_1.Message.setOneofWrapperField(this, 7, this.#one_of_decls[0], value);
    }
    get has_select_option() {
      return pb_1.Message.getField(this, 7) != null;
    }
    get select_battle_cmd() {
      return pb_1.Message.getWrapperField(
        this,
        CtosGameMsgResponse.SelectBattleCmdResponse,
        8
      ) as CtosGameMsgResponse.SelectBattleCmdResponse;
    }
    set select_battle_cmd(value: CtosGameMsgResponse.SelectBattleCmdResponse) {
      pb_1.Message.setOneofWrapperField(this, 8, this.#one_of_decls[0], value);
    }
    get has_select_battle_cmd() {
      return pb_1.Message.getField(this, 8) != null;
    }
    get select_unselect_card() {
      return pb_1.Message.getWrapperField(
        this,
        CtosGameMsgResponse.SelectUnselectCardResponse,
        9
      ) as CtosGameMsgResponse.SelectUnselectCardResponse;
    }
    set select_unselect_card(
      value: CtosGameMsgResponse.SelectUnselectCardResponse
    ) {
      pb_1.Message.setOneofWrapperField(this, 9, this.#one_of_decls[0], value);
    }
    get has_select_unselect_card() {
      return pb_1.Message.getField(this, 9) != null;
    }
    get gameMsgResponse() {
      const cases: {
        [index: number]:
          | "none"
          | "select_idle_cmd"
          | "select_place"
          | "select_card"
          | "select_chain"
          | "select_effect_yn"
          | "select_position"
          | "select_option"
          | "select_battle_cmd"
          | "select_unselect_card";
      } = {
        0: "none",
        1: "select_idle_cmd",
        2: "select_place",
        3: "select_card",
        4: "select_chain",
        5: "select_effect_yn",
        6: "select_position",
        7: "select_option",
        8: "select_battle_cmd",
        9: "select_unselect_card",
      };
      return cases[
        pb_1.Message.computeOneofCase(this, [1, 2, 3, 4, 5, 6, 7, 8, 9])
      ];
    }
    static fromObject(data: {
      select_idle_cmd?: ReturnType<
        typeof CtosGameMsgResponse.SelectIdleCmdResponse.prototype.toObject
      >;
      select_place?: ReturnType<
        typeof CtosGameMsgResponse.SelectPlaceResponse.prototype.toObject
      >;
      select_card?: ReturnType<
        typeof CtosGameMsgResponse.SelectCardResponse.prototype.toObject
      >;
      select_chain?: ReturnType<
        typeof CtosGameMsgResponse.SelectChainResponse.prototype.toObject
      >;
      select_effect_yn?: ReturnType<
        typeof CtosGameMsgResponse.SelectEffectYnResponse.prototype.toObject
      >;
      select_position?: ReturnType<
        typeof CtosGameMsgResponse.SelectPositionResponse.prototype.toObject
      >;
      select_option?: ReturnType<
        typeof CtosGameMsgResponse.SelectOptionResponse.prototype.toObject
      >;
      select_battle_cmd?: ReturnType<
        typeof CtosGameMsgResponse.SelectBattleCmdResponse.prototype.toObject
      >;
      select_unselect_card?: ReturnType<
        typeof CtosGameMsgResponse.SelectUnselectCardResponse.prototype.toObject
      >;
    }): CtosGameMsgResponse {
      const message = new CtosGameMsgResponse({});
      if (data.select_idle_cmd != null) {
        message.select_idle_cmd =
          CtosGameMsgResponse.SelectIdleCmdResponse.fromObject(
            data.select_idle_cmd
          );
      }
      if (data.select_place != null) {
        message.select_place =
          CtosGameMsgResponse.SelectPlaceResponse.fromObject(data.select_place);
      }
      if (data.select_card != null) {
        message.select_card = CtosGameMsgResponse.SelectCardResponse.fromObject(
          data.select_card
        );
      }
      if (data.select_chain != null) {
        message.select_chain =
          CtosGameMsgResponse.SelectChainResponse.fromObject(data.select_chain);
      }
      if (data.select_effect_yn != null) {
        message.select_effect_yn =
          CtosGameMsgResponse.SelectEffectYnResponse.fromObject(
            data.select_effect_yn
          );
      }
      if (data.select_position != null) {
        message.select_position =
          CtosGameMsgResponse.SelectPositionResponse.fromObject(
            data.select_position
          );
      }
      if (data.select_option != null) {
        message.select_option =
          CtosGameMsgResponse.SelectOptionResponse.fromObject(
            data.select_option
          );
      }
      if (data.select_battle_cmd != null) {
        message.select_battle_cmd =
          CtosGameMsgResponse.SelectBattleCmdResponse.fromObject(
            data.select_battle_cmd
          );
      }
      if (data.select_unselect_card != null) {
        message.select_unselect_card =
          CtosGameMsgResponse.SelectUnselectCardResponse.fromObject(
            data.select_unselect_card
          );
      }
      return message;
    }
    toObject() {
      const data: {
        select_idle_cmd?: ReturnType<
          typeof CtosGameMsgResponse.SelectIdleCmdResponse.prototype.toObject
        >;
        select_place?: ReturnType<
          typeof CtosGameMsgResponse.SelectPlaceResponse.prototype.toObject
        >;
        select_card?: ReturnType<
          typeof CtosGameMsgResponse.SelectCardResponse.prototype.toObject
        >;
        select_chain?: ReturnType<
          typeof CtosGameMsgResponse.SelectChainResponse.prototype.toObject
        >;
        select_effect_yn?: ReturnType<
          typeof CtosGameMsgResponse.SelectEffectYnResponse.prototype.toObject
        >;
        select_position?: ReturnType<
          typeof CtosGameMsgResponse.SelectPositionResponse.prototype.toObject
        >;
        select_option?: ReturnType<
          typeof CtosGameMsgResponse.SelectOptionResponse.prototype.toObject
        >;
        select_battle_cmd?: ReturnType<
          typeof CtosGameMsgResponse.SelectBattleCmdResponse.prototype.toObject
        >;
        select_unselect_card?: ReturnType<
          typeof CtosGameMsgResponse.SelectUnselectCardResponse.prototype.toObject
        >;
      } = {};
      if (this.select_idle_cmd != null) {
        data.select_idle_cmd = this.select_idle_cmd.toObject();
      }
      if (this.select_place != null) {
        data.select_place = this.select_place.toObject();
      }
      if (this.select_card != null) {
        data.select_card = this.select_card.toObject();
      }
      if (this.select_chain != null) {
        data.select_chain = this.select_chain.toObject();
      }
      if (this.select_effect_yn != null) {
        data.select_effect_yn = this.select_effect_yn.toObject();
      }
      if (this.select_position != null) {
        data.select_position = this.select_position.toObject();
      }
      if (this.select_option != null) {
        data.select_option = this.select_option.toObject();
      }
      if (this.select_battle_cmd != null) {
        data.select_battle_cmd = this.select_battle_cmd.toObject();
      }
      if (this.select_unselect_card != null) {
        data.select_unselect_card = this.select_unselect_card.toObject();
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.has_select_idle_cmd)
        writer.writeMessage(1, this.select_idle_cmd, () =>
          this.select_idle_cmd.serialize(writer)
        );
      if (this.has_select_place)
        writer.writeMessage(2, this.select_place, () =>
          this.select_place.serialize(writer)
        );
      if (this.has_select_card)
        writer.writeMessage(3, this.select_card, () =>
          this.select_card.serialize(writer)
        );
      if (this.has_select_chain)
        writer.writeMessage(4, this.select_chain, () =>
          this.select_chain.serialize(writer)
        );
      if (this.has_select_effect_yn)
        writer.writeMessage(5, this.select_effect_yn, () =>
          this.select_effect_yn.serialize(writer)
        );
      if (this.has_select_position)
        writer.writeMessage(6, this.select_position, () =>
          this.select_position.serialize(writer)
        );
      if (this.has_select_option)
        writer.writeMessage(7, this.select_option, () =>
          this.select_option.serialize(writer)
        );
      if (this.has_select_battle_cmd)
        writer.writeMessage(8, this.select_battle_cmd, () =>
          this.select_battle_cmd.serialize(writer)
        );
      if (this.has_select_unselect_card)
        writer.writeMessage(9, this.select_unselect_card, () =>
          this.select_unselect_card.serialize(writer)
        );
      if (!w) return writer.getResultBuffer();
    }
    static deserialize(
      bytes: Uint8Array | pb_1.BinaryReader
    ): CtosGameMsgResponse {
      const reader =
          bytes instanceof pb_1.BinaryReader
            ? bytes
            : new pb_1.BinaryReader(bytes),
        message = new CtosGameMsgResponse();
      while (reader.nextField()) {
        if (reader.isEndGroup()) break;
        switch (reader.getFieldNumber()) {
          case 1:
            reader.readMessage(
              message.select_idle_cmd,
              () =>
                (message.select_idle_cmd =
                  CtosGameMsgResponse.SelectIdleCmdResponse.deserialize(reader))
            );
            break;
          case 2:
            reader.readMessage(
              message.select_place,
              () =>
                (message.select_place =
                  CtosGameMsgResponse.SelectPlaceResponse.deserialize(reader))
            );
            break;
          case 3:
            reader.readMessage(
              message.select_card,
              () =>
                (message.select_card =
                  CtosGameMsgResponse.SelectCardResponse.deserialize(reader))
            );
            break;
          case 4:
            reader.readMessage(
              message.select_chain,
              () =>
                (message.select_chain =
                  CtosGameMsgResponse.SelectChainResponse.deserialize(reader))
            );
            break;
          case 5:
            reader.readMessage(
              message.select_effect_yn,
              () =>
                (message.select_effect_yn =
                  CtosGameMsgResponse.SelectEffectYnResponse.deserialize(
                    reader
                  ))
            );
            break;
          case 6:
            reader.readMessage(
              message.select_position,
              () =>
                (message.select_position =
                  CtosGameMsgResponse.SelectPositionResponse.deserialize(
                    reader
                  ))
            );
            break;
          case 7:
            reader.readMessage(
              message.select_option,
              () =>
                (message.select_option =
                  CtosGameMsgResponse.SelectOptionResponse.deserialize(reader))
            );
            break;
          case 8:
            reader.readMessage(
              message.select_battle_cmd,
              () =>
                (message.select_battle_cmd =
                  CtosGameMsgResponse.SelectBattleCmdResponse.deserialize(
                    reader
                  ))
            );
            break;
          case 9:
            reader.readMessage(
              message.select_unselect_card,
              () =>
                (message.select_unselect_card =
                  CtosGameMsgResponse.SelectUnselectCardResponse.deserialize(
                    reader
                  ))
            );
            break;
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): CtosGameMsgResponse {
      return CtosGameMsgResponse.deserialize(bytes);
    }
  }
  export namespace CtosGameMsgResponse {
    export class SelectIdleCmdResponse extends pb_1.Message {
      #one_of_decls: number[][] = [];
      constructor(
        data?:
          | any[]
          | {
              code?: number;
            }
      ) {
        super();
        pb_1.Message.initialize(
          this,
          Array.isArray(data) ? data : [],
          0,
          -1,
          [],
          this.#one_of_decls
        );
        if (!Array.isArray(data) && typeof data == "object") {
          if ("code" in data && data.code != undefined) {
            this.code = data.code;
          }
        }
      }
      get code() {
        return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
      }
      set code(value: number) {
        pb_1.Message.setField(this, 1, value);
      }
      static fromObject(data: { code?: number }): SelectIdleCmdResponse {
        const message = new SelectIdleCmdResponse({});
        if (data.code != null) {
          message.code = data.code;
        }
        return message;
      }
      toObject() {
        const data: {
          code?: number;
        } = {};
        if (this.code != null) {
          data.code = this.code;
        }
        return data;
      }
      serialize(): Uint8Array;
      serialize(w: pb_1.BinaryWriter): void;
      serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.code != 0) writer.writeInt32(1, this.code);
        if (!w) return writer.getResultBuffer();
      }
      static deserialize(
        bytes: Uint8Array | pb_1.BinaryReader
      ): SelectIdleCmdResponse {
        const reader =
            bytes instanceof pb_1.BinaryReader
              ? bytes
              : new pb_1.BinaryReader(bytes),
          message = new SelectIdleCmdResponse();
        while (reader.nextField()) {
          if (reader.isEndGroup()) break;
          switch (reader.getFieldNumber()) {
            case 1:
              message.code = reader.readInt32();
              break;
            default:
              reader.skipField();
          }
        }
        return message;
      }
      serializeBinary(): Uint8Array {
        return this.serialize();
      }
      static deserializeBinary(bytes: Uint8Array): SelectIdleCmdResponse {
        return SelectIdleCmdResponse.deserialize(bytes);
      }
    }
    export class SelectPlaceResponse extends pb_1.Message {
      #one_of_decls: number[][] = [];
      constructor(
        data?:
          | any[]
          | {
              player?: number;
              zone?: CardZone;
              sequence?: number;
            }
      ) {
        super();
        pb_1.Message.initialize(
          this,
          Array.isArray(data) ? data : [],
          0,
          -1,
          [],
          this.#one_of_decls
        );
        if (!Array.isArray(data) && typeof data == "object") {
          if ("player" in data && data.player != undefined) {
            this.player = data.player;
          }
          if ("zone" in data && data.zone != undefined) {
            this.zone = data.zone;
          }
          if ("sequence" in data && data.sequence != undefined) {
            this.sequence = data.sequence;
          }
        }
      }
      get player() {
        return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
      }
      set player(value: number) {
        pb_1.Message.setField(this, 1, value);
      }
      get zone() {
        return pb_1.Message.getFieldWithDefault(
          this,
          2,
          CardZone.DECK
        ) as CardZone;
      }
      set zone(value: CardZone) {
        pb_1.Message.setField(this, 2, value);
      }
      get sequence() {
        return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
      }
      set sequence(value: number) {
        pb_1.Message.setField(this, 3, value);
      }
      static fromObject(data: {
        player?: number;
        zone?: CardZone;
        sequence?: number;
      }): SelectPlaceResponse {
        const message = new SelectPlaceResponse({});
        if (data.player != null) {
          message.player = data.player;
        }
        if (data.zone != null) {
          message.zone = data.zone;
        }
        if (data.sequence != null) {
          message.sequence = data.sequence;
        }
        return message;
      }
      toObject() {
        const data: {
          player?: number;
          zone?: CardZone;
          sequence?: number;
        } = {};
        if (this.player != null) {
          data.player = this.player;
        }
        if (this.zone != null) {
          data.zone = this.zone;
        }
        if (this.sequence != null) {
          data.sequence = this.sequence;
        }
        return data;
      }
      serialize(): Uint8Array;
      serialize(w: pb_1.BinaryWriter): void;
      serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.player != 0) writer.writeInt32(1, this.player);
        if (this.zone != CardZone.DECK) writer.writeEnum(2, this.zone);
        if (this.sequence != 0) writer.writeInt32(3, this.sequence);
        if (!w) return writer.getResultBuffer();
      }
      static deserialize(
        bytes: Uint8Array | pb_1.BinaryReader
      ): SelectPlaceResponse {
        const reader =
            bytes instanceof pb_1.BinaryReader
              ? bytes
              : new pb_1.BinaryReader(bytes),
          message = new SelectPlaceResponse();
        while (reader.nextField()) {
          if (reader.isEndGroup()) break;
          switch (reader.getFieldNumber()) {
            case 1:
              message.player = reader.readInt32();
              break;
            case 2:
              message.zone = reader.readEnum();
              break;
            case 3:
              message.sequence = reader.readInt32();
              break;
            default:
              reader.skipField();
          }
        }
        return message;
      }
      serializeBinary(): Uint8Array {
        return this.serialize();
      }
      static deserializeBinary(bytes: Uint8Array): SelectPlaceResponse {
        return SelectPlaceResponse.deserialize(bytes);
      }
    }
    export class SelectCardResponse extends pb_1.Message {
      #one_of_decls: number[][] = [];
      constructor(
        data?:
          | any[]
          | {
              selected_ptrs?: number[];
            }
      ) {
        super();
        pb_1.Message.initialize(
          this,
          Array.isArray(data) ? data : [],
          0,
          -1,
          [1],
          this.#one_of_decls
        );
        if (!Array.isArray(data) && typeof data == "object") {
          if ("selected_ptrs" in data && data.selected_ptrs != undefined) {
            this.selected_ptrs = data.selected_ptrs;
          }
        }
      }
      get selected_ptrs() {
        return pb_1.Message.getFieldWithDefault(this, 1, []) as number[];
      }
      set selected_ptrs(value: number[]) {
        pb_1.Message.setField(this, 1, value);
      }
      static fromObject(data: {
        selected_ptrs?: number[];
      }): SelectCardResponse {
        const message = new SelectCardResponse({});
        if (data.selected_ptrs != null) {
          message.selected_ptrs = data.selected_ptrs;
        }
        return message;
      }
      toObject() {
        const data: {
          selected_ptrs?: number[];
        } = {};
        if (this.selected_ptrs != null) {
          data.selected_ptrs = this.selected_ptrs;
        }
        return data;
      }
      serialize(): Uint8Array;
      serialize(w: pb_1.BinaryWriter): void;
      serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.selected_ptrs.length)
          writer.writePackedInt32(1, this.selected_ptrs);
        if (!w) return writer.getResultBuffer();
      }
      static deserialize(
        bytes: Uint8Array | pb_1.BinaryReader
      ): SelectCardResponse {
        const reader =
            bytes instanceof pb_1.BinaryReader
              ? bytes
              : new pb_1.BinaryReader(bytes),
          message = new SelectCardResponse();
        while (reader.nextField()) {
          if (reader.isEndGroup()) break;
          switch (reader.getFieldNumber()) {
            case 1:
              message.selected_ptrs = reader.readPackedInt32();
              break;
            default:
              reader.skipField();
          }
        }
        return message;
      }
      serializeBinary(): Uint8Array {
        return this.serialize();
      }
      static deserializeBinary(bytes: Uint8Array): SelectCardResponse {
        return SelectCardResponse.deserialize(bytes);
      }
    }
    export class SelectChainResponse extends pb_1.Message {
      #one_of_decls: number[][] = [];
      constructor(
        data?:
          | any[]
          | {
              selected_ptr?: number;
            }
      ) {
        super();
        pb_1.Message.initialize(
          this,
          Array.isArray(data) ? data : [],
          0,
          -1,
          [],
          this.#one_of_decls
        );
        if (!Array.isArray(data) && typeof data == "object") {
          if ("selected_ptr" in data && data.selected_ptr != undefined) {
            this.selected_ptr = data.selected_ptr;
          }
        }
      }
      get selected_ptr() {
        return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
      }
      set selected_ptr(value: number) {
        pb_1.Message.setField(this, 1, value);
      }
      static fromObject(data: { selected_ptr?: number }): SelectChainResponse {
        const message = new SelectChainResponse({});
        if (data.selected_ptr != null) {
          message.selected_ptr = data.selected_ptr;
        }
        return message;
      }
      toObject() {
        const data: {
          selected_ptr?: number;
        } = {};
        if (this.selected_ptr != null) {
          data.selected_ptr = this.selected_ptr;
        }
        return data;
      }
      serialize(): Uint8Array;
      serialize(w: pb_1.BinaryWriter): void;
      serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.selected_ptr != 0) writer.writeInt32(1, this.selected_ptr);
        if (!w) return writer.getResultBuffer();
      }
      static deserialize(
        bytes: Uint8Array | pb_1.BinaryReader
      ): SelectChainResponse {
        const reader =
            bytes instanceof pb_1.BinaryReader
              ? bytes
              : new pb_1.BinaryReader(bytes),
          message = new SelectChainResponse();
        while (reader.nextField()) {
          if (reader.isEndGroup()) break;
          switch (reader.getFieldNumber()) {
            case 1:
              message.selected_ptr = reader.readInt32();
              break;
            default:
              reader.skipField();
          }
        }
        return message;
      }
      serializeBinary(): Uint8Array {
        return this.serialize();
      }
      static deserializeBinary(bytes: Uint8Array): SelectChainResponse {
        return SelectChainResponse.deserialize(bytes);
      }
    }
    export class SelectEffectYnResponse extends pb_1.Message {
      #one_of_decls: number[][] = [];
      constructor(
        data?:
          | any[]
          | {
              selected?: boolean;
            }
      ) {
        super();
        pb_1.Message.initialize(
          this,
          Array.isArray(data) ? data : [],
          0,
          -1,
          [],
          this.#one_of_decls
        );
        if (!Array.isArray(data) && typeof data == "object") {
          if ("selected" in data && data.selected != undefined) {
            this.selected = data.selected;
          }
        }
      }
      get selected() {
        return pb_1.Message.getFieldWithDefault(this, 1, false) as boolean;
      }
      set selected(value: boolean) {
        pb_1.Message.setField(this, 1, value);
      }
      static fromObject(data: { selected?: boolean }): SelectEffectYnResponse {
        const message = new SelectEffectYnResponse({});
        if (data.selected != null) {
          message.selected = data.selected;
        }
        return message;
      }
      toObject() {
        const data: {
          selected?: boolean;
        } = {};
        if (this.selected != null) {
          data.selected = this.selected;
        }
        return data;
      }
      serialize(): Uint8Array;
      serialize(w: pb_1.BinaryWriter): void;
      serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.selected != false) writer.writeBool(1, this.selected);
        if (!w) return writer.getResultBuffer();
      }
      static deserialize(
        bytes: Uint8Array | pb_1.BinaryReader
      ): SelectEffectYnResponse {
        const reader =
            bytes instanceof pb_1.BinaryReader
              ? bytes
              : new pb_1.BinaryReader(bytes),
          message = new SelectEffectYnResponse();
        while (reader.nextField()) {
          if (reader.isEndGroup()) break;
          switch (reader.getFieldNumber()) {
            case 1:
              message.selected = reader.readBool();
              break;
            default:
              reader.skipField();
          }
        }
        return message;
      }
      serializeBinary(): Uint8Array {
        return this.serialize();
      }
      static deserializeBinary(bytes: Uint8Array): SelectEffectYnResponse {
        return SelectEffectYnResponse.deserialize(bytes);
      }
    }
    export class SelectPositionResponse extends pb_1.Message {
      #one_of_decls: number[][] = [];
      constructor(
        data?:
          | any[]
          | {
              position?: CardPosition;
            }
      ) {
        super();
        pb_1.Message.initialize(
          this,
          Array.isArray(data) ? data : [],
          0,
          -1,
          [],
          this.#one_of_decls
        );
        if (!Array.isArray(data) && typeof data == "object") {
          if ("position" in data && data.position != undefined) {
            this.position = data.position;
          }
        }
      }
      get position() {
        return pb_1.Message.getFieldWithDefault(
          this,
          1,
          CardPosition.FACEUP_ATTACK
        ) as CardPosition;
      }
      set position(value: CardPosition) {
        pb_1.Message.setField(this, 1, value);
      }
      static fromObject(data: {
        position?: CardPosition;
      }): SelectPositionResponse {
        const message = new SelectPositionResponse({});
        if (data.position != null) {
          message.position = data.position;
        }
        return message;
      }
      toObject() {
        const data: {
          position?: CardPosition;
        } = {};
        if (this.position != null) {
          data.position = this.position;
        }
        return data;
      }
      serialize(): Uint8Array;
      serialize(w: pb_1.BinaryWriter): void;
      serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.position != CardPosition.FACEUP_ATTACK)
          writer.writeEnum(1, this.position);
        if (!w) return writer.getResultBuffer();
      }
      static deserialize(
        bytes: Uint8Array | pb_1.BinaryReader
      ): SelectPositionResponse {
        const reader =
            bytes instanceof pb_1.BinaryReader
              ? bytes
              : new pb_1.BinaryReader(bytes),
          message = new SelectPositionResponse();
        while (reader.nextField()) {
          if (reader.isEndGroup()) break;
          switch (reader.getFieldNumber()) {
            case 1:
              message.position = reader.readEnum();
              break;
            default:
              reader.skipField();
          }
        }
        return message;
      }
      serializeBinary(): Uint8Array {
        return this.serialize();
      }
      static deserializeBinary(bytes: Uint8Array): SelectPositionResponse {
        return SelectPositionResponse.deserialize(bytes);
      }
    }
    export class SelectOptionResponse extends pb_1.Message {
      #one_of_decls: number[][] = [];
      constructor(
        data?:
          | any[]
          | {
              code?: number;
            }
      ) {
        super();
        pb_1.Message.initialize(
          this,
          Array.isArray(data) ? data : [],
          0,
          -1,
          [],
          this.#one_of_decls
        );
        if (!Array.isArray(data) && typeof data == "object") {
          if ("code" in data && data.code != undefined) {
            this.code = data.code;
          }
        }
      }
      get code() {
        return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
      }
      set code(value: number) {
        pb_1.Message.setField(this, 1, value);
      }
      static fromObject(data: { code?: number }): SelectOptionResponse {
        const message = new SelectOptionResponse({});
        if (data.code != null) {
          message.code = data.code;
        }
        return message;
      }
      toObject() {
        const data: {
          code?: number;
        } = {};
        if (this.code != null) {
          data.code = this.code;
        }
        return data;
      }
      serialize(): Uint8Array;
      serialize(w: pb_1.BinaryWriter): void;
      serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.code != 0) writer.writeInt32(1, this.code);
        if (!w) return writer.getResultBuffer();
      }
      static deserialize(
        bytes: Uint8Array | pb_1.BinaryReader
      ): SelectOptionResponse {
        const reader =
            bytes instanceof pb_1.BinaryReader
              ? bytes
              : new pb_1.BinaryReader(bytes),
          message = new SelectOptionResponse();
        while (reader.nextField()) {
          if (reader.isEndGroup()) break;
          switch (reader.getFieldNumber()) {
            case 1:
              message.code = reader.readInt32();
              break;
            default:
              reader.skipField();
          }
        }
        return message;
      }
      serializeBinary(): Uint8Array {
        return this.serialize();
      }
      static deserializeBinary(bytes: Uint8Array): SelectOptionResponse {
        return SelectOptionResponse.deserialize(bytes);
      }
    }
    export class SelectBattleCmdResponse extends pb_1.Message {
      #one_of_decls: number[][] = [];
      constructor(
        data?:
          | any[]
          | {
              selected_cmd?: number;
            }
      ) {
        super();
        pb_1.Message.initialize(
          this,
          Array.isArray(data) ? data : [],
          0,
          -1,
          [],
          this.#one_of_decls
        );
        if (!Array.isArray(data) && typeof data == "object") {
          if ("selected_cmd" in data && data.selected_cmd != undefined) {
            this.selected_cmd = data.selected_cmd;
          }
        }
      }
      get selected_cmd() {
        return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
      }
      set selected_cmd(value: number) {
        pb_1.Message.setField(this, 1, value);
      }
      static fromObject(data: {
        selected_cmd?: number;
      }): SelectBattleCmdResponse {
        const message = new SelectBattleCmdResponse({});
        if (data.selected_cmd != null) {
          message.selected_cmd = data.selected_cmd;
        }
        return message;
      }
      toObject() {
        const data: {
          selected_cmd?: number;
        } = {};
        if (this.selected_cmd != null) {
          data.selected_cmd = this.selected_cmd;
        }
        return data;
      }
      serialize(): Uint8Array;
      serialize(w: pb_1.BinaryWriter): void;
      serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.selected_cmd != 0) writer.writeInt32(1, this.selected_cmd);
        if (!w) return writer.getResultBuffer();
      }
      static deserialize(
        bytes: Uint8Array | pb_1.BinaryReader
      ): SelectBattleCmdResponse {
        const reader =
            bytes instanceof pb_1.BinaryReader
              ? bytes
              : new pb_1.BinaryReader(bytes),
          message = new SelectBattleCmdResponse();
        while (reader.nextField()) {
          if (reader.isEndGroup()) break;
          switch (reader.getFieldNumber()) {
            case 1:
              message.selected_cmd = reader.readInt32();
              break;
            default:
              reader.skipField();
          }
        }
        return message;
      }
      serializeBinary(): Uint8Array {
        return this.serialize();
      }
      static deserializeBinary(bytes: Uint8Array): SelectBattleCmdResponse {
        return SelectBattleCmdResponse.deserialize(bytes);
      }
    }
    export class SelectUnselectCardResponse extends pb_1.Message {
      #one_of_decls: number[][] = [];
      constructor(
        data?:
          | any[]
          | {
              cancel_or_finish?: boolean;
              selected_ptr?: number;
            }
      ) {
        super();
        pb_1.Message.initialize(
          this,
          Array.isArray(data) ? data : [],
          0,
          -1,
          [],
          this.#one_of_decls
        );
        if (!Array.isArray(data) && typeof data == "object") {
          if (
            "cancel_or_finish" in data &&
            data.cancel_or_finish != undefined
          ) {
            this.cancel_or_finish = data.cancel_or_finish;
          }
          if ("selected_ptr" in data && data.selected_ptr != undefined) {
            this.selected_ptr = data.selected_ptr;
          }
        }
      }
      get cancel_or_finish() {
        return pb_1.Message.getFieldWithDefault(this, 1, false) as boolean;
      }
      set cancel_or_finish(value: boolean) {
        pb_1.Message.setField(this, 1, value);
      }
      get selected_ptr() {
        return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
      }
      set selected_ptr(value: number) {
        pb_1.Message.setField(this, 2, value);
      }
      static fromObject(data: {
        cancel_or_finish?: boolean;
        selected_ptr?: number;
      }): SelectUnselectCardResponse {
        const message = new SelectUnselectCardResponse({});
        if (data.cancel_or_finish != null) {
          message.cancel_or_finish = data.cancel_or_finish;
        }
        if (data.selected_ptr != null) {
          message.selected_ptr = data.selected_ptr;
        }
        return message;
      }
      toObject() {
        const data: {
          cancel_or_finish?: boolean;
          selected_ptr?: number;
        } = {};
        if (this.cancel_or_finish != null) {
          data.cancel_or_finish = this.cancel_or_finish;
        }
        if (this.selected_ptr != null) {
          data.selected_ptr = this.selected_ptr;
        }
        return data;
      }
      serialize(): Uint8Array;
      serialize(w: pb_1.BinaryWriter): void;
      serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.cancel_or_finish != false)
          writer.writeBool(1, this.cancel_or_finish);
        if (this.selected_ptr != 0) writer.writeInt32(2, this.selected_ptr);
        if (!w) return writer.getResultBuffer();
      }
      static deserialize(
        bytes: Uint8Array | pb_1.BinaryReader
      ): SelectUnselectCardResponse {
        const reader =
            bytes instanceof pb_1.BinaryReader
              ? bytes
              : new pb_1.BinaryReader(bytes),
          message = new SelectUnselectCardResponse();
        while (reader.nextField()) {
          if (reader.isEndGroup()) break;
          switch (reader.getFieldNumber()) {
            case 1:
              message.cancel_or_finish = reader.readBool();
              break;
            case 2:
              message.selected_ptr = reader.readInt32();
              break;
            default:
              reader.skipField();
          }
        }
        return message;
      }
      serializeBinary(): Uint8Array {
        return this.serialize();
      }
      static deserializeBinary(bytes: Uint8Array): SelectUnselectCardResponse {
        return SelectUnselectCardResponse.deserialize(bytes);
      }
    }
  }
  export class StocJoinGame extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(
      data?:
        | any[]
        | {
            lflist?: number;
            rule?: number;
            mode?: number;
            duel_rule?: number;
            no_check_deck?: boolean;
            no_shuffle_deck?: boolean;
            start_lp?: number;
            start_hand?: number;
            draw_count?: number;
            time_limit?: number;
          }
    ) {
      super();
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [],
        this.#one_of_decls
      );
      if (!Array.isArray(data) && typeof data == "object") {
        if ("lflist" in data && data.lflist != undefined) {
          this.lflist = data.lflist;
        }
        if ("rule" in data && data.rule != undefined) {
          this.rule = data.rule;
        }
        if ("mode" in data && data.mode != undefined) {
          this.mode = data.mode;
        }
        if ("duel_rule" in data && data.duel_rule != undefined) {
          this.duel_rule = data.duel_rule;
        }
        if ("no_check_deck" in data && data.no_check_deck != undefined) {
          this.no_check_deck = data.no_check_deck;
        }
        if ("no_shuffle_deck" in data && data.no_shuffle_deck != undefined) {
          this.no_shuffle_deck = data.no_shuffle_deck;
        }
        if ("start_lp" in data && data.start_lp != undefined) {
          this.start_lp = data.start_lp;
        }
        if ("start_hand" in data && data.start_hand != undefined) {
          this.start_hand = data.start_hand;
        }
        if ("draw_count" in data && data.draw_count != undefined) {
          this.draw_count = data.draw_count;
        }
        if ("time_limit" in data && data.time_limit != undefined) {
          this.time_limit = data.time_limit;
        }
      }
    }
    get lflist() {
      return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
    }
    set lflist(value: number) {
      pb_1.Message.setField(this, 1, value);
    }
    get rule() {
      return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
    }
    set rule(value: number) {
      pb_1.Message.setField(this, 2, value);
    }
    get mode() {
      return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
    }
    set mode(value: number) {
      pb_1.Message.setField(this, 3, value);
    }
    get duel_rule() {
      return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
    }
    set duel_rule(value: number) {
      pb_1.Message.setField(this, 4, value);
    }
    get no_check_deck() {
      return pb_1.Message.getFieldWithDefault(this, 5, false) as boolean;
    }
    set no_check_deck(value: boolean) {
      pb_1.Message.setField(this, 5, value);
    }
    get no_shuffle_deck() {
      return pb_1.Message.getFieldWithDefault(this, 6, false) as boolean;
    }
    set no_shuffle_deck(value: boolean) {
      pb_1.Message.setField(this, 6, value);
    }
    get start_lp() {
      return pb_1.Message.getFieldWithDefault(this, 7, 0) as number;
    }
    set start_lp(value: number) {
      pb_1.Message.setField(this, 7, value);
    }
    get start_hand() {
      return pb_1.Message.getFieldWithDefault(this, 8, 0) as number;
    }
    set start_hand(value: number) {
      pb_1.Message.setField(this, 8, value);
    }
    get draw_count() {
      return pb_1.Message.getFieldWithDefault(this, 9, 0) as number;
    }
    set draw_count(value: number) {
      pb_1.Message.setField(this, 9, value);
    }
    get time_limit() {
      return pb_1.Message.getFieldWithDefault(this, 10, 0) as number;
    }
    set time_limit(value: number) {
      pb_1.Message.setField(this, 10, value);
    }
    static fromObject(data: {
      lflist?: number;
      rule?: number;
      mode?: number;
      duel_rule?: number;
      no_check_deck?: boolean;
      no_shuffle_deck?: boolean;
      start_lp?: number;
      start_hand?: number;
      draw_count?: number;
      time_limit?: number;
    }): StocJoinGame {
      const message = new StocJoinGame({});
      if (data.lflist != null) {
        message.lflist = data.lflist;
      }
      if (data.rule != null) {
        message.rule = data.rule;
      }
      if (data.mode != null) {
        message.mode = data.mode;
      }
      if (data.duel_rule != null) {
        message.duel_rule = data.duel_rule;
      }
      if (data.no_check_deck != null) {
        message.no_check_deck = data.no_check_deck;
      }
      if (data.no_shuffle_deck != null) {
        message.no_shuffle_deck = data.no_shuffle_deck;
      }
      if (data.start_lp != null) {
        message.start_lp = data.start_lp;
      }
      if (data.start_hand != null) {
        message.start_hand = data.start_hand;
      }
      if (data.draw_count != null) {
        message.draw_count = data.draw_count;
      }
      if (data.time_limit != null) {
        message.time_limit = data.time_limit;
      }
      return message;
    }
    toObject() {
      const data: {
        lflist?: number;
        rule?: number;
        mode?: number;
        duel_rule?: number;
        no_check_deck?: boolean;
        no_shuffle_deck?: boolean;
        start_lp?: number;
        start_hand?: number;
        draw_count?: number;
        time_limit?: number;
      } = {};
      if (this.lflist != null) {
        data.lflist = this.lflist;
      }
      if (this.rule != null) {
        data.rule = this.rule;
      }
      if (this.mode != null) {
        data.mode = this.mode;
      }
      if (this.duel_rule != null) {
        data.duel_rule = this.duel_rule;
      }
      if (this.no_check_deck != null) {
        data.no_check_deck = this.no_check_deck;
      }
      if (this.no_shuffle_deck != null) {
        data.no_shuffle_deck = this.no_shuffle_deck;
      }
      if (this.start_lp != null) {
        data.start_lp = this.start_lp;
      }
      if (this.start_hand != null) {
        data.start_hand = this.start_hand;
      }
      if (this.draw_count != null) {
        data.draw_count = this.draw_count;
      }
      if (this.time_limit != null) {
        data.time_limit = this.time_limit;
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.lflist != 0) writer.writeInt32(1, this.lflist);
      if (this.rule != 0) writer.writeInt32(2, this.rule);
      if (this.mode != 0) writer.writeInt32(3, this.mode);
      if (this.duel_rule != 0) writer.writeInt32(4, this.duel_rule);
      if (this.no_check_deck != false) writer.writeBool(5, this.no_check_deck);
      if (this.no_shuffle_deck != false)
        writer.writeBool(6, this.no_shuffle_deck);
      if (this.start_lp != 0) writer.writeInt32(7, this.start_lp);
      if (this.start_hand != 0) writer.writeInt32(8, this.start_hand);
      if (this.draw_count != 0) writer.writeInt32(9, this.draw_count);
      if (this.time_limit != 0) writer.writeInt32(10, this.time_limit);
      if (!w) return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): StocJoinGame {
      const reader =
          bytes instanceof pb_1.BinaryReader
            ? bytes
            : new pb_1.BinaryReader(bytes),
        message = new StocJoinGame();
      while (reader.nextField()) {
        if (reader.isEndGroup()) break;
        switch (reader.getFieldNumber()) {
          case 1:
            message.lflist = reader.readInt32();
            break;
          case 2:
            message.rule = reader.readInt32();
            break;
          case 3:
            message.mode = reader.readInt32();
            break;
          case 4:
            message.duel_rule = reader.readInt32();
            break;
          case 5:
            message.no_check_deck = reader.readBool();
            break;
          case 6:
            message.no_shuffle_deck = reader.readBool();
            break;
          case 7:
            message.start_lp = reader.readInt32();
            break;
          case 8:
            message.start_hand = reader.readInt32();
            break;
          case 9:
            message.draw_count = reader.readInt32();
            break;
          case 10:
            message.time_limit = reader.readInt32();
            break;
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): StocJoinGame {
      return StocJoinGame.deserialize(bytes);
    }
  }
  export class StocChat extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(
      data?:
        | any[]
        | {
            player?: number;
            msg?: string;
          }
    ) {
      super();
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [],
        this.#one_of_decls
      );
      if (!Array.isArray(data) && typeof data == "object") {
        if ("player" in data && data.player != undefined) {
          this.player = data.player;
        }
        if ("msg" in data && data.msg != undefined) {
          this.msg = data.msg;
        }
      }
    }
    get player() {
      return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
    }
    set player(value: number) {
      pb_1.Message.setField(this, 1, value);
    }
    get msg() {
      return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
    }
    set msg(value: string) {
      pb_1.Message.setField(this, 2, value);
    }
    static fromObject(data: { player?: number; msg?: string }): StocChat {
      const message = new StocChat({});
      if (data.player != null) {
        message.player = data.player;
      }
      if (data.msg != null) {
        message.msg = data.msg;
      }
      return message;
    }
    toObject() {
      const data: {
        player?: number;
        msg?: string;
      } = {};
      if (this.player != null) {
        data.player = this.player;
      }
      if (this.msg != null) {
        data.msg = this.msg;
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.player != 0) writer.writeInt32(1, this.player);
      if (this.msg.length) writer.writeString(2, this.msg);
      if (!w) return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): StocChat {
      const reader =
          bytes instanceof pb_1.BinaryReader
            ? bytes
            : new pb_1.BinaryReader(bytes),
        message = new StocChat();
      while (reader.nextField()) {
        if (reader.isEndGroup()) break;
        switch (reader.getFieldNumber()) {
          case 1:
            message.player = reader.readInt32();
            break;
          case 2:
            message.msg = reader.readString();
            break;
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): StocChat {
      return StocChat.deserialize(bytes);
    }
  }
  export class StocHsPlayerEnter extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(
      data?:
        | any[]
        | {
            name?: string;
            pos?: number;
          }
    ) {
      super();
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [],
        this.#one_of_decls
      );
      if (!Array.isArray(data) && typeof data == "object") {
        if ("name" in data && data.name != undefined) {
          this.name = data.name;
        }
        if ("pos" in data && data.pos != undefined) {
          this.pos = data.pos;
        }
      }
    }
    get name() {
      return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
    }
    set name(value: string) {
      pb_1.Message.setField(this, 1, value);
    }
    get pos() {
      return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
    }
    set pos(value: number) {
      pb_1.Message.setField(this, 2, value);
    }
    static fromObject(data: {
      name?: string;
      pos?: number;
    }): StocHsPlayerEnter {
      const message = new StocHsPlayerEnter({});
      if (data.name != null) {
        message.name = data.name;
      }
      if (data.pos != null) {
        message.pos = data.pos;
      }
      return message;
    }
    toObject() {
      const data: {
        name?: string;
        pos?: number;
      } = {};
      if (this.name != null) {
        data.name = this.name;
      }
      if (this.pos != null) {
        data.pos = this.pos;
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.name.length) writer.writeString(1, this.name);
      if (this.pos != 0) writer.writeInt32(2, this.pos);
      if (!w) return writer.getResultBuffer();
    }
    static deserialize(
      bytes: Uint8Array | pb_1.BinaryReader
    ): StocHsPlayerEnter {
      const reader =
          bytes instanceof pb_1.BinaryReader
            ? bytes
            : new pb_1.BinaryReader(bytes),
        message = new StocHsPlayerEnter();
      while (reader.nextField()) {
        if (reader.isEndGroup()) break;
        switch (reader.getFieldNumber()) {
          case 1:
            message.name = reader.readString();
            break;
          case 2:
            message.pos = reader.readInt32();
            break;
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): StocHsPlayerEnter {
      return StocHsPlayerEnter.deserialize(bytes);
    }
  }
  export class StocTypeChange extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(
      data?:
        | any[]
        | {
            self_type?: StocTypeChange.SelfType;
            is_host?: boolean;
          }
    ) {
      super();
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [],
        this.#one_of_decls
      );
      if (!Array.isArray(data) && typeof data == "object") {
        if ("self_type" in data && data.self_type != undefined) {
          this.self_type = data.self_type;
        }
        if ("is_host" in data && data.is_host != undefined) {
          this.is_host = data.is_host;
        }
      }
    }
    get self_type() {
      return pb_1.Message.getFieldWithDefault(
        this,
        1,
        StocTypeChange.SelfType.UNKNOWN
      ) as StocTypeChange.SelfType;
    }
    set self_type(value: StocTypeChange.SelfType) {
      pb_1.Message.setField(this, 1, value);
    }
    get is_host() {
      return pb_1.Message.getFieldWithDefault(this, 2, false) as boolean;
    }
    set is_host(value: boolean) {
      pb_1.Message.setField(this, 2, value);
    }
    static fromObject(data: {
      self_type?: StocTypeChange.SelfType;
      is_host?: boolean;
    }): StocTypeChange {
      const message = new StocTypeChange({});
      if (data.self_type != null) {
        message.self_type = data.self_type;
      }
      if (data.is_host != null) {
        message.is_host = data.is_host;
      }
      return message;
    }
    toObject() {
      const data: {
        self_type?: StocTypeChange.SelfType;
        is_host?: boolean;
      } = {};
      if (this.self_type != null) {
        data.self_type = this.self_type;
      }
      if (this.is_host != null) {
        data.is_host = this.is_host;
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.self_type != StocTypeChange.SelfType.UNKNOWN)
        writer.writeEnum(1, this.self_type);
      if (this.is_host != false) writer.writeBool(2, this.is_host);
      if (!w) return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): StocTypeChange {
      const reader =
          bytes instanceof pb_1.BinaryReader
            ? bytes
            : new pb_1.BinaryReader(bytes),
        message = new StocTypeChange();
      while (reader.nextField()) {
        if (reader.isEndGroup()) break;
        switch (reader.getFieldNumber()) {
          case 1:
            message.self_type = reader.readEnum();
            break;
          case 2:
            message.is_host = reader.readBool();
            break;
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): StocTypeChange {
      return StocTypeChange.deserialize(bytes);
    }
  }
  export namespace StocTypeChange {
    export enum SelfType {
      UNKNOWN = 0,
      PLAYER1 = 1,
      PLAYER2 = 2,
      PLAYER3 = 3,
      PLAYER4 = 4,
      PLAYER5 = 5,
      PLAYER6 = 6,
      OBSERVER = 100,
    }
  }
  export class StocHsPlayerChange extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(
      data?:
        | any[]
        | {
            state?: StocHsPlayerChange.State;
            pos?: number;
            moved_pos?: number;
          }
    ) {
      super();
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [],
        this.#one_of_decls
      );
      if (!Array.isArray(data) && typeof data == "object") {
        if ("state" in data && data.state != undefined) {
          this.state = data.state;
        }
        if ("pos" in data && data.pos != undefined) {
          this.pos = data.pos;
        }
        if ("moved_pos" in data && data.moved_pos != undefined) {
          this.moved_pos = data.moved_pos;
        }
      }
    }
    get state() {
      return pb_1.Message.getFieldWithDefault(
        this,
        1,
        StocHsPlayerChange.State.UNKNOWN
      ) as StocHsPlayerChange.State;
    }
    set state(value: StocHsPlayerChange.State) {
      pb_1.Message.setField(this, 1, value);
    }
    get pos() {
      return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
    }
    set pos(value: number) {
      pb_1.Message.setField(this, 2, value);
    }
    get moved_pos() {
      return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
    }
    set moved_pos(value: number) {
      pb_1.Message.setField(this, 3, value);
    }
    static fromObject(data: {
      state?: StocHsPlayerChange.State;
      pos?: number;
      moved_pos?: number;
    }): StocHsPlayerChange {
      const message = new StocHsPlayerChange({});
      if (data.state != null) {
        message.state = data.state;
      }
      if (data.pos != null) {
        message.pos = data.pos;
      }
      if (data.moved_pos != null) {
        message.moved_pos = data.moved_pos;
      }
      return message;
    }
    toObject() {
      const data: {
        state?: StocHsPlayerChange.State;
        pos?: number;
        moved_pos?: number;
      } = {};
      if (this.state != null) {
        data.state = this.state;
      }
      if (this.pos != null) {
        data.pos = this.pos;
      }
      if (this.moved_pos != null) {
        data.moved_pos = this.moved_pos;
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.state != StocHsPlayerChange.State.UNKNOWN)
        writer.writeEnum(1, this.state);
      if (this.pos != 0) writer.writeInt32(2, this.pos);
      if (this.moved_pos != 0) writer.writeInt32(3, this.moved_pos);
      if (!w) return writer.getResultBuffer();
    }
    static deserialize(
      bytes: Uint8Array | pb_1.BinaryReader
    ): StocHsPlayerChange {
      const reader =
          bytes instanceof pb_1.BinaryReader
            ? bytes
            : new pb_1.BinaryReader(bytes),
        message = new StocHsPlayerChange();
      while (reader.nextField()) {
        if (reader.isEndGroup()) break;
        switch (reader.getFieldNumber()) {
          case 1:
            message.state = reader.readEnum();
            break;
          case 2:
            message.pos = reader.readInt32();
            break;
          case 3:
            message.moved_pos = reader.readInt32();
            break;
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): StocHsPlayerChange {
      return StocHsPlayerChange.deserialize(bytes);
    }
  }
  export namespace StocHsPlayerChange {
    export enum State {
      UNKNOWN = 0,
      MOVE = 1,
      READY = 2,
      NO_READY = 3,
      LEAVE = 4,
      TO_OBSERVER = 5,
    }
  }
  export class StocHsWatchChange extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(
      data?:
        | any[]
        | {
            count?: number;
          }
    ) {
      super();
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [],
        this.#one_of_decls
      );
      if (!Array.isArray(data) && typeof data == "object") {
        if ("count" in data && data.count != undefined) {
          this.count = data.count;
        }
      }
    }
    get count() {
      return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
    }
    set count(value: number) {
      pb_1.Message.setField(this, 1, value);
    }
    static fromObject(data: { count?: number }): StocHsWatchChange {
      const message = new StocHsWatchChange({});
      if (data.count != null) {
        message.count = data.count;
      }
      return message;
    }
    toObject() {
      const data: {
        count?: number;
      } = {};
      if (this.count != null) {
        data.count = this.count;
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.count != 0) writer.writeInt32(1, this.count);
      if (!w) return writer.getResultBuffer();
    }
    static deserialize(
      bytes: Uint8Array | pb_1.BinaryReader
    ): StocHsWatchChange {
      const reader =
          bytes instanceof pb_1.BinaryReader
            ? bytes
            : new pb_1.BinaryReader(bytes),
        message = new StocHsWatchChange();
      while (reader.nextField()) {
        if (reader.isEndGroup()) break;
        switch (reader.getFieldNumber()) {
          case 1:
            message.count = reader.readInt32();
            break;
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): StocHsWatchChange {
      return StocHsWatchChange.deserialize(bytes);
    }
  }
  export class StocSelectHand extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {}) {
      super();
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [],
        this.#one_of_decls
      );
      if (!Array.isArray(data) && typeof data == "object") {
      }
    }
    static fromObject(data: {}): StocSelectHand {
      const message = new StocSelectHand({});
      return message;
    }
    toObject() {
      const data: {} = {};
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (!w) return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): StocSelectHand {
      const reader =
          bytes instanceof pb_1.BinaryReader
            ? bytes
            : new pb_1.BinaryReader(bytes),
        message = new StocSelectHand();
      while (reader.nextField()) {
        if (reader.isEndGroup()) break;
        switch (reader.getFieldNumber()) {
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): StocSelectHand {
      return StocSelectHand.deserialize(bytes);
    }
  }
  export class StocHandResult extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(
      data?:
        | any[]
        | {
            meResult?: HandType;
            opResult?: HandType;
          }
    ) {
      super();
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [],
        this.#one_of_decls
      );
      if (!Array.isArray(data) && typeof data == "object") {
        if ("meResult" in data && data.meResult != undefined) {
          this.meResult = data.meResult;
        }
        if ("opResult" in data && data.opResult != undefined) {
          this.opResult = data.opResult;
        }
      }
    }
    get meResult() {
      return pb_1.Message.getFieldWithDefault(
        this,
        1,
        HandType.UNKNOWN
      ) as HandType;
    }
    set meResult(value: HandType) {
      pb_1.Message.setField(this, 1, value);
    }
    get opResult() {
      return pb_1.Message.getFieldWithDefault(
        this,
        2,
        HandType.UNKNOWN
      ) as HandType;
    }
    set opResult(value: HandType) {
      pb_1.Message.setField(this, 2, value);
    }
    static fromObject(data: {
      meResult?: HandType;
      opResult?: HandType;
    }): StocHandResult {
      const message = new StocHandResult({});
      if (data.meResult != null) {
        message.meResult = data.meResult;
      }
      if (data.opResult != null) {
        message.opResult = data.opResult;
      }
      return message;
    }
    toObject() {
      const data: {
        meResult?: HandType;
        opResult?: HandType;
      } = {};
      if (this.meResult != null) {
        data.meResult = this.meResult;
      }
      if (this.opResult != null) {
        data.opResult = this.opResult;
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.meResult != HandType.UNKNOWN) writer.writeEnum(1, this.meResult);
      if (this.opResult != HandType.UNKNOWN) writer.writeEnum(2, this.opResult);
      if (!w) return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): StocHandResult {
      const reader =
          bytes instanceof pb_1.BinaryReader
            ? bytes
            : new pb_1.BinaryReader(bytes),
        message = new StocHandResult();
      while (reader.nextField()) {
        if (reader.isEndGroup()) break;
        switch (reader.getFieldNumber()) {
          case 1:
            message.meResult = reader.readEnum();
            break;
          case 2:
            message.opResult = reader.readEnum();
            break;
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): StocHandResult {
      return StocHandResult.deserialize(bytes);
    }
  }
  export class StocSelectTp extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {}) {
      super();
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [],
        this.#one_of_decls
      );
      if (!Array.isArray(data) && typeof data == "object") {
      }
    }
    static fromObject(data: {}): StocSelectTp {
      const message = new StocSelectTp({});
      return message;
    }
    toObject() {
      const data: {} = {};
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (!w) return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): StocSelectTp {
      const reader =
          bytes instanceof pb_1.BinaryReader
            ? bytes
            : new pb_1.BinaryReader(bytes),
        message = new StocSelectTp();
      while (reader.nextField()) {
        if (reader.isEndGroup()) break;
        switch (reader.getFieldNumber()) {
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): StocSelectTp {
      return StocSelectTp.deserialize(bytes);
    }
  }
  export class StocDeckCount extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(
      data?:
        | any[]
        | {
            meMain?: number;
            meExtra?: number;
            meSide?: number;
            opMain?: number;
            opExtra?: number;
            opSide?: number;
          }
    ) {
      super();
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [],
        this.#one_of_decls
      );
      if (!Array.isArray(data) && typeof data == "object") {
        if ("meMain" in data && data.meMain != undefined) {
          this.meMain = data.meMain;
        }
        if ("meExtra" in data && data.meExtra != undefined) {
          this.meExtra = data.meExtra;
        }
        if ("meSide" in data && data.meSide != undefined) {
          this.meSide = data.meSide;
        }
        if ("opMain" in data && data.opMain != undefined) {
          this.opMain = data.opMain;
        }
        if ("opExtra" in data && data.opExtra != undefined) {
          this.opExtra = data.opExtra;
        }
        if ("opSide" in data && data.opSide != undefined) {
          this.opSide = data.opSide;
        }
      }
    }
    get meMain() {
      return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
    }
    set meMain(value: number) {
      pb_1.Message.setField(this, 1, value);
    }
    get meExtra() {
      return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
    }
    set meExtra(value: number) {
      pb_1.Message.setField(this, 2, value);
    }
    get meSide() {
      return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
    }
    set meSide(value: number) {
      pb_1.Message.setField(this, 3, value);
    }
    get opMain() {
      return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
    }
    set opMain(value: number) {
      pb_1.Message.setField(this, 4, value);
    }
    get opExtra() {
      return pb_1.Message.getFieldWithDefault(this, 5, 0) as number;
    }
    set opExtra(value: number) {
      pb_1.Message.setField(this, 5, value);
    }
    get opSide() {
      return pb_1.Message.getFieldWithDefault(this, 6, 0) as number;
    }
    set opSide(value: number) {
      pb_1.Message.setField(this, 6, value);
    }
    static fromObject(data: {
      meMain?: number;
      meExtra?: number;
      meSide?: number;
      opMain?: number;
      opExtra?: number;
      opSide?: number;
    }): StocDeckCount {
      const message = new StocDeckCount({});
      if (data.meMain != null) {
        message.meMain = data.meMain;
      }
      if (data.meExtra != null) {
        message.meExtra = data.meExtra;
      }
      if (data.meSide != null) {
        message.meSide = data.meSide;
      }
      if (data.opMain != null) {
        message.opMain = data.opMain;
      }
      if (data.opExtra != null) {
        message.opExtra = data.opExtra;
      }
      if (data.opSide != null) {
        message.opSide = data.opSide;
      }
      return message;
    }
    toObject() {
      const data: {
        meMain?: number;
        meExtra?: number;
        meSide?: number;
        opMain?: number;
        opExtra?: number;
        opSide?: number;
      } = {};
      if (this.meMain != null) {
        data.meMain = this.meMain;
      }
      if (this.meExtra != null) {
        data.meExtra = this.meExtra;
      }
      if (this.meSide != null) {
        data.meSide = this.meSide;
      }
      if (this.opMain != null) {
        data.opMain = this.opMain;
      }
      if (this.opExtra != null) {
        data.opExtra = this.opExtra;
      }
      if (this.opSide != null) {
        data.opSide = this.opSide;
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.meMain != 0) writer.writeInt32(1, this.meMain);
      if (this.meExtra != 0) writer.writeInt32(2, this.meExtra);
      if (this.meSide != 0) writer.writeInt32(3, this.meSide);
      if (this.opMain != 0) writer.writeInt32(4, this.opMain);
      if (this.opExtra != 0) writer.writeInt32(5, this.opExtra);
      if (this.opSide != 0) writer.writeInt32(6, this.opSide);
      if (!w) return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): StocDeckCount {
      const reader =
          bytes instanceof pb_1.BinaryReader
            ? bytes
            : new pb_1.BinaryReader(bytes),
        message = new StocDeckCount();
      while (reader.nextField()) {
        if (reader.isEndGroup()) break;
        switch (reader.getFieldNumber()) {
          case 1:
            message.meMain = reader.readInt32();
            break;
          case 2:
            message.meExtra = reader.readInt32();
            break;
          case 3:
            message.meSide = reader.readInt32();
            break;
          case 4:
            message.opMain = reader.readInt32();
            break;
          case 5:
            message.opExtra = reader.readInt32();
            break;
          case 6:
            message.opSide = reader.readInt32();
            break;
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): StocDeckCount {
      return StocDeckCount.deserialize(bytes);
    }
  }
  export class StocDuelStart extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {}) {
      super();
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [],
        this.#one_of_decls
      );
      if (!Array.isArray(data) && typeof data == "object") {
      }
    }
    static fromObject(data: {}): StocDuelStart {
      const message = new StocDuelStart({});
      return message;
    }
    toObject() {
      const data: {} = {};
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (!w) return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): StocDuelStart {
      const reader =
          bytes instanceof pb_1.BinaryReader
            ? bytes
            : new pb_1.BinaryReader(bytes),
        message = new StocDuelStart();
      while (reader.nextField()) {
        if (reader.isEndGroup()) break;
        switch (reader.getFieldNumber()) {
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): StocDuelStart {
      return StocDuelStart.deserialize(bytes);
    }
  }
  export class StocTimeLimit extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(
      data?:
        | any[]
        | {
            player?: number;
            left_time?: number;
          }
    ) {
      super();
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [],
        this.#one_of_decls
      );
      if (!Array.isArray(data) && typeof data == "object") {
        if ("player" in data && data.player != undefined) {
          this.player = data.player;
        }
        if ("left_time" in data && data.left_time != undefined) {
          this.left_time = data.left_time;
        }
      }
    }
    get player() {
      return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
    }
    set player(value: number) {
      pb_1.Message.setField(this, 1, value);
    }
    get left_time() {
      return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
    }
    set left_time(value: number) {
      pb_1.Message.setField(this, 2, value);
    }
    static fromObject(data: {
      player?: number;
      left_time?: number;
    }): StocTimeLimit {
      const message = new StocTimeLimit({});
      if (data.player != null) {
        message.player = data.player;
      }
      if (data.left_time != null) {
        message.left_time = data.left_time;
      }
      return message;
    }
    toObject() {
      const data: {
        player?: number;
        left_time?: number;
      } = {};
      if (this.player != null) {
        data.player = this.player;
      }
      if (this.left_time != null) {
        data.left_time = this.left_time;
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.player != 0) writer.writeInt32(1, this.player);
      if (this.left_time != 0) writer.writeInt32(2, this.left_time);
      if (!w) return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): StocTimeLimit {
      const reader =
          bytes instanceof pb_1.BinaryReader
            ? bytes
            : new pb_1.BinaryReader(bytes),
        message = new StocTimeLimit();
      while (reader.nextField()) {
        if (reader.isEndGroup()) break;
        switch (reader.getFieldNumber()) {
          case 1:
            message.player = reader.readInt32();
            break;
          case 2:
            message.left_time = reader.readInt32();
            break;
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): StocTimeLimit {
      return StocTimeLimit.deserialize(bytes);
    }
  }
  export class StocGameMessage extends pb_1.Message {
    #one_of_decls: number[][] = [
      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17],
    ];
    constructor(
      data?:
        | any[]
        | ({} & (
            | {
                start?: StocGameMessage.MsgStart;
                draw?: never;
                new_turn?: never;
                new_phase?: never;
                hint?: never;
                select_idle_cmd?: never;
                select_place?: never;
                move?: never;
                select_card?: never;
                select_chain?: never;
                select_effect_yn?: never;
                select_position?: never;
                select_option?: never;
                shuffle_hand?: never;
                select_battle_cmd?: never;
                pos_change?: never;
                select_unselect_card?: never;
              }
            | {
                start?: never;
                draw?: StocGameMessage.MsgDraw;
                new_turn?: never;
                new_phase?: never;
                hint?: never;
                select_idle_cmd?: never;
                select_place?: never;
                move?: never;
                select_card?: never;
                select_chain?: never;
                select_effect_yn?: never;
                select_position?: never;
                select_option?: never;
                shuffle_hand?: never;
                select_battle_cmd?: never;
                pos_change?: never;
                select_unselect_card?: never;
              }
            | {
                start?: never;
                draw?: never;
                new_turn?: StocGameMessage.MsgNewTurn;
                new_phase?: never;
                hint?: never;
                select_idle_cmd?: never;
                select_place?: never;
                move?: never;
                select_card?: never;
                select_chain?: never;
                select_effect_yn?: never;
                select_position?: never;
                select_option?: never;
                shuffle_hand?: never;
                select_battle_cmd?: never;
                pos_change?: never;
                select_unselect_card?: never;
              }
            | {
                start?: never;
                draw?: never;
                new_turn?: never;
                new_phase?: StocGameMessage.MsgNewPhase;
                hint?: never;
                select_idle_cmd?: never;
                select_place?: never;
                move?: never;
                select_card?: never;
                select_chain?: never;
                select_effect_yn?: never;
                select_position?: never;
                select_option?: never;
                shuffle_hand?: never;
                select_battle_cmd?: never;
                pos_change?: never;
                select_unselect_card?: never;
              }
            | {
                start?: never;
                draw?: never;
                new_turn?: never;
                new_phase?: never;
                hint?: StocGameMessage.MsgHint;
                select_idle_cmd?: never;
                select_place?: never;
                move?: never;
                select_card?: never;
                select_chain?: never;
                select_effect_yn?: never;
                select_position?: never;
                select_option?: never;
                shuffle_hand?: never;
                select_battle_cmd?: never;
                pos_change?: never;
                select_unselect_card?: never;
              }
            | {
                start?: never;
                draw?: never;
                new_turn?: never;
                new_phase?: never;
                hint?: never;
                select_idle_cmd?: StocGameMessage.MsgSelectIdleCmd;
                select_place?: never;
                move?: never;
                select_card?: never;
                select_chain?: never;
                select_effect_yn?: never;
                select_position?: never;
                select_option?: never;
                shuffle_hand?: never;
                select_battle_cmd?: never;
                pos_change?: never;
                select_unselect_card?: never;
              }
            | {
                start?: never;
                draw?: never;
                new_turn?: never;
                new_phase?: never;
                hint?: never;
                select_idle_cmd?: never;
                select_place?: StocGameMessage.MsgSelectPlace;
                move?: never;
                select_card?: never;
                select_chain?: never;
                select_effect_yn?: never;
                select_position?: never;
                select_option?: never;
                shuffle_hand?: never;
                select_battle_cmd?: never;
                pos_change?: never;
                select_unselect_card?: never;
              }
            | {
                start?: never;
                draw?: never;
                new_turn?: never;
                new_phase?: never;
                hint?: never;
                select_idle_cmd?: never;
                select_place?: never;
                move?: StocGameMessage.MsgMove;
                select_card?: never;
                select_chain?: never;
                select_effect_yn?: never;
                select_position?: never;
                select_option?: never;
                shuffle_hand?: never;
                select_battle_cmd?: never;
                pos_change?: never;
                select_unselect_card?: never;
              }
            | {
                start?: never;
                draw?: never;
                new_turn?: never;
                new_phase?: never;
                hint?: never;
                select_idle_cmd?: never;
                select_place?: never;
                move?: never;
                select_card?: StocGameMessage.MsgSelectCard;
                select_chain?: never;
                select_effect_yn?: never;
                select_position?: never;
                select_option?: never;
                shuffle_hand?: never;
                select_battle_cmd?: never;
                pos_change?: never;
                select_unselect_card?: never;
              }
            | {
                start?: never;
                draw?: never;
                new_turn?: never;
                new_phase?: never;
                hint?: never;
                select_idle_cmd?: never;
                select_place?: never;
                move?: never;
                select_card?: never;
                select_chain?: StocGameMessage.MsgSelectChain;
                select_effect_yn?: never;
                select_position?: never;
                select_option?: never;
                shuffle_hand?: never;
                select_battle_cmd?: never;
                pos_change?: never;
                select_unselect_card?: never;
              }
            | {
                start?: never;
                draw?: never;
                new_turn?: never;
                new_phase?: never;
                hint?: never;
                select_idle_cmd?: never;
                select_place?: never;
                move?: never;
                select_card?: never;
                select_chain?: never;
                select_effect_yn?: StocGameMessage.MsgSelectEffectYn;
                select_position?: never;
                select_option?: never;
                shuffle_hand?: never;
                select_battle_cmd?: never;
                pos_change?: never;
                select_unselect_card?: never;
              }
            | {
                start?: never;
                draw?: never;
                new_turn?: never;
                new_phase?: never;
                hint?: never;
                select_idle_cmd?: never;
                select_place?: never;
                move?: never;
                select_card?: never;
                select_chain?: never;
                select_effect_yn?: never;
                select_position?: StocGameMessage.MsgSelectPosition;
                select_option?: never;
                shuffle_hand?: never;
                select_battle_cmd?: never;
                pos_change?: never;
                select_unselect_card?: never;
              }
            | {
                start?: never;
                draw?: never;
                new_turn?: never;
                new_phase?: never;
                hint?: never;
                select_idle_cmd?: never;
                select_place?: never;
                move?: never;
                select_card?: never;
                select_chain?: never;
                select_effect_yn?: never;
                select_position?: never;
                select_option?: StocGameMessage.MsgSelectOption;
                shuffle_hand?: never;
                select_battle_cmd?: never;
                pos_change?: never;
                select_unselect_card?: never;
              }
            | {
                start?: never;
                draw?: never;
                new_turn?: never;
                new_phase?: never;
                hint?: never;
                select_idle_cmd?: never;
                select_place?: never;
                move?: never;
                select_card?: never;
                select_chain?: never;
                select_effect_yn?: never;
                select_position?: never;
                select_option?: never;
                shuffle_hand?: StocGameMessage.MsgShuffleHand;
                select_battle_cmd?: never;
                pos_change?: never;
                select_unselect_card?: never;
              }
            | {
                start?: never;
                draw?: never;
                new_turn?: never;
                new_phase?: never;
                hint?: never;
                select_idle_cmd?: never;
                select_place?: never;
                move?: never;
                select_card?: never;
                select_chain?: never;
                select_effect_yn?: never;
                select_position?: never;
                select_option?: never;
                shuffle_hand?: never;
                select_battle_cmd?: StocGameMessage.MsgSelectBattleCmd;
                pos_change?: never;
                select_unselect_card?: never;
              }
            | {
                start?: never;
                draw?: never;
                new_turn?: never;
                new_phase?: never;
                hint?: never;
                select_idle_cmd?: never;
                select_place?: never;
                move?: never;
                select_card?: never;
                select_chain?: never;
                select_effect_yn?: never;
                select_position?: never;
                select_option?: never;
                shuffle_hand?: never;
                select_battle_cmd?: never;
                pos_change?: StocGameMessage.MsgPosChange;
                select_unselect_card?: never;
              }
            | {
                start?: never;
                draw?: never;
                new_turn?: never;
                new_phase?: never;
                hint?: never;
                select_idle_cmd?: never;
                select_place?: never;
                move?: never;
                select_card?: never;
                select_chain?: never;
                select_effect_yn?: never;
                select_position?: never;
                select_option?: never;
                shuffle_hand?: never;
                select_battle_cmd?: never;
                pos_change?: never;
                select_unselect_card?: StocGameMessage.MsgSelectUnselectCard;
              }
          ))
    ) {
      super();
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [],
        this.#one_of_decls
      );
      if (!Array.isArray(data) && typeof data == "object") {
        if ("start" in data && data.start != undefined) {
          this.start = data.start;
        }
        if ("draw" in data && data.draw != undefined) {
          this.draw = data.draw;
        }
        if ("new_turn" in data && data.new_turn != undefined) {
          this.new_turn = data.new_turn;
        }
        if ("new_phase" in data && data.new_phase != undefined) {
          this.new_phase = data.new_phase;
        }
        if ("hint" in data && data.hint != undefined) {
          this.hint = data.hint;
        }
        if ("select_idle_cmd" in data && data.select_idle_cmd != undefined) {
          this.select_idle_cmd = data.select_idle_cmd;
        }
        if ("select_place" in data && data.select_place != undefined) {
          this.select_place = data.select_place;
        }
        if ("move" in data && data.move != undefined) {
          this.move = data.move;
        }
        if ("select_card" in data && data.select_card != undefined) {
          this.select_card = data.select_card;
        }
        if ("select_chain" in data && data.select_chain != undefined) {
          this.select_chain = data.select_chain;
        }
        if ("select_effect_yn" in data && data.select_effect_yn != undefined) {
          this.select_effect_yn = data.select_effect_yn;
        }
        if ("select_position" in data && data.select_position != undefined) {
          this.select_position = data.select_position;
        }
        if ("select_option" in data && data.select_option != undefined) {
          this.select_option = data.select_option;
        }
        if ("shuffle_hand" in data && data.shuffle_hand != undefined) {
          this.shuffle_hand = data.shuffle_hand;
        }
        if (
          "select_battle_cmd" in data &&
          data.select_battle_cmd != undefined
        ) {
          this.select_battle_cmd = data.select_battle_cmd;
        }
        if ("pos_change" in data && data.pos_change != undefined) {
          this.pos_change = data.pos_change;
        }
        if (
          "select_unselect_card" in data &&
          data.select_unselect_card != undefined
        ) {
          this.select_unselect_card = data.select_unselect_card;
        }
      }
    }
    get start() {
      return pb_1.Message.getWrapperField(
        this,
        StocGameMessage.MsgStart,
        1
      ) as StocGameMessage.MsgStart;
    }
    set start(value: StocGameMessage.MsgStart) {
      pb_1.Message.setOneofWrapperField(this, 1, this.#one_of_decls[0], value);
    }
    get has_start() {
      return pb_1.Message.getField(this, 1) != null;
    }
    get draw() {
      return pb_1.Message.getWrapperField(
        this,
        StocGameMessage.MsgDraw,
        2
      ) as StocGameMessage.MsgDraw;
    }
    set draw(value: StocGameMessage.MsgDraw) {
      pb_1.Message.setOneofWrapperField(this, 2, this.#one_of_decls[0], value);
    }
    get has_draw() {
      return pb_1.Message.getField(this, 2) != null;
    }
    get new_turn() {
      return pb_1.Message.getWrapperField(
        this,
        StocGameMessage.MsgNewTurn,
        3
      ) as StocGameMessage.MsgNewTurn;
    }
    set new_turn(value: StocGameMessage.MsgNewTurn) {
      pb_1.Message.setOneofWrapperField(this, 3, this.#one_of_decls[0], value);
    }
    get has_new_turn() {
      return pb_1.Message.getField(this, 3) != null;
    }
    get new_phase() {
      return pb_1.Message.getWrapperField(
        this,
        StocGameMessage.MsgNewPhase,
        4
      ) as StocGameMessage.MsgNewPhase;
    }
    set new_phase(value: StocGameMessage.MsgNewPhase) {
      pb_1.Message.setOneofWrapperField(this, 4, this.#one_of_decls[0], value);
    }
    get has_new_phase() {
      return pb_1.Message.getField(this, 4) != null;
    }
    get hint() {
      return pb_1.Message.getWrapperField(
        this,
        StocGameMessage.MsgHint,
        5
      ) as StocGameMessage.MsgHint;
    }
    set hint(value: StocGameMessage.MsgHint) {
      pb_1.Message.setOneofWrapperField(this, 5, this.#one_of_decls[0], value);
    }
    get has_hint() {
      return pb_1.Message.getField(this, 5) != null;
    }
    get select_idle_cmd() {
      return pb_1.Message.getWrapperField(
        this,
        StocGameMessage.MsgSelectIdleCmd,
        6
      ) as StocGameMessage.MsgSelectIdleCmd;
    }
    set select_idle_cmd(value: StocGameMessage.MsgSelectIdleCmd) {
      pb_1.Message.setOneofWrapperField(this, 6, this.#one_of_decls[0], value);
    }
    get has_select_idle_cmd() {
      return pb_1.Message.getField(this, 6) != null;
    }
    get select_place() {
      return pb_1.Message.getWrapperField(
        this,
        StocGameMessage.MsgSelectPlace,
        7
      ) as StocGameMessage.MsgSelectPlace;
    }
    set select_place(value: StocGameMessage.MsgSelectPlace) {
      pb_1.Message.setOneofWrapperField(this, 7, this.#one_of_decls[0], value);
    }
    get has_select_place() {
      return pb_1.Message.getField(this, 7) != null;
    }
    get move() {
      return pb_1.Message.getWrapperField(
        this,
        StocGameMessage.MsgMove,
        8
      ) as StocGameMessage.MsgMove;
    }
    set move(value: StocGameMessage.MsgMove) {
      pb_1.Message.setOneofWrapperField(this, 8, this.#one_of_decls[0], value);
    }
    get has_move() {
      return pb_1.Message.getField(this, 8) != null;
    }
    get select_card() {
      return pb_1.Message.getWrapperField(
        this,
        StocGameMessage.MsgSelectCard,
        9
      ) as StocGameMessage.MsgSelectCard;
    }
    set select_card(value: StocGameMessage.MsgSelectCard) {
      pb_1.Message.setOneofWrapperField(this, 9, this.#one_of_decls[0], value);
    }
    get has_select_card() {
      return pb_1.Message.getField(this, 9) != null;
    }
    get select_chain() {
      return pb_1.Message.getWrapperField(
        this,
        StocGameMessage.MsgSelectChain,
        10
      ) as StocGameMessage.MsgSelectChain;
    }
    set select_chain(value: StocGameMessage.MsgSelectChain) {
      pb_1.Message.setOneofWrapperField(this, 10, this.#one_of_decls[0], value);
    }
    get has_select_chain() {
      return pb_1.Message.getField(this, 10) != null;
    }
    get select_effect_yn() {
      return pb_1.Message.getWrapperField(
        this,
        StocGameMessage.MsgSelectEffectYn,
        11
      ) as StocGameMessage.MsgSelectEffectYn;
    }
    set select_effect_yn(value: StocGameMessage.MsgSelectEffectYn) {
      pb_1.Message.setOneofWrapperField(this, 11, this.#one_of_decls[0], value);
    }
    get has_select_effect_yn() {
      return pb_1.Message.getField(this, 11) != null;
    }
    get select_position() {
      return pb_1.Message.getWrapperField(
        this,
        StocGameMessage.MsgSelectPosition,
        12
      ) as StocGameMessage.MsgSelectPosition;
    }
    set select_position(value: StocGameMessage.MsgSelectPosition) {
      pb_1.Message.setOneofWrapperField(this, 12, this.#one_of_decls[0], value);
    }
    get has_select_position() {
      return pb_1.Message.getField(this, 12) != null;
    }
    get select_option() {
      return pb_1.Message.getWrapperField(
        this,
        StocGameMessage.MsgSelectOption,
        13
      ) as StocGameMessage.MsgSelectOption;
    }
    set select_option(value: StocGameMessage.MsgSelectOption) {
      pb_1.Message.setOneofWrapperField(this, 13, this.#one_of_decls[0], value);
    }
    get has_select_option() {
      return pb_1.Message.getField(this, 13) != null;
    }
    get shuffle_hand() {
      return pb_1.Message.getWrapperField(
        this,
        StocGameMessage.MsgShuffleHand,
        14
      ) as StocGameMessage.MsgShuffleHand;
    }
    set shuffle_hand(value: StocGameMessage.MsgShuffleHand) {
      pb_1.Message.setOneofWrapperField(this, 14, this.#one_of_decls[0], value);
    }
    get has_shuffle_hand() {
      return pb_1.Message.getField(this, 14) != null;
    }
    get select_battle_cmd() {
      return pb_1.Message.getWrapperField(
        this,
        StocGameMessage.MsgSelectBattleCmd,
        15
      ) as StocGameMessage.MsgSelectBattleCmd;
    }
    set select_battle_cmd(value: StocGameMessage.MsgSelectBattleCmd) {
      pb_1.Message.setOneofWrapperField(this, 15, this.#one_of_decls[0], value);
    }
    get has_select_battle_cmd() {
      return pb_1.Message.getField(this, 15) != null;
    }
    get pos_change() {
      return pb_1.Message.getWrapperField(
        this,
        StocGameMessage.MsgPosChange,
        16
      ) as StocGameMessage.MsgPosChange;
    }
    set pos_change(value: StocGameMessage.MsgPosChange) {
      pb_1.Message.setOneofWrapperField(this, 16, this.#one_of_decls[0], value);
    }
    get has_pos_change() {
      return pb_1.Message.getField(this, 16) != null;
    }
    get select_unselect_card() {
      return pb_1.Message.getWrapperField(
        this,
        StocGameMessage.MsgSelectUnselectCard,
        17
      ) as StocGameMessage.MsgSelectUnselectCard;
    }
    set select_unselect_card(value: StocGameMessage.MsgSelectUnselectCard) {
      pb_1.Message.setOneofWrapperField(this, 17, this.#one_of_decls[0], value);
    }
    get has_select_unselect_card() {
      return pb_1.Message.getField(this, 17) != null;
    }
    get gameMsg() {
      const cases: {
        [index: number]:
          | "none"
          | "start"
          | "draw"
          | "new_turn"
          | "new_phase"
          | "hint"
          | "select_idle_cmd"
          | "select_place"
          | "move"
          | "select_card"
          | "select_chain"
          | "select_effect_yn"
          | "select_position"
          | "select_option"
          | "shuffle_hand"
          | "select_battle_cmd"
          | "pos_change"
          | "select_unselect_card";
      } = {
        0: "none",
        1: "start",
        2: "draw",
        3: "new_turn",
        4: "new_phase",
        5: "hint",
        6: "select_idle_cmd",
        7: "select_place",
        8: "move",
        9: "select_card",
        10: "select_chain",
        11: "select_effect_yn",
        12: "select_position",
        13: "select_option",
        14: "shuffle_hand",
        15: "select_battle_cmd",
        16: "pos_change",
        17: "select_unselect_card",
      };
      return cases[
        pb_1.Message.computeOneofCase(
          this,
          [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17]
        )
      ];
    }
    static fromObject(data: {
      start?: ReturnType<typeof StocGameMessage.MsgStart.prototype.toObject>;
      draw?: ReturnType<typeof StocGameMessage.MsgDraw.prototype.toObject>;
      new_turn?: ReturnType<
        typeof StocGameMessage.MsgNewTurn.prototype.toObject
      >;
      new_phase?: ReturnType<
        typeof StocGameMessage.MsgNewPhase.prototype.toObject
      >;
      hint?: ReturnType<typeof StocGameMessage.MsgHint.prototype.toObject>;
      select_idle_cmd?: ReturnType<
        typeof StocGameMessage.MsgSelectIdleCmd.prototype.toObject
      >;
      select_place?: ReturnType<
        typeof StocGameMessage.MsgSelectPlace.prototype.toObject
      >;
      move?: ReturnType<typeof StocGameMessage.MsgMove.prototype.toObject>;
      select_card?: ReturnType<
        typeof StocGameMessage.MsgSelectCard.prototype.toObject
      >;
      select_chain?: ReturnType<
        typeof StocGameMessage.MsgSelectChain.prototype.toObject
      >;
      select_effect_yn?: ReturnType<
        typeof StocGameMessage.MsgSelectEffectYn.prototype.toObject
      >;
      select_position?: ReturnType<
        typeof StocGameMessage.MsgSelectPosition.prototype.toObject
      >;
      select_option?: ReturnType<
        typeof StocGameMessage.MsgSelectOption.prototype.toObject
      >;
      shuffle_hand?: ReturnType<
        typeof StocGameMessage.MsgShuffleHand.prototype.toObject
      >;
      select_battle_cmd?: ReturnType<
        typeof StocGameMessage.MsgSelectBattleCmd.prototype.toObject
      >;
      pos_change?: ReturnType<
        typeof StocGameMessage.MsgPosChange.prototype.toObject
      >;
      select_unselect_card?: ReturnType<
        typeof StocGameMessage.MsgSelectUnselectCard.prototype.toObject
      >;
    }): StocGameMessage {
      const message = new StocGameMessage({});
      if (data.start != null) {
        message.start = StocGameMessage.MsgStart.fromObject(data.start);
      }
      if (data.draw != null) {
        message.draw = StocGameMessage.MsgDraw.fromObject(data.draw);
      }
      if (data.new_turn != null) {
        message.new_turn = StocGameMessage.MsgNewTurn.fromObject(data.new_turn);
      }
      if (data.new_phase != null) {
        message.new_phase = StocGameMessage.MsgNewPhase.fromObject(
          data.new_phase
        );
      }
      if (data.hint != null) {
        message.hint = StocGameMessage.MsgHint.fromObject(data.hint);
      }
      if (data.select_idle_cmd != null) {
        message.select_idle_cmd = StocGameMessage.MsgSelectIdleCmd.fromObject(
          data.select_idle_cmd
        );
      }
      if (data.select_place != null) {
        message.select_place = StocGameMessage.MsgSelectPlace.fromObject(
          data.select_place
        );
      }
      if (data.move != null) {
        message.move = StocGameMessage.MsgMove.fromObject(data.move);
      }
      if (data.select_card != null) {
        message.select_card = StocGameMessage.MsgSelectCard.fromObject(
          data.select_card
        );
      }
      if (data.select_chain != null) {
        message.select_chain = StocGameMessage.MsgSelectChain.fromObject(
          data.select_chain
        );
      }
      if (data.select_effect_yn != null) {
        message.select_effect_yn = StocGameMessage.MsgSelectEffectYn.fromObject(
          data.select_effect_yn
        );
      }
      if (data.select_position != null) {
        message.select_position = StocGameMessage.MsgSelectPosition.fromObject(
          data.select_position
        );
      }
      if (data.select_option != null) {
        message.select_option = StocGameMessage.MsgSelectOption.fromObject(
          data.select_option
        );
      }
      if (data.shuffle_hand != null) {
        message.shuffle_hand = StocGameMessage.MsgShuffleHand.fromObject(
          data.shuffle_hand
        );
      }
      if (data.select_battle_cmd != null) {
        message.select_battle_cmd =
          StocGameMessage.MsgSelectBattleCmd.fromObject(data.select_battle_cmd);
      }
      if (data.pos_change != null) {
        message.pos_change = StocGameMessage.MsgPosChange.fromObject(
          data.pos_change
        );
      }
      if (data.select_unselect_card != null) {
        message.select_unselect_card =
          StocGameMessage.MsgSelectUnselectCard.fromObject(
            data.select_unselect_card
          );
      }
      return message;
    }
    toObject() {
      const data: {
        start?: ReturnType<typeof StocGameMessage.MsgStart.prototype.toObject>;
        draw?: ReturnType<typeof StocGameMessage.MsgDraw.prototype.toObject>;
        new_turn?: ReturnType<
          typeof StocGameMessage.MsgNewTurn.prototype.toObject
        >;
        new_phase?: ReturnType<
          typeof StocGameMessage.MsgNewPhase.prototype.toObject
        >;
        hint?: ReturnType<typeof StocGameMessage.MsgHint.prototype.toObject>;
        select_idle_cmd?: ReturnType<
          typeof StocGameMessage.MsgSelectIdleCmd.prototype.toObject
        >;
        select_place?: ReturnType<
          typeof StocGameMessage.MsgSelectPlace.prototype.toObject
        >;
        move?: ReturnType<typeof StocGameMessage.MsgMove.prototype.toObject>;
        select_card?: ReturnType<
          typeof StocGameMessage.MsgSelectCard.prototype.toObject
        >;
        select_chain?: ReturnType<
          typeof StocGameMessage.MsgSelectChain.prototype.toObject
        >;
        select_effect_yn?: ReturnType<
          typeof StocGameMessage.MsgSelectEffectYn.prototype.toObject
        >;
        select_position?: ReturnType<
          typeof StocGameMessage.MsgSelectPosition.prototype.toObject
        >;
        select_option?: ReturnType<
          typeof StocGameMessage.MsgSelectOption.prototype.toObject
        >;
        shuffle_hand?: ReturnType<
          typeof StocGameMessage.MsgShuffleHand.prototype.toObject
        >;
        select_battle_cmd?: ReturnType<
          typeof StocGameMessage.MsgSelectBattleCmd.prototype.toObject
        >;
        pos_change?: ReturnType<
          typeof StocGameMessage.MsgPosChange.prototype.toObject
        >;
        select_unselect_card?: ReturnType<
          typeof StocGameMessage.MsgSelectUnselectCard.prototype.toObject
        >;
      } = {};
      if (this.start != null) {
        data.start = this.start.toObject();
      }
      if (this.draw != null) {
        data.draw = this.draw.toObject();
      }
      if (this.new_turn != null) {
        data.new_turn = this.new_turn.toObject();
      }
      if (this.new_phase != null) {
        data.new_phase = this.new_phase.toObject();
      }
      if (this.hint != null) {
        data.hint = this.hint.toObject();
      }
      if (this.select_idle_cmd != null) {
        data.select_idle_cmd = this.select_idle_cmd.toObject();
      }
      if (this.select_place != null) {
        data.select_place = this.select_place.toObject();
      }
      if (this.move != null) {
        data.move = this.move.toObject();
      }
      if (this.select_card != null) {
        data.select_card = this.select_card.toObject();
      }
      if (this.select_chain != null) {
        data.select_chain = this.select_chain.toObject();
      }
      if (this.select_effect_yn != null) {
        data.select_effect_yn = this.select_effect_yn.toObject();
      }
      if (this.select_position != null) {
        data.select_position = this.select_position.toObject();
      }
      if (this.select_option != null) {
        data.select_option = this.select_option.toObject();
      }
      if (this.shuffle_hand != null) {
        data.shuffle_hand = this.shuffle_hand.toObject();
      }
      if (this.select_battle_cmd != null) {
        data.select_battle_cmd = this.select_battle_cmd.toObject();
      }
      if (this.pos_change != null) {
        data.pos_change = this.pos_change.toObject();
      }
      if (this.select_unselect_card != null) {
        data.select_unselect_card = this.select_unselect_card.toObject();
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.has_start)
        writer.writeMessage(1, this.start, () => this.start.serialize(writer));
      if (this.has_draw)
        writer.writeMessage(2, this.draw, () => this.draw.serialize(writer));
      if (this.has_new_turn)
        writer.writeMessage(3, this.new_turn, () =>
          this.new_turn.serialize(writer)
        );
      if (this.has_new_phase)
        writer.writeMessage(4, this.new_phase, () =>
          this.new_phase.serialize(writer)
        );
      if (this.has_hint)
        writer.writeMessage(5, this.hint, () => this.hint.serialize(writer));
      if (this.has_select_idle_cmd)
        writer.writeMessage(6, this.select_idle_cmd, () =>
          this.select_idle_cmd.serialize(writer)
        );
      if (this.has_select_place)
        writer.writeMessage(7, this.select_place, () =>
          this.select_place.serialize(writer)
        );
      if (this.has_move)
        writer.writeMessage(8, this.move, () => this.move.serialize(writer));
      if (this.has_select_card)
        writer.writeMessage(9, this.select_card, () =>
          this.select_card.serialize(writer)
        );
      if (this.has_select_chain)
        writer.writeMessage(10, this.select_chain, () =>
          this.select_chain.serialize(writer)
        );
      if (this.has_select_effect_yn)
        writer.writeMessage(11, this.select_effect_yn, () =>
          this.select_effect_yn.serialize(writer)
        );
      if (this.has_select_position)
        writer.writeMessage(12, this.select_position, () =>
          this.select_position.serialize(writer)
        );
      if (this.has_select_option)
        writer.writeMessage(13, this.select_option, () =>
          this.select_option.serialize(writer)
        );
      if (this.has_shuffle_hand)
        writer.writeMessage(14, this.shuffle_hand, () =>
          this.shuffle_hand.serialize(writer)
        );
      if (this.has_select_battle_cmd)
        writer.writeMessage(15, this.select_battle_cmd, () =>
          this.select_battle_cmd.serialize(writer)
        );
      if (this.has_pos_change)
        writer.writeMessage(16, this.pos_change, () =>
          this.pos_change.serialize(writer)
        );
      if (this.has_select_unselect_card)
        writer.writeMessage(17, this.select_unselect_card, () =>
          this.select_unselect_card.serialize(writer)
        );
      if (!w) return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): StocGameMessage {
      const reader =
          bytes instanceof pb_1.BinaryReader
            ? bytes
            : new pb_1.BinaryReader(bytes),
        message = new StocGameMessage();
      while (reader.nextField()) {
        if (reader.isEndGroup()) break;
        switch (reader.getFieldNumber()) {
          case 1:
            reader.readMessage(
              message.start,
              () =>
                (message.start = StocGameMessage.MsgStart.deserialize(reader))
            );
            break;
          case 2:
            reader.readMessage(
              message.draw,
              () => (message.draw = StocGameMessage.MsgDraw.deserialize(reader))
            );
            break;
          case 3:
            reader.readMessage(
              message.new_turn,
              () =>
                (message.new_turn =
                  StocGameMessage.MsgNewTurn.deserialize(reader))
            );
            break;
          case 4:
            reader.readMessage(
              message.new_phase,
              () =>
                (message.new_phase =
                  StocGameMessage.MsgNewPhase.deserialize(reader))
            );
            break;
          case 5:
            reader.readMessage(
              message.hint,
              () => (message.hint = StocGameMessage.MsgHint.deserialize(reader))
            );
            break;
          case 6:
            reader.readMessage(
              message.select_idle_cmd,
              () =>
                (message.select_idle_cmd =
                  StocGameMessage.MsgSelectIdleCmd.deserialize(reader))
            );
            break;
          case 7:
            reader.readMessage(
              message.select_place,
              () =>
                (message.select_place =
                  StocGameMessage.MsgSelectPlace.deserialize(reader))
            );
            break;
          case 8:
            reader.readMessage(
              message.move,
              () => (message.move = StocGameMessage.MsgMove.deserialize(reader))
            );
            break;
          case 9:
            reader.readMessage(
              message.select_card,
              () =>
                (message.select_card =
                  StocGameMessage.MsgSelectCard.deserialize(reader))
            );
            break;
          case 10:
            reader.readMessage(
              message.select_chain,
              () =>
                (message.select_chain =
                  StocGameMessage.MsgSelectChain.deserialize(reader))
            );
            break;
          case 11:
            reader.readMessage(
              message.select_effect_yn,
              () =>
                (message.select_effect_yn =
                  StocGameMessage.MsgSelectEffectYn.deserialize(reader))
            );
            break;
          case 12:
            reader.readMessage(
              message.select_position,
              () =>
                (message.select_position =
                  StocGameMessage.MsgSelectPosition.deserialize(reader))
            );
            break;
          case 13:
            reader.readMessage(
              message.select_option,
              () =>
                (message.select_option =
                  StocGameMessage.MsgSelectOption.deserialize(reader))
            );
            break;
          case 14:
            reader.readMessage(
              message.shuffle_hand,
              () =>
                (message.shuffle_hand =
                  StocGameMessage.MsgShuffleHand.deserialize(reader))
            );
            break;
          case 15:
            reader.readMessage(
              message.select_battle_cmd,
              () =>
                (message.select_battle_cmd =
                  StocGameMessage.MsgSelectBattleCmd.deserialize(reader))
            );
            break;
          case 16:
            reader.readMessage(
              message.pos_change,
              () =>
                (message.pos_change =
                  StocGameMessage.MsgPosChange.deserialize(reader))
            );
            break;
          case 17:
            reader.readMessage(
              message.select_unselect_card,
              () =>
                (message.select_unselect_card =
                  StocGameMessage.MsgSelectUnselectCard.deserialize(reader))
            );
            break;
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): StocGameMessage {
      return StocGameMessage.deserialize(bytes);
    }
  }
  export namespace StocGameMessage {
    export class MsgStart extends pb_1.Message {
      #one_of_decls: number[][] = [];
      constructor(
        data?:
          | any[]
          | {
              playerType?: StocGameMessage.MsgStart.PlayerType;
              life1?: number;
              life2?: number;
              deckSize1?: number;
              deckSize2?: number;
              extraSize1?: number;
              extraSize2?: number;
            }
      ) {
        super();
        pb_1.Message.initialize(
          this,
          Array.isArray(data) ? data : [],
          0,
          -1,
          [],
          this.#one_of_decls
        );
        if (!Array.isArray(data) && typeof data == "object") {
          if ("playerType" in data && data.playerType != undefined) {
            this.playerType = data.playerType;
          }
          if ("life1" in data && data.life1 != undefined) {
            this.life1 = data.life1;
          }
          if ("life2" in data && data.life2 != undefined) {
            this.life2 = data.life2;
          }
          if ("deckSize1" in data && data.deckSize1 != undefined) {
            this.deckSize1 = data.deckSize1;
          }
          if ("deckSize2" in data && data.deckSize2 != undefined) {
            this.deckSize2 = data.deckSize2;
          }
          if ("extraSize1" in data && data.extraSize1 != undefined) {
            this.extraSize1 = data.extraSize1;
          }
          if ("extraSize2" in data && data.extraSize2 != undefined) {
            this.extraSize2 = data.extraSize2;
          }
        }
      }
      get playerType() {
        return pb_1.Message.getFieldWithDefault(
          this,
          1,
          StocGameMessage.MsgStart.PlayerType.UNKNOWN
        ) as StocGameMessage.MsgStart.PlayerType;
      }
      set playerType(value: StocGameMessage.MsgStart.PlayerType) {
        pb_1.Message.setField(this, 1, value);
      }
      get life1() {
        return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
      }
      set life1(value: number) {
        pb_1.Message.setField(this, 2, value);
      }
      get life2() {
        return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
      }
      set life2(value: number) {
        pb_1.Message.setField(this, 3, value);
      }
      get deckSize1() {
        return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
      }
      set deckSize1(value: number) {
        pb_1.Message.setField(this, 4, value);
      }
      get deckSize2() {
        return pb_1.Message.getFieldWithDefault(this, 5, 0) as number;
      }
      set deckSize2(value: number) {
        pb_1.Message.setField(this, 5, value);
      }
      get extraSize1() {
        return pb_1.Message.getFieldWithDefault(this, 6, 0) as number;
      }
      set extraSize1(value: number) {
        pb_1.Message.setField(this, 6, value);
      }
      get extraSize2() {
        return pb_1.Message.getFieldWithDefault(this, 7, 0) as number;
      }
      set extraSize2(value: number) {
        pb_1.Message.setField(this, 7, value);
      }
      static fromObject(data: {
        playerType?: StocGameMessage.MsgStart.PlayerType;
        life1?: number;
        life2?: number;
        deckSize1?: number;
        deckSize2?: number;
        extraSize1?: number;
        extraSize2?: number;
      }): MsgStart {
        const message = new MsgStart({});
        if (data.playerType != null) {
          message.playerType = data.playerType;
        }
        if (data.life1 != null) {
          message.life1 = data.life1;
        }
        if (data.life2 != null) {
          message.life2 = data.life2;
        }
        if (data.deckSize1 != null) {
          message.deckSize1 = data.deckSize1;
        }
        if (data.deckSize2 != null) {
          message.deckSize2 = data.deckSize2;
        }
        if (data.extraSize1 != null) {
          message.extraSize1 = data.extraSize1;
        }
        if (data.extraSize2 != null) {
          message.extraSize2 = data.extraSize2;
        }
        return message;
      }
      toObject() {
        const data: {
          playerType?: StocGameMessage.MsgStart.PlayerType;
          life1?: number;
          life2?: number;
          deckSize1?: number;
          deckSize2?: number;
          extraSize1?: number;
          extraSize2?: number;
        } = {};
        if (this.playerType != null) {
          data.playerType = this.playerType;
        }
        if (this.life1 != null) {
          data.life1 = this.life1;
        }
        if (this.life2 != null) {
          data.life2 = this.life2;
        }
        if (this.deckSize1 != null) {
          data.deckSize1 = this.deckSize1;
        }
        if (this.deckSize2 != null) {
          data.deckSize2 = this.deckSize2;
        }
        if (this.extraSize1 != null) {
          data.extraSize1 = this.extraSize1;
        }
        if (this.extraSize2 != null) {
          data.extraSize2 = this.extraSize2;
        }
        return data;
      }
      serialize(): Uint8Array;
      serialize(w: pb_1.BinaryWriter): void;
      serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.playerType != StocGameMessage.MsgStart.PlayerType.UNKNOWN)
          writer.writeEnum(1, this.playerType);
        if (this.life1 != 0) writer.writeInt32(2, this.life1);
        if (this.life2 != 0) writer.writeInt32(3, this.life2);
        if (this.deckSize1 != 0) writer.writeInt32(4, this.deckSize1);
        if (this.deckSize2 != 0) writer.writeInt32(5, this.deckSize2);
        if (this.extraSize1 != 0) writer.writeInt32(6, this.extraSize1);
        if (this.extraSize2 != 0) writer.writeInt32(7, this.extraSize2);
        if (!w) return writer.getResultBuffer();
      }
      static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgStart {
        const reader =
            bytes instanceof pb_1.BinaryReader
              ? bytes
              : new pb_1.BinaryReader(bytes),
          message = new MsgStart();
        while (reader.nextField()) {
          if (reader.isEndGroup()) break;
          switch (reader.getFieldNumber()) {
            case 1:
              message.playerType = reader.readEnum();
              break;
            case 2:
              message.life1 = reader.readInt32();
              break;
            case 3:
              message.life2 = reader.readInt32();
              break;
            case 4:
              message.deckSize1 = reader.readInt32();
              break;
            case 5:
              message.deckSize2 = reader.readInt32();
              break;
            case 6:
              message.extraSize1 = reader.readInt32();
              break;
            case 7:
              message.extraSize2 = reader.readInt32();
              break;
            default:
              reader.skipField();
          }
        }
        return message;
      }
      serializeBinary(): Uint8Array {
        return this.serialize();
      }
      static deserializeBinary(bytes: Uint8Array): MsgStart {
        return MsgStart.deserialize(bytes);
      }
    }
    export namespace MsgStart {
      export enum PlayerType {
        UNKNOWN = 0,
        FirstStrike = 1,
        SecondStrike = 2,
        Observer = 3,
      }
    }
    export class MsgDraw extends pb_1.Message {
      #one_of_decls: number[][] = [];
      constructor(
        data?:
          | any[]
          | {
              player?: number;
              count?: number;
              cards?: number[];
            }
      ) {
        super();
        pb_1.Message.initialize(
          this,
          Array.isArray(data) ? data : [],
          0,
          -1,
          [3],
          this.#one_of_decls
        );
        if (!Array.isArray(data) && typeof data == "object") {
          if ("player" in data && data.player != undefined) {
            this.player = data.player;
          }
          if ("count" in data && data.count != undefined) {
            this.count = data.count;
          }
          if ("cards" in data && data.cards != undefined) {
            this.cards = data.cards;
          }
        }
      }
      get player() {
        return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
      }
      set player(value: number) {
        pb_1.Message.setField(this, 1, value);
      }
      get count() {
        return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
      }
      set count(value: number) {
        pb_1.Message.setField(this, 2, value);
      }
      get cards() {
        return pb_1.Message.getFieldWithDefault(this, 3, []) as number[];
      }
      set cards(value: number[]) {
        pb_1.Message.setField(this, 3, value);
      }
      static fromObject(data: {
        player?: number;
        count?: number;
        cards?: number[];
      }): MsgDraw {
        const message = new MsgDraw({});
        if (data.player != null) {
          message.player = data.player;
        }
        if (data.count != null) {
          message.count = data.count;
        }
        if (data.cards != null) {
          message.cards = data.cards;
        }
        return message;
      }
      toObject() {
        const data: {
          player?: number;
          count?: number;
          cards?: number[];
        } = {};
        if (this.player != null) {
          data.player = this.player;
        }
        if (this.count != null) {
          data.count = this.count;
        }
        if (this.cards != null) {
          data.cards = this.cards;
        }
        return data;
      }
      serialize(): Uint8Array;
      serialize(w: pb_1.BinaryWriter): void;
      serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.player != 0) writer.writeInt32(1, this.player);
        if (this.count != 0) writer.writeInt32(2, this.count);
        if (this.cards.length) writer.writePackedInt32(3, this.cards);
        if (!w) return writer.getResultBuffer();
      }
      static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgDraw {
        const reader =
            bytes instanceof pb_1.BinaryReader
              ? bytes
              : new pb_1.BinaryReader(bytes),
          message = new MsgDraw();
        while (reader.nextField()) {
          if (reader.isEndGroup()) break;
          switch (reader.getFieldNumber()) {
            case 1:
              message.player = reader.readInt32();
              break;
            case 2:
              message.count = reader.readInt32();
              break;
            case 3:
              message.cards = reader.readPackedInt32();
              break;
            default:
              reader.skipField();
          }
        }
        return message;
      }
      serializeBinary(): Uint8Array {
        return this.serialize();
      }
      static deserializeBinary(bytes: Uint8Array): MsgDraw {
        return MsgDraw.deserialize(bytes);
      }
    }
    export class MsgNewTurn extends pb_1.Message {
      #one_of_decls: number[][] = [];
      constructor(
        data?:
          | any[]
          | {
              player?: number;
            }
      ) {
        super();
        pb_1.Message.initialize(
          this,
          Array.isArray(data) ? data : [],
          0,
          -1,
          [],
          this.#one_of_decls
        );
        if (!Array.isArray(data) && typeof data == "object") {
          if ("player" in data && data.player != undefined) {
            this.player = data.player;
          }
        }
      }
      get player() {
        return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
      }
      set player(value: number) {
        pb_1.Message.setField(this, 1, value);
      }
      static fromObject(data: { player?: number }): MsgNewTurn {
        const message = new MsgNewTurn({});
        if (data.player != null) {
          message.player = data.player;
        }
        return message;
      }
      toObject() {
        const data: {
          player?: number;
        } = {};
        if (this.player != null) {
          data.player = this.player;
        }
        return data;
      }
      serialize(): Uint8Array;
      serialize(w: pb_1.BinaryWriter): void;
      serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.player != 0) writer.writeInt32(1, this.player);
        if (!w) return writer.getResultBuffer();
      }
      static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgNewTurn {
        const reader =
            bytes instanceof pb_1.BinaryReader
              ? bytes
              : new pb_1.BinaryReader(bytes),
          message = new MsgNewTurn();
        while (reader.nextField()) {
          if (reader.isEndGroup()) break;
          switch (reader.getFieldNumber()) {
            case 1:
              message.player = reader.readInt32();
              break;
            default:
              reader.skipField();
          }
        }
        return message;
      }
      serializeBinary(): Uint8Array {
        return this.serialize();
      }
      static deserializeBinary(bytes: Uint8Array): MsgNewTurn {
        return MsgNewTurn.deserialize(bytes);
      }
    }
    export class MsgNewPhase extends pb_1.Message {
      #one_of_decls: number[][] = [];
      constructor(
        data?:
          | any[]
          | {
              phase_type?: StocGameMessage.MsgNewPhase.PhaseType;
            }
      ) {
        super();
        pb_1.Message.initialize(
          this,
          Array.isArray(data) ? data : [],
          0,
          -1,
          [],
          this.#one_of_decls
        );
        if (!Array.isArray(data) && typeof data == "object") {
          if ("phase_type" in data && data.phase_type != undefined) {
            this.phase_type = data.phase_type;
          }
        }
      }
      get phase_type() {
        return pb_1.Message.getFieldWithDefault(
          this,
          1,
          StocGameMessage.MsgNewPhase.PhaseType.UNKNOWN
        ) as StocGameMessage.MsgNewPhase.PhaseType;
      }
      set phase_type(value: StocGameMessage.MsgNewPhase.PhaseType) {
        pb_1.Message.setField(this, 1, value);
      }
      static fromObject(data: {
        phase_type?: StocGameMessage.MsgNewPhase.PhaseType;
      }): MsgNewPhase {
        const message = new MsgNewPhase({});
        if (data.phase_type != null) {
          message.phase_type = data.phase_type;
        }
        return message;
      }
      toObject() {
        const data: {
          phase_type?: StocGameMessage.MsgNewPhase.PhaseType;
        } = {};
        if (this.phase_type != null) {
          data.phase_type = this.phase_type;
        }
        return data;
      }
      serialize(): Uint8Array;
      serialize(w: pb_1.BinaryWriter): void;
      serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.phase_type != StocGameMessage.MsgNewPhase.PhaseType.UNKNOWN)
          writer.writeEnum(1, this.phase_type);
        if (!w) return writer.getResultBuffer();
      }
      static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgNewPhase {
        const reader =
            bytes instanceof pb_1.BinaryReader
              ? bytes
              : new pb_1.BinaryReader(bytes),
          message = new MsgNewPhase();
        while (reader.nextField()) {
          if (reader.isEndGroup()) break;
          switch (reader.getFieldNumber()) {
            case 1:
              message.phase_type = reader.readEnum();
              break;
            default:
              reader.skipField();
          }
        }
        return message;
      }
      serializeBinary(): Uint8Array {
        return this.serialize();
      }
      static deserializeBinary(bytes: Uint8Array): MsgNewPhase {
        return MsgNewPhase.deserialize(bytes);
      }
    }
    export namespace MsgNewPhase {
      export enum PhaseType {
        UNKNOWN = 0,
        DRAW = 1,
        STANDBY = 2,
        MAIN1 = 3,
        BATTLE_START = 4,
        BATTLE_STEP = 5,
        DAMAGE = 6,
        DAMAGE_GAL = 7,
        BATTLE = 8,
        MAIN2 = 9,
        END = 10,
      }
    }
    export class MsgHint extends pb_1.Message {
      #one_of_decls: number[][] = [];
      constructor(
        data?:
          | any[]
          | {
              hint_type?: StocGameMessage.MsgHint.HintType;
              player?: number;
              hint_data?: number;
            }
      ) {
        super();
        pb_1.Message.initialize(
          this,
          Array.isArray(data) ? data : [],
          0,
          -1,
          [],
          this.#one_of_decls
        );
        if (!Array.isArray(data) && typeof data == "object") {
          if ("hint_type" in data && data.hint_type != undefined) {
            this.hint_type = data.hint_type;
          }
          if ("player" in data && data.player != undefined) {
            this.player = data.player;
          }
          if ("hint_data" in data && data.hint_data != undefined) {
            this.hint_data = data.hint_data;
          }
        }
      }
      get hint_type() {
        return pb_1.Message.getFieldWithDefault(
          this,
          1,
          StocGameMessage.MsgHint.HintType.UNKNOWN
        ) as StocGameMessage.MsgHint.HintType;
      }
      set hint_type(value: StocGameMessage.MsgHint.HintType) {
        pb_1.Message.setField(this, 1, value);
      }
      get player() {
        return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
      }
      set player(value: number) {
        pb_1.Message.setField(this, 2, value);
      }
      get hint_data() {
        return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
      }
      set hint_data(value: number) {
        pb_1.Message.setField(this, 3, value);
      }
      static fromObject(data: {
        hint_type?: StocGameMessage.MsgHint.HintType;
        player?: number;
        hint_data?: number;
      }): MsgHint {
        const message = new MsgHint({});
        if (data.hint_type != null) {
          message.hint_type = data.hint_type;
        }
        if (data.player != null) {
          message.player = data.player;
        }
        if (data.hint_data != null) {
          message.hint_data = data.hint_data;
        }
        return message;
      }
      toObject() {
        const data: {
          hint_type?: StocGameMessage.MsgHint.HintType;
          player?: number;
          hint_data?: number;
        } = {};
        if (this.hint_type != null) {
          data.hint_type = this.hint_type;
        }
        if (this.player != null) {
          data.player = this.player;
        }
        if (this.hint_data != null) {
          data.hint_data = this.hint_data;
        }
        return data;
      }
      serialize(): Uint8Array;
      serialize(w: pb_1.BinaryWriter): void;
      serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.hint_type != StocGameMessage.MsgHint.HintType.UNKNOWN)
          writer.writeEnum(1, this.hint_type);
        if (this.player != 0) writer.writeInt32(2, this.player);
        if (this.hint_data != 0) writer.writeInt32(3, this.hint_data);
        if (!w) return writer.getResultBuffer();
      }
      static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgHint {
        const reader =
            bytes instanceof pb_1.BinaryReader
              ? bytes
              : new pb_1.BinaryReader(bytes),
          message = new MsgHint();
        while (reader.nextField()) {
          if (reader.isEndGroup()) break;
          switch (reader.getFieldNumber()) {
            case 1:
              message.hint_type = reader.readEnum();
              break;
            case 2:
              message.player = reader.readInt32();
              break;
            case 3:
              message.hint_data = reader.readInt32();
              break;
            default:
              reader.skipField();
          }
        }
        return message;
      }
      serializeBinary(): Uint8Array {
        return this.serialize();
      }
      static deserializeBinary(bytes: Uint8Array): MsgHint {
        return MsgHint.deserialize(bytes);
      }
    }
    export namespace MsgHint {
      export enum HintType {
        UNKNOWN = 0,
        HINT_EVENT = 1,
        HINT_MESSAGE = 2,
        HINT_SELECTMSG = 3,
        HINT_OPSELECTED = 4,
        HINT_EFFECT = 5,
        HINT_RACE = 6,
        HINT_ATTRIB = 7,
        HINT_CODE = 8,
        HINT_NUMBER = 9,
        HINT_CARD = 10,
        HINT_ZONE = 11,
      }
    }
    export class MsgSelectIdleCmd extends pb_1.Message {
      #one_of_decls: number[][] = [];
      constructor(
        data?:
          | any[]
          | {
              player?: number;
              idle_cmds?: StocGameMessage.MsgSelectIdleCmd.IdleCmd[];
              enable_bp?: boolean;
              enable_ep?: boolean;
              enable_shuffle?: boolean;
            }
      ) {
        super();
        pb_1.Message.initialize(
          this,
          Array.isArray(data) ? data : [],
          0,
          -1,
          [2],
          this.#one_of_decls
        );
        if (!Array.isArray(data) && typeof data == "object") {
          if ("player" in data && data.player != undefined) {
            this.player = data.player;
          }
          if ("idle_cmds" in data && data.idle_cmds != undefined) {
            this.idle_cmds = data.idle_cmds;
          }
          if ("enable_bp" in data && data.enable_bp != undefined) {
            this.enable_bp = data.enable_bp;
          }
          if ("enable_ep" in data && data.enable_ep != undefined) {
            this.enable_ep = data.enable_ep;
          }
          if ("enable_shuffle" in data && data.enable_shuffle != undefined) {
            this.enable_shuffle = data.enable_shuffle;
          }
        }
      }
      get player() {
        return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
      }
      set player(value: number) {
        pb_1.Message.setField(this, 1, value);
      }
      get idle_cmds() {
        return pb_1.Message.getRepeatedWrapperField(
          this,
          StocGameMessage.MsgSelectIdleCmd.IdleCmd,
          2
        ) as StocGameMessage.MsgSelectIdleCmd.IdleCmd[];
      }
      set idle_cmds(value: StocGameMessage.MsgSelectIdleCmd.IdleCmd[]) {
        pb_1.Message.setRepeatedWrapperField(this, 2, value);
      }
      get enable_bp() {
        return pb_1.Message.getFieldWithDefault(this, 3, false) as boolean;
      }
      set enable_bp(value: boolean) {
        pb_1.Message.setField(this, 3, value);
      }
      get enable_ep() {
        return pb_1.Message.getFieldWithDefault(this, 4, false) as boolean;
      }
      set enable_ep(value: boolean) {
        pb_1.Message.setField(this, 4, value);
      }
      get enable_shuffle() {
        return pb_1.Message.getFieldWithDefault(this, 5, false) as boolean;
      }
      set enable_shuffle(value: boolean) {
        pb_1.Message.setField(this, 5, value);
      }
      static fromObject(data: {
        player?: number;
        idle_cmds?: ReturnType<
          typeof StocGameMessage.MsgSelectIdleCmd.IdleCmd.prototype.toObject
        >[];
        enable_bp?: boolean;
        enable_ep?: boolean;
        enable_shuffle?: boolean;
      }): MsgSelectIdleCmd {
        const message = new MsgSelectIdleCmd({});
        if (data.player != null) {
          message.player = data.player;
        }
        if (data.idle_cmds != null) {
          message.idle_cmds = data.idle_cmds.map((item) =>
            StocGameMessage.MsgSelectIdleCmd.IdleCmd.fromObject(item)
          );
        }
        if (data.enable_bp != null) {
          message.enable_bp = data.enable_bp;
        }
        if (data.enable_ep != null) {
          message.enable_ep = data.enable_ep;
        }
        if (data.enable_shuffle != null) {
          message.enable_shuffle = data.enable_shuffle;
        }
        return message;
      }
      toObject() {
        const data: {
          player?: number;
          idle_cmds?: ReturnType<
            typeof StocGameMessage.MsgSelectIdleCmd.IdleCmd.prototype.toObject
          >[];
          enable_bp?: boolean;
          enable_ep?: boolean;
          enable_shuffle?: boolean;
        } = {};
        if (this.player != null) {
          data.player = this.player;
        }
        if (this.idle_cmds != null) {
          data.idle_cmds = this.idle_cmds.map(
            (item: StocGameMessage.MsgSelectIdleCmd.IdleCmd) => item.toObject()
          );
        }
        if (this.enable_bp != null) {
          data.enable_bp = this.enable_bp;
        }
        if (this.enable_ep != null) {
          data.enable_ep = this.enable_ep;
        }
        if (this.enable_shuffle != null) {
          data.enable_shuffle = this.enable_shuffle;
        }
        return data;
      }
      serialize(): Uint8Array;
      serialize(w: pb_1.BinaryWriter): void;
      serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.player != 0) writer.writeInt32(1, this.player);
        if (this.idle_cmds.length)
          writer.writeRepeatedMessage(
            2,
            this.idle_cmds,
            (item: StocGameMessage.MsgSelectIdleCmd.IdleCmd) =>
              item.serialize(writer)
          );
        if (this.enable_bp != false) writer.writeBool(3, this.enable_bp);
        if (this.enable_ep != false) writer.writeBool(4, this.enable_ep);
        if (this.enable_shuffle != false)
          writer.writeBool(5, this.enable_shuffle);
        if (!w) return writer.getResultBuffer();
      }
      static deserialize(
        bytes: Uint8Array | pb_1.BinaryReader
      ): MsgSelectIdleCmd {
        const reader =
            bytes instanceof pb_1.BinaryReader
              ? bytes
              : new pb_1.BinaryReader(bytes),
          message = new MsgSelectIdleCmd();
        while (reader.nextField()) {
          if (reader.isEndGroup()) break;
          switch (reader.getFieldNumber()) {
            case 1:
              message.player = reader.readInt32();
              break;
            case 2:
              reader.readMessage(message.idle_cmds, () =>
                pb_1.Message.addToRepeatedWrapperField(
                  message,
                  2,
                  StocGameMessage.MsgSelectIdleCmd.IdleCmd.deserialize(reader),
                  StocGameMessage.MsgSelectIdleCmd.IdleCmd
                )
              );
              break;
            case 3:
              message.enable_bp = reader.readBool();
              break;
            case 4:
              message.enable_ep = reader.readBool();
              break;
            case 5:
              message.enable_shuffle = reader.readBool();
              break;
            default:
              reader.skipField();
          }
        }
        return message;
      }
      serializeBinary(): Uint8Array {
        return this.serialize();
      }
      static deserializeBinary(bytes: Uint8Array): MsgSelectIdleCmd {
        return MsgSelectIdleCmd.deserialize(bytes);
      }
    }
    export namespace MsgSelectIdleCmd {
      export class IdleCmd extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(
          data?:
            | any[]
            | {
                idle_type?: StocGameMessage.MsgSelectIdleCmd.IdleCmd.IdleType;
                idle_datas?: StocGameMessage.MsgSelectIdleCmd.IdleCmd.IdleData[];
              }
        ) {
          super();
          pb_1.Message.initialize(
            this,
            Array.isArray(data) ? data : [],
            0,
            -1,
            [2],
            this.#one_of_decls
          );
          if (!Array.isArray(data) && typeof data == "object") {
            if ("idle_type" in data && data.idle_type != undefined) {
              this.idle_type = data.idle_type;
            }
            if ("idle_datas" in data && data.idle_datas != undefined) {
              this.idle_datas = data.idle_datas;
            }
          }
        }
        get idle_type() {
          return pb_1.Message.getFieldWithDefault(
            this,
            1,
            StocGameMessage.MsgSelectIdleCmd.IdleCmd.IdleType.UNKNOWN
          ) as StocGameMessage.MsgSelectIdleCmd.IdleCmd.IdleType;
        }
        set idle_type(
          value: StocGameMessage.MsgSelectIdleCmd.IdleCmd.IdleType
        ) {
          pb_1.Message.setField(this, 1, value);
        }
        get idle_datas() {
          return pb_1.Message.getRepeatedWrapperField(
            this,
            StocGameMessage.MsgSelectIdleCmd.IdleCmd.IdleData,
            2
          ) as StocGameMessage.MsgSelectIdleCmd.IdleCmd.IdleData[];
        }
        set idle_datas(
          value: StocGameMessage.MsgSelectIdleCmd.IdleCmd.IdleData[]
        ) {
          pb_1.Message.setRepeatedWrapperField(this, 2, value);
        }
        static fromObject(data: {
          idle_type?: StocGameMessage.MsgSelectIdleCmd.IdleCmd.IdleType;
          idle_datas?: ReturnType<
            typeof StocGameMessage.MsgSelectIdleCmd.IdleCmd.IdleData.prototype.toObject
          >[];
        }): IdleCmd {
          const message = new IdleCmd({});
          if (data.idle_type != null) {
            message.idle_type = data.idle_type;
          }
          if (data.idle_datas != null) {
            message.idle_datas = data.idle_datas.map((item) =>
              StocGameMessage.MsgSelectIdleCmd.IdleCmd.IdleData.fromObject(item)
            );
          }
          return message;
        }
        toObject() {
          const data: {
            idle_type?: StocGameMessage.MsgSelectIdleCmd.IdleCmd.IdleType;
            idle_datas?: ReturnType<
              typeof StocGameMessage.MsgSelectIdleCmd.IdleCmd.IdleData.prototype.toObject
            >[];
          } = {};
          if (this.idle_type != null) {
            data.idle_type = this.idle_type;
          }
          if (this.idle_datas != null) {
            data.idle_datas = this.idle_datas.map(
              (item: StocGameMessage.MsgSelectIdleCmd.IdleCmd.IdleData) =>
                item.toObject()
            );
          }
          return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
          const writer = w || new pb_1.BinaryWriter();
          if (
            this.idle_type !=
            StocGameMessage.MsgSelectIdleCmd.IdleCmd.IdleType.UNKNOWN
          )
            writer.writeEnum(1, this.idle_type);
          if (this.idle_datas.length)
            writer.writeRepeatedMessage(
              2,
              this.idle_datas,
              (item: StocGameMessage.MsgSelectIdleCmd.IdleCmd.IdleData) =>
                item.serialize(writer)
            );
          if (!w) return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): IdleCmd {
          const reader =
              bytes instanceof pb_1.BinaryReader
                ? bytes
                : new pb_1.BinaryReader(bytes),
            message = new IdleCmd();
          while (reader.nextField()) {
            if (reader.isEndGroup()) break;
            switch (reader.getFieldNumber()) {
              case 1:
                message.idle_type = reader.readEnum();
                break;
              case 2:
                reader.readMessage(message.idle_datas, () =>
                  pb_1.Message.addToRepeatedWrapperField(
                    message,
                    2,
                    StocGameMessage.MsgSelectIdleCmd.IdleCmd.IdleData.deserialize(
                      reader
                    ),
                    StocGameMessage.MsgSelectIdleCmd.IdleCmd.IdleData
                  )
                );
                break;
              default:
                reader.skipField();
            }
          }
          return message;
        }
        serializeBinary(): Uint8Array {
          return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): IdleCmd {
          return IdleCmd.deserialize(bytes);
        }
      }
      export namespace IdleCmd {
        export enum IdleType {
          UNKNOWN = 0,
          SUMMON = 1,
          SPSUMMON = 2,
          POS_CHANGE = 3,
          MSET = 4,
          SSET = 5,
          ACTIVATE = 6,
          TO_BP = 7,
          TO_EP = 8,
          SHUFFLE = 9,
        }
        export class IdleData extends pb_1.Message {
          #one_of_decls: number[][] = [];
          constructor(
            data?:
              | any[]
              | {
                  card_info?: CardInfo;
                  effect_description?: number;
                  response?: number;
                }
          ) {
            super();
            pb_1.Message.initialize(
              this,
              Array.isArray(data) ? data : [],
              0,
              -1,
              [],
              this.#one_of_decls
            );
            if (!Array.isArray(data) && typeof data == "object") {
              if ("card_info" in data && data.card_info != undefined) {
                this.card_info = data.card_info;
              }
              if (
                "effect_description" in data &&
                data.effect_description != undefined
              ) {
                this.effect_description = data.effect_description;
              }
              if ("response" in data && data.response != undefined) {
                this.response = data.response;
              }
            }
          }
          get card_info() {
            return pb_1.Message.getWrapperField(this, CardInfo, 1) as CardInfo;
          }
          set card_info(value: CardInfo) {
            pb_1.Message.setWrapperField(this, 1, value);
          }
          get has_card_info() {
            return pb_1.Message.getField(this, 1) != null;
          }
          get effect_description() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
          }
          set effect_description(value: number) {
            pb_1.Message.setField(this, 2, value);
          }
          get response() {
            return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
          }
          set response(value: number) {
            pb_1.Message.setField(this, 3, value);
          }
          static fromObject(data: {
            card_info?: ReturnType<typeof CardInfo.prototype.toObject>;
            effect_description?: number;
            response?: number;
          }): IdleData {
            const message = new IdleData({});
            if (data.card_info != null) {
              message.card_info = CardInfo.fromObject(data.card_info);
            }
            if (data.effect_description != null) {
              message.effect_description = data.effect_description;
            }
            if (data.response != null) {
              message.response = data.response;
            }
            return message;
          }
          toObject() {
            const data: {
              card_info?: ReturnType<typeof CardInfo.prototype.toObject>;
              effect_description?: number;
              response?: number;
            } = {};
            if (this.card_info != null) {
              data.card_info = this.card_info.toObject();
            }
            if (this.effect_description != null) {
              data.effect_description = this.effect_description;
            }
            if (this.response != null) {
              data.response = this.response;
            }
            return data;
          }
          serialize(): Uint8Array;
          serialize(w: pb_1.BinaryWriter): void;
          serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_card_info)
              writer.writeMessage(1, this.card_info, () =>
                this.card_info.serialize(writer)
              );
            if (this.effect_description != 0)
              writer.writeInt32(2, this.effect_description);
            if (this.response != 0) writer.writeInt32(3, this.response);
            if (!w) return writer.getResultBuffer();
          }
          static deserialize(bytes: Uint8Array | pb_1.BinaryReader): IdleData {
            const reader =
                bytes instanceof pb_1.BinaryReader
                  ? bytes
                  : new pb_1.BinaryReader(bytes),
              message = new IdleData();
            while (reader.nextField()) {
              if (reader.isEndGroup()) break;
              switch (reader.getFieldNumber()) {
                case 1:
                  reader.readMessage(
                    message.card_info,
                    () => (message.card_info = CardInfo.deserialize(reader))
                  );
                  break;
                case 2:
                  message.effect_description = reader.readInt32();
                  break;
                case 3:
                  message.response = reader.readInt32();
                  break;
                default:
                  reader.skipField();
              }
            }
            return message;
          }
          serializeBinary(): Uint8Array {
            return this.serialize();
          }
          static deserializeBinary(bytes: Uint8Array): IdleData {
            return IdleData.deserialize(bytes);
          }
        }
      }
    }
    export class MsgSelectPlace extends pb_1.Message {
      #one_of_decls: number[][] = [];
      constructor(
        data?:
          | any[]
          | {
              player?: number;
              count?: number;
              places?: StocGameMessage.MsgSelectPlace.SelectAblePlace[];
            }
      ) {
        super();
        pb_1.Message.initialize(
          this,
          Array.isArray(data) ? data : [],
          0,
          -1,
          [3],
          this.#one_of_decls
        );
        if (!Array.isArray(data) && typeof data == "object") {
          if ("player" in data && data.player != undefined) {
            this.player = data.player;
          }
          if ("count" in data && data.count != undefined) {
            this.count = data.count;
          }
          if ("places" in data && data.places != undefined) {
            this.places = data.places;
          }
        }
      }
      get player() {
        return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
      }
      set player(value: number) {
        pb_1.Message.setField(this, 1, value);
      }
      get count() {
        return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
      }
      set count(value: number) {
        pb_1.Message.setField(this, 2, value);
      }
      get places() {
        return pb_1.Message.getRepeatedWrapperField(
          this,
          StocGameMessage.MsgSelectPlace.SelectAblePlace,
          3
        ) as StocGameMessage.MsgSelectPlace.SelectAblePlace[];
      }
      set places(value: StocGameMessage.MsgSelectPlace.SelectAblePlace[]) {
        pb_1.Message.setRepeatedWrapperField(this, 3, value);
      }
      static fromObject(data: {
        player?: number;
        count?: number;
        places?: ReturnType<
          typeof StocGameMessage.MsgSelectPlace.SelectAblePlace.prototype.toObject
        >[];
      }): MsgSelectPlace {
        const message = new MsgSelectPlace({});
        if (data.player != null) {
          message.player = data.player;
        }
        if (data.count != null) {
          message.count = data.count;
        }
        if (data.places != null) {
          message.places = data.places.map((item) =>
            StocGameMessage.MsgSelectPlace.SelectAblePlace.fromObject(item)
          );
        }
        return message;
      }
      toObject() {
        const data: {
          player?: number;
          count?: number;
          places?: ReturnType<
            typeof StocGameMessage.MsgSelectPlace.SelectAblePlace.prototype.toObject
          >[];
        } = {};
        if (this.player != null) {
          data.player = this.player;
        }
        if (this.count != null) {
          data.count = this.count;
        }
        if (this.places != null) {
          data.places = this.places.map(
            (item: StocGameMessage.MsgSelectPlace.SelectAblePlace) =>
              item.toObject()
          );
        }
        return data;
      }
      serialize(): Uint8Array;
      serialize(w: pb_1.BinaryWriter): void;
      serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.player != 0) writer.writeInt32(1, this.player);
        if (this.count != 0) writer.writeInt32(2, this.count);
        if (this.places.length)
          writer.writeRepeatedMessage(
            3,
            this.places,
            (item: StocGameMessage.MsgSelectPlace.SelectAblePlace) =>
              item.serialize(writer)
          );
        if (!w) return writer.getResultBuffer();
      }
      static deserialize(
        bytes: Uint8Array | pb_1.BinaryReader
      ): MsgSelectPlace {
        const reader =
            bytes instanceof pb_1.BinaryReader
              ? bytes
              : new pb_1.BinaryReader(bytes),
          message = new MsgSelectPlace();
        while (reader.nextField()) {
          if (reader.isEndGroup()) break;
          switch (reader.getFieldNumber()) {
            case 1:
              message.player = reader.readInt32();
              break;
            case 2:
              message.count = reader.readInt32();
              break;
            case 3:
              reader.readMessage(message.places, () =>
                pb_1.Message.addToRepeatedWrapperField(
                  message,
                  3,
                  StocGameMessage.MsgSelectPlace.SelectAblePlace.deserialize(
                    reader
                  ),
                  StocGameMessage.MsgSelectPlace.SelectAblePlace
                )
              );
              break;
            default:
              reader.skipField();
          }
        }
        return message;
      }
      serializeBinary(): Uint8Array {
        return this.serialize();
      }
      static deserializeBinary(bytes: Uint8Array): MsgSelectPlace {
        return MsgSelectPlace.deserialize(bytes);
      }
    }
    export namespace MsgSelectPlace {
      export class SelectAblePlace extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(
          data?:
            | any[]
            | {
                controler?: number;
                zone?: CardZone;
                sequence?: number;
              }
        ) {
          super();
          pb_1.Message.initialize(
            this,
            Array.isArray(data) ? data : [],
            0,
            -1,
            [],
            this.#one_of_decls
          );
          if (!Array.isArray(data) && typeof data == "object") {
            if ("controler" in data && data.controler != undefined) {
              this.controler = data.controler;
            }
            if ("zone" in data && data.zone != undefined) {
              this.zone = data.zone;
            }
            if ("sequence" in data && data.sequence != undefined) {
              this.sequence = data.sequence;
            }
          }
        }
        get controler() {
          return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set controler(value: number) {
          pb_1.Message.setField(this, 1, value);
        }
        get zone() {
          return pb_1.Message.getFieldWithDefault(
            this,
            2,
            CardZone.DECK
          ) as CardZone;
        }
        set zone(value: CardZone) {
          pb_1.Message.setField(this, 2, value);
        }
        get sequence() {
          return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
        }
        set sequence(value: number) {
          pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
          controler?: number;
          zone?: CardZone;
          sequence?: number;
        }): SelectAblePlace {
          const message = new SelectAblePlace({});
          if (data.controler != null) {
            message.controler = data.controler;
          }
          if (data.zone != null) {
            message.zone = data.zone;
          }
          if (data.sequence != null) {
            message.sequence = data.sequence;
          }
          return message;
        }
        toObject() {
          const data: {
            controler?: number;
            zone?: CardZone;
            sequence?: number;
          } = {};
          if (this.controler != null) {
            data.controler = this.controler;
          }
          if (this.zone != null) {
            data.zone = this.zone;
          }
          if (this.sequence != null) {
            data.sequence = this.sequence;
          }
          return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
          const writer = w || new pb_1.BinaryWriter();
          if (this.controler != 0) writer.writeInt32(1, this.controler);
          if (this.zone != CardZone.DECK) writer.writeEnum(2, this.zone);
          if (this.sequence != 0) writer.writeInt32(3, this.sequence);
          if (!w) return writer.getResultBuffer();
        }
        static deserialize(
          bytes: Uint8Array | pb_1.BinaryReader
        ): SelectAblePlace {
          const reader =
              bytes instanceof pb_1.BinaryReader
                ? bytes
                : new pb_1.BinaryReader(bytes),
            message = new SelectAblePlace();
          while (reader.nextField()) {
            if (reader.isEndGroup()) break;
            switch (reader.getFieldNumber()) {
              case 1:
                message.controler = reader.readInt32();
                break;
              case 2:
                message.zone = reader.readEnum();
                break;
              case 3:
                message.sequence = reader.readInt32();
                break;
              default:
                reader.skipField();
            }
          }
          return message;
        }
        serializeBinary(): Uint8Array {
          return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): SelectAblePlace {
          return SelectAblePlace.deserialize(bytes);
        }
      }
    }
    export class MsgMove extends pb_1.Message {
      #one_of_decls: number[][] = [];
      constructor(
        data?:
          | any[]
          | {
              code?: number;
              from?: CardLocation;
              to?: CardLocation;
              reason?: number;
            }
      ) {
        super();
        pb_1.Message.initialize(
          this,
          Array.isArray(data) ? data : [],
          0,
          -1,
          [],
          this.#one_of_decls
        );
        if (!Array.isArray(data) && typeof data == "object") {
          if ("code" in data && data.code != undefined) {
            this.code = data.code;
          }
          if ("from" in data && data.from != undefined) {
            this.from = data.from;
          }
          if ("to" in data && data.to != undefined) {
            this.to = data.to;
          }
          if ("reason" in data && data.reason != undefined) {
            this.reason = data.reason;
          }
        }
      }
      get code() {
        return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
      }
      set code(value: number) {
        pb_1.Message.setField(this, 1, value);
      }
      get from() {
        return pb_1.Message.getWrapperField(
          this,
          CardLocation,
          2
        ) as CardLocation;
      }
      set from(value: CardLocation) {
        pb_1.Message.setWrapperField(this, 2, value);
      }
      get has_from() {
        return pb_1.Message.getField(this, 2) != null;
      }
      get to() {
        return pb_1.Message.getWrapperField(
          this,
          CardLocation,
          3
        ) as CardLocation;
      }
      set to(value: CardLocation) {
        pb_1.Message.setWrapperField(this, 3, value);
      }
      get has_to() {
        return pb_1.Message.getField(this, 3) != null;
      }
      get reason() {
        return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
      }
      set reason(value: number) {
        pb_1.Message.setField(this, 4, value);
      }
      static fromObject(data: {
        code?: number;
        from?: ReturnType<typeof CardLocation.prototype.toObject>;
        to?: ReturnType<typeof CardLocation.prototype.toObject>;
        reason?: number;
      }): MsgMove {
        const message = new MsgMove({});
        if (data.code != null) {
          message.code = data.code;
        }
        if (data.from != null) {
          message.from = CardLocation.fromObject(data.from);
        }
        if (data.to != null) {
          message.to = CardLocation.fromObject(data.to);
        }
        if (data.reason != null) {
          message.reason = data.reason;
        }
        return message;
      }
      toObject() {
        const data: {
          code?: number;
          from?: ReturnType<typeof CardLocation.prototype.toObject>;
          to?: ReturnType<typeof CardLocation.prototype.toObject>;
          reason?: number;
        } = {};
        if (this.code != null) {
          data.code = this.code;
        }
        if (this.from != null) {
          data.from = this.from.toObject();
        }
        if (this.to != null) {
          data.to = this.to.toObject();
        }
        if (this.reason != null) {
          data.reason = this.reason;
        }
        return data;
      }
      serialize(): Uint8Array;
      serialize(w: pb_1.BinaryWriter): void;
      serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.code != 0) writer.writeInt32(1, this.code);
        if (this.has_from)
          writer.writeMessage(2, this.from, () => this.from.serialize(writer));
        if (this.has_to)
          writer.writeMessage(3, this.to, () => this.to.serialize(writer));
        if (this.reason != 0) writer.writeInt32(4, this.reason);
        if (!w) return writer.getResultBuffer();
      }
      static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgMove {
        const reader =
            bytes instanceof pb_1.BinaryReader
              ? bytes
              : new pb_1.BinaryReader(bytes),
          message = new MsgMove();
        while (reader.nextField()) {
          if (reader.isEndGroup()) break;
          switch (reader.getFieldNumber()) {
            case 1:
              message.code = reader.readInt32();
              break;
            case 2:
              reader.readMessage(
                message.from,
                () => (message.from = CardLocation.deserialize(reader))
              );
              break;
            case 3:
              reader.readMessage(
                message.to,
                () => (message.to = CardLocation.deserialize(reader))
              );
              break;
            case 4:
              message.reason = reader.readInt32();
              break;
            default:
              reader.skipField();
          }
        }
        return message;
      }
      serializeBinary(): Uint8Array {
        return this.serialize();
      }
      static deserializeBinary(bytes: Uint8Array): MsgMove {
        return MsgMove.deserialize(bytes);
      }
    }
    export class MsgSelectCard extends pb_1.Message {
      #one_of_decls: number[][] = [];
      constructor(
        data?:
          | any[]
          | {
              player?: number;
              cancelable?: boolean;
              min?: number;
              max?: number;
              cards?: StocGameMessage.MsgSelectCard.SelectAbleCard[];
            }
      ) {
        super();
        pb_1.Message.initialize(
          this,
          Array.isArray(data) ? data : [],
          0,
          -1,
          [5],
          this.#one_of_decls
        );
        if (!Array.isArray(data) && typeof data == "object") {
          if ("player" in data && data.player != undefined) {
            this.player = data.player;
          }
          if ("cancelable" in data && data.cancelable != undefined) {
            this.cancelable = data.cancelable;
          }
          if ("min" in data && data.min != undefined) {
            this.min = data.min;
          }
          if ("max" in data && data.max != undefined) {
            this.max = data.max;
          }
          if ("cards" in data && data.cards != undefined) {
            this.cards = data.cards;
          }
        }
      }
      get player() {
        return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
      }
      set player(value: number) {
        pb_1.Message.setField(this, 1, value);
      }
      get cancelable() {
        return pb_1.Message.getFieldWithDefault(this, 2, false) as boolean;
      }
      set cancelable(value: boolean) {
        pb_1.Message.setField(this, 2, value);
      }
      get min() {
        return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
      }
      set min(value: number) {
        pb_1.Message.setField(this, 3, value);
      }
      get max() {
        return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
      }
      set max(value: number) {
        pb_1.Message.setField(this, 4, value);
      }
      get cards() {
        return pb_1.Message.getRepeatedWrapperField(
          this,
          StocGameMessage.MsgSelectCard.SelectAbleCard,
          5
        ) as StocGameMessage.MsgSelectCard.SelectAbleCard[];
      }
      set cards(value: StocGameMessage.MsgSelectCard.SelectAbleCard[]) {
        pb_1.Message.setRepeatedWrapperField(this, 5, value);
      }
      static fromObject(data: {
        player?: number;
        cancelable?: boolean;
        min?: number;
        max?: number;
        cards?: ReturnType<
          typeof StocGameMessage.MsgSelectCard.SelectAbleCard.prototype.toObject
        >[];
      }): MsgSelectCard {
        const message = new MsgSelectCard({});
        if (data.player != null) {
          message.player = data.player;
        }
        if (data.cancelable != null) {
          message.cancelable = data.cancelable;
        }
        if (data.min != null) {
          message.min = data.min;
        }
        if (data.max != null) {
          message.max = data.max;
        }
        if (data.cards != null) {
          message.cards = data.cards.map((item) =>
            StocGameMessage.MsgSelectCard.SelectAbleCard.fromObject(item)
          );
        }
        return message;
      }
      toObject() {
        const data: {
          player?: number;
          cancelable?: boolean;
          min?: number;
          max?: number;
          cards?: ReturnType<
            typeof StocGameMessage.MsgSelectCard.SelectAbleCard.prototype.toObject
          >[];
        } = {};
        if (this.player != null) {
          data.player = this.player;
        }
        if (this.cancelable != null) {
          data.cancelable = this.cancelable;
        }
        if (this.min != null) {
          data.min = this.min;
        }
        if (this.max != null) {
          data.max = this.max;
        }
        if (this.cards != null) {
          data.cards = this.cards.map(
            (item: StocGameMessage.MsgSelectCard.SelectAbleCard) =>
              item.toObject()
          );
        }
        return data;
      }
      serialize(): Uint8Array;
      serialize(w: pb_1.BinaryWriter): void;
      serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.player != 0) writer.writeInt32(1, this.player);
        if (this.cancelable != false) writer.writeBool(2, this.cancelable);
        if (this.min != 0) writer.writeInt32(3, this.min);
        if (this.max != 0) writer.writeInt32(4, this.max);
        if (this.cards.length)
          writer.writeRepeatedMessage(
            5,
            this.cards,
            (item: StocGameMessage.MsgSelectCard.SelectAbleCard) =>
              item.serialize(writer)
          );
        if (!w) return writer.getResultBuffer();
      }
      static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgSelectCard {
        const reader =
            bytes instanceof pb_1.BinaryReader
              ? bytes
              : new pb_1.BinaryReader(bytes),
          message = new MsgSelectCard();
        while (reader.nextField()) {
          if (reader.isEndGroup()) break;
          switch (reader.getFieldNumber()) {
            case 1:
              message.player = reader.readInt32();
              break;
            case 2:
              message.cancelable = reader.readBool();
              break;
            case 3:
              message.min = reader.readInt32();
              break;
            case 4:
              message.max = reader.readInt32();
              break;
            case 5:
              reader.readMessage(message.cards, () =>
                pb_1.Message.addToRepeatedWrapperField(
                  message,
                  5,
                  StocGameMessage.MsgSelectCard.SelectAbleCard.deserialize(
                    reader
                  ),
                  StocGameMessage.MsgSelectCard.SelectAbleCard
                )
              );
              break;
            default:
              reader.skipField();
          }
        }
        return message;
      }
      serializeBinary(): Uint8Array {
        return this.serialize();
      }
      static deserializeBinary(bytes: Uint8Array): MsgSelectCard {
        return MsgSelectCard.deserialize(bytes);
      }
    }
    export namespace MsgSelectCard {
      export class SelectAbleCard extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(
          data?:
            | any[]
            | {
                code?: number;
                location?: CardLocation;
                response?: number;
              }
        ) {
          super();
          pb_1.Message.initialize(
            this,
            Array.isArray(data) ? data : [],
            0,
            -1,
            [],
            this.#one_of_decls
          );
          if (!Array.isArray(data) && typeof data == "object") {
            if ("code" in data && data.code != undefined) {
              this.code = data.code;
            }
            if ("location" in data && data.location != undefined) {
              this.location = data.location;
            }
            if ("response" in data && data.response != undefined) {
              this.response = data.response;
            }
          }
        }
        get code() {
          return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set code(value: number) {
          pb_1.Message.setField(this, 1, value);
        }
        get location() {
          return pb_1.Message.getWrapperField(
            this,
            CardLocation,
            2
          ) as CardLocation;
        }
        set location(value: CardLocation) {
          pb_1.Message.setWrapperField(this, 2, value);
        }
        get has_location() {
          return pb_1.Message.getField(this, 2) != null;
        }
        get response() {
          return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
        }
        set response(value: number) {
          pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
          code?: number;
          location?: ReturnType<typeof CardLocation.prototype.toObject>;
          response?: number;
        }): SelectAbleCard {
          const message = new SelectAbleCard({});
          if (data.code != null) {
            message.code = data.code;
          }
          if (data.location != null) {
            message.location = CardLocation.fromObject(data.location);
          }
          if (data.response != null) {
            message.response = data.response;
          }
          return message;
        }
        toObject() {
          const data: {
            code?: number;
            location?: ReturnType<typeof CardLocation.prototype.toObject>;
            response?: number;
          } = {};
          if (this.code != null) {
            data.code = this.code;
          }
          if (this.location != null) {
            data.location = this.location.toObject();
          }
          if (this.response != null) {
            data.response = this.response;
          }
          return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
          const writer = w || new pb_1.BinaryWriter();
          if (this.code != 0) writer.writeInt32(1, this.code);
          if (this.has_location)
            writer.writeMessage(2, this.location, () =>
              this.location.serialize(writer)
            );
          if (this.response != 0) writer.writeInt32(3, this.response);
          if (!w) return writer.getResultBuffer();
        }
        static deserialize(
          bytes: Uint8Array | pb_1.BinaryReader
        ): SelectAbleCard {
          const reader =
              bytes instanceof pb_1.BinaryReader
                ? bytes
                : new pb_1.BinaryReader(bytes),
            message = new SelectAbleCard();
          while (reader.nextField()) {
            if (reader.isEndGroup()) break;
            switch (reader.getFieldNumber()) {
              case 1:
                message.code = reader.readInt32();
                break;
              case 2:
                reader.readMessage(
                  message.location,
                  () => (message.location = CardLocation.deserialize(reader))
                );
                break;
              case 3:
                message.response = reader.readInt32();
                break;
              default:
                reader.skipField();
            }
          }
          return message;
        }
        serializeBinary(): Uint8Array {
          return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): SelectAbleCard {
          return SelectAbleCard.deserialize(bytes);
        }
      }
    }
    export class MsgSelectChain extends pb_1.Message {
      #one_of_decls: number[][] = [];
      constructor(
        data?:
          | any[]
          | {
              player?: number;
              special_count?: number;
              forced?: boolean;
              hint0?: number;
              hint1?: number;
              chains?: StocGameMessage.MsgSelectChain.Chain[];
            }
      ) {
        super();
        pb_1.Message.initialize(
          this,
          Array.isArray(data) ? data : [],
          0,
          -1,
          [6],
          this.#one_of_decls
        );
        if (!Array.isArray(data) && typeof data == "object") {
          if ("player" in data && data.player != undefined) {
            this.player = data.player;
          }
          if ("special_count" in data && data.special_count != undefined) {
            this.special_count = data.special_count;
          }
          if ("forced" in data && data.forced != undefined) {
            this.forced = data.forced;
          }
          if ("hint0" in data && data.hint0 != undefined) {
            this.hint0 = data.hint0;
          }
          if ("hint1" in data && data.hint1 != undefined) {
            this.hint1 = data.hint1;
          }
          if ("chains" in data && data.chains != undefined) {
            this.chains = data.chains;
          }
        }
      }
      get player() {
        return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
      }
      set player(value: number) {
        pb_1.Message.setField(this, 1, value);
      }
      get special_count() {
        return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
      }
      set special_count(value: number) {
        pb_1.Message.setField(this, 2, value);
      }
      get forced() {
        return pb_1.Message.getFieldWithDefault(this, 3, false) as boolean;
      }
      set forced(value: boolean) {
        pb_1.Message.setField(this, 3, value);
      }
      get hint0() {
        return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
      }
      set hint0(value: number) {
        pb_1.Message.setField(this, 4, value);
      }
      get hint1() {
        return pb_1.Message.getFieldWithDefault(this, 5, 0) as number;
      }
      set hint1(value: number) {
        pb_1.Message.setField(this, 5, value);
      }
      get chains() {
        return pb_1.Message.getRepeatedWrapperField(
          this,
          StocGameMessage.MsgSelectChain.Chain,
          6
        ) as StocGameMessage.MsgSelectChain.Chain[];
      }
      set chains(value: StocGameMessage.MsgSelectChain.Chain[]) {
        pb_1.Message.setRepeatedWrapperField(this, 6, value);
      }
      static fromObject(data: {
        player?: number;
        special_count?: number;
        forced?: boolean;
        hint0?: number;
        hint1?: number;
        chains?: ReturnType<
          typeof StocGameMessage.MsgSelectChain.Chain.prototype.toObject
        >[];
      }): MsgSelectChain {
        const message = new MsgSelectChain({});
        if (data.player != null) {
          message.player = data.player;
        }
        if (data.special_count != null) {
          message.special_count = data.special_count;
        }
        if (data.forced != null) {
          message.forced = data.forced;
        }
        if (data.hint0 != null) {
          message.hint0 = data.hint0;
        }
        if (data.hint1 != null) {
          message.hint1 = data.hint1;
        }
        if (data.chains != null) {
          message.chains = data.chains.map((item) =>
            StocGameMessage.MsgSelectChain.Chain.fromObject(item)
          );
        }
        return message;
      }
      toObject() {
        const data: {
          player?: number;
          special_count?: number;
          forced?: boolean;
          hint0?: number;
          hint1?: number;
          chains?: ReturnType<
            typeof StocGameMessage.MsgSelectChain.Chain.prototype.toObject
          >[];
        } = {};
        if (this.player != null) {
          data.player = this.player;
        }
        if (this.special_count != null) {
          data.special_count = this.special_count;
        }
        if (this.forced != null) {
          data.forced = this.forced;
        }
        if (this.hint0 != null) {
          data.hint0 = this.hint0;
        }
        if (this.hint1 != null) {
          data.hint1 = this.hint1;
        }
        if (this.chains != null) {
          data.chains = this.chains.map(
            (item: StocGameMessage.MsgSelectChain.Chain) => item.toObject()
          );
        }
        return data;
      }
      serialize(): Uint8Array;
      serialize(w: pb_1.BinaryWriter): void;
      serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.player != 0) writer.writeInt32(1, this.player);
        if (this.special_count != 0) writer.writeInt32(2, this.special_count);
        if (this.forced != false) writer.writeBool(3, this.forced);
        if (this.hint0 != 0) writer.writeInt32(4, this.hint0);
        if (this.hint1 != 0) writer.writeInt32(5, this.hint1);
        if (this.chains.length)
          writer.writeRepeatedMessage(
            6,
            this.chains,
            (item: StocGameMessage.MsgSelectChain.Chain) =>
              item.serialize(writer)
          );
        if (!w) return writer.getResultBuffer();
      }
      static deserialize(
        bytes: Uint8Array | pb_1.BinaryReader
      ): MsgSelectChain {
        const reader =
            bytes instanceof pb_1.BinaryReader
              ? bytes
              : new pb_1.BinaryReader(bytes),
          message = new MsgSelectChain();
        while (reader.nextField()) {
          if (reader.isEndGroup()) break;
          switch (reader.getFieldNumber()) {
            case 1:
              message.player = reader.readInt32();
              break;
            case 2:
              message.special_count = reader.readInt32();
              break;
            case 3:
              message.forced = reader.readBool();
              break;
            case 4:
              message.hint0 = reader.readInt32();
              break;
            case 5:
              message.hint1 = reader.readInt32();
              break;
            case 6:
              reader.readMessage(message.chains, () =>
                pb_1.Message.addToRepeatedWrapperField(
                  message,
                  6,
                  StocGameMessage.MsgSelectChain.Chain.deserialize(reader),
                  StocGameMessage.MsgSelectChain.Chain
                )
              );
              break;
            default:
              reader.skipField();
          }
        }
        return message;
      }
      serializeBinary(): Uint8Array {
        return this.serialize();
      }
      static deserializeBinary(bytes: Uint8Array): MsgSelectChain {
        return MsgSelectChain.deserialize(bytes);
      }
    }
    export namespace MsgSelectChain {
      export enum ChainFlag {
        COMMON = 0,
        EDESC_OPERATION = 1,
        EDESC_RESET = 2,
      }
      export class Chain extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(
          data?:
            | any[]
            | {
                flag?: StocGameMessage.MsgSelectChain.ChainFlag;
                code?: number;
                location?: CardLocation;
                effect_description?: number;
                response?: number;
              }
        ) {
          super();
          pb_1.Message.initialize(
            this,
            Array.isArray(data) ? data : [],
            0,
            -1,
            [],
            this.#one_of_decls
          );
          if (!Array.isArray(data) && typeof data == "object") {
            if ("flag" in data && data.flag != undefined) {
              this.flag = data.flag;
            }
            if ("code" in data && data.code != undefined) {
              this.code = data.code;
            }
            if ("location" in data && data.location != undefined) {
              this.location = data.location;
            }
            if (
              "effect_description" in data &&
              data.effect_description != undefined
            ) {
              this.effect_description = data.effect_description;
            }
            if ("response" in data && data.response != undefined) {
              this.response = data.response;
            }
          }
        }
        get flag() {
          return pb_1.Message.getFieldWithDefault(
            this,
            1,
            StocGameMessage.MsgSelectChain.ChainFlag.COMMON
          ) as StocGameMessage.MsgSelectChain.ChainFlag;
        }
        set flag(value: StocGameMessage.MsgSelectChain.ChainFlag) {
          pb_1.Message.setField(this, 1, value);
        }
        get code() {
          return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set code(value: number) {
          pb_1.Message.setField(this, 2, value);
        }
        get location() {
          return pb_1.Message.getWrapperField(
            this,
            CardLocation,
            3
          ) as CardLocation;
        }
        set location(value: CardLocation) {
          pb_1.Message.setWrapperField(this, 3, value);
        }
        get has_location() {
          return pb_1.Message.getField(this, 3) != null;
        }
        get effect_description() {
          return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
        }
        set effect_description(value: number) {
          pb_1.Message.setField(this, 4, value);
        }
        get response() {
          return pb_1.Message.getFieldWithDefault(this, 5, 0) as number;
        }
        set response(value: number) {
          pb_1.Message.setField(this, 5, value);
        }
        static fromObject(data: {
          flag?: StocGameMessage.MsgSelectChain.ChainFlag;
          code?: number;
          location?: ReturnType<typeof CardLocation.prototype.toObject>;
          effect_description?: number;
          response?: number;
        }): Chain {
          const message = new Chain({});
          if (data.flag != null) {
            message.flag = data.flag;
          }
          if (data.code != null) {
            message.code = data.code;
          }
          if (data.location != null) {
            message.location = CardLocation.fromObject(data.location);
          }
          if (data.effect_description != null) {
            message.effect_description = data.effect_description;
          }
          if (data.response != null) {
            message.response = data.response;
          }
          return message;
        }
        toObject() {
          const data: {
            flag?: StocGameMessage.MsgSelectChain.ChainFlag;
            code?: number;
            location?: ReturnType<typeof CardLocation.prototype.toObject>;
            effect_description?: number;
            response?: number;
          } = {};
          if (this.flag != null) {
            data.flag = this.flag;
          }
          if (this.code != null) {
            data.code = this.code;
          }
          if (this.location != null) {
            data.location = this.location.toObject();
          }
          if (this.effect_description != null) {
            data.effect_description = this.effect_description;
          }
          if (this.response != null) {
            data.response = this.response;
          }
          return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
          const writer = w || new pb_1.BinaryWriter();
          if (this.flag != StocGameMessage.MsgSelectChain.ChainFlag.COMMON)
            writer.writeEnum(1, this.flag);
          if (this.code != 0) writer.writeInt32(2, this.code);
          if (this.has_location)
            writer.writeMessage(3, this.location, () =>
              this.location.serialize(writer)
            );
          if (this.effect_description != 0)
            writer.writeInt32(4, this.effect_description);
          if (this.response != 0) writer.writeInt32(5, this.response);
          if (!w) return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Chain {
          const reader =
              bytes instanceof pb_1.BinaryReader
                ? bytes
                : new pb_1.BinaryReader(bytes),
            message = new Chain();
          while (reader.nextField()) {
            if (reader.isEndGroup()) break;
            switch (reader.getFieldNumber()) {
              case 1:
                message.flag = reader.readEnum();
                break;
              case 2:
                message.code = reader.readInt32();
                break;
              case 3:
                reader.readMessage(
                  message.location,
                  () => (message.location = CardLocation.deserialize(reader))
                );
                break;
              case 4:
                message.effect_description = reader.readInt32();
                break;
              case 5:
                message.response = reader.readInt32();
                break;
              default:
                reader.skipField();
            }
          }
          return message;
        }
        serializeBinary(): Uint8Array {
          return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Chain {
          return Chain.deserialize(bytes);
        }
      }
    }
    export class MsgSelectEffectYn extends pb_1.Message {
      #one_of_decls: number[][] = [];
      constructor(
        data?:
          | any[]
          | {
              player?: number;
              code?: number;
              location?: CardLocation;
              effect_description?: number;
            }
      ) {
        super();
        pb_1.Message.initialize(
          this,
          Array.isArray(data) ? data : [],
          0,
          -1,
          [],
          this.#one_of_decls
        );
        if (!Array.isArray(data) && typeof data == "object") {
          if ("player" in data && data.player != undefined) {
            this.player = data.player;
          }
          if ("code" in data && data.code != undefined) {
            this.code = data.code;
          }
          if ("location" in data && data.location != undefined) {
            this.location = data.location;
          }
          if (
            "effect_description" in data &&
            data.effect_description != undefined
          ) {
            this.effect_description = data.effect_description;
          }
        }
      }
      get player() {
        return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
      }
      set player(value: number) {
        pb_1.Message.setField(this, 1, value);
      }
      get code() {
        return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
      }
      set code(value: number) {
        pb_1.Message.setField(this, 2, value);
      }
      get location() {
        return pb_1.Message.getWrapperField(
          this,
          CardLocation,
          3
        ) as CardLocation;
      }
      set location(value: CardLocation) {
        pb_1.Message.setWrapperField(this, 3, value);
      }
      get has_location() {
        return pb_1.Message.getField(this, 3) != null;
      }
      get effect_description() {
        return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
      }
      set effect_description(value: number) {
        pb_1.Message.setField(this, 4, value);
      }
      static fromObject(data: {
        player?: number;
        code?: number;
        location?: ReturnType<typeof CardLocation.prototype.toObject>;
        effect_description?: number;
      }): MsgSelectEffectYn {
        const message = new MsgSelectEffectYn({});
        if (data.player != null) {
          message.player = data.player;
        }
        if (data.code != null) {
          message.code = data.code;
        }
        if (data.location != null) {
          message.location = CardLocation.fromObject(data.location);
        }
        if (data.effect_description != null) {
          message.effect_description = data.effect_description;
        }
        return message;
      }
      toObject() {
        const data: {
          player?: number;
          code?: number;
          location?: ReturnType<typeof CardLocation.prototype.toObject>;
          effect_description?: number;
        } = {};
        if (this.player != null) {
          data.player = this.player;
        }
        if (this.code != null) {
          data.code = this.code;
        }
        if (this.location != null) {
          data.location = this.location.toObject();
        }
        if (this.effect_description != null) {
          data.effect_description = this.effect_description;
        }
        return data;
      }
      serialize(): Uint8Array;
      serialize(w: pb_1.BinaryWriter): void;
      serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.player != 0) writer.writeInt32(1, this.player);
        if (this.code != 0) writer.writeInt32(2, this.code);
        if (this.has_location)
          writer.writeMessage(3, this.location, () =>
            this.location.serialize(writer)
          );
        if (this.effect_description != 0)
          writer.writeInt32(4, this.effect_description);
        if (!w) return writer.getResultBuffer();
      }
      static deserialize(
        bytes: Uint8Array | pb_1.BinaryReader
      ): MsgSelectEffectYn {
        const reader =
            bytes instanceof pb_1.BinaryReader
              ? bytes
              : new pb_1.BinaryReader(bytes),
          message = new MsgSelectEffectYn();
        while (reader.nextField()) {
          if (reader.isEndGroup()) break;
          switch (reader.getFieldNumber()) {
            case 1:
              message.player = reader.readInt32();
              break;
            case 2:
              message.code = reader.readInt32();
              break;
            case 3:
              reader.readMessage(
                message.location,
                () => (message.location = CardLocation.deserialize(reader))
              );
              break;
            case 4:
              message.effect_description = reader.readInt32();
              break;
            default:
              reader.skipField();
          }
        }
        return message;
      }
      serializeBinary(): Uint8Array {
        return this.serialize();
      }
      static deserializeBinary(bytes: Uint8Array): MsgSelectEffectYn {
        return MsgSelectEffectYn.deserialize(bytes);
      }
    }
    export class MsgSelectPosition extends pb_1.Message {
      #one_of_decls: number[][] = [];
      constructor(
        data?:
          | any[]
          | {
              player?: number;
              code?: number;
              positions?: StocGameMessage.MsgSelectPosition.SelectAblePosition[];
            }
      ) {
        super();
        pb_1.Message.initialize(
          this,
          Array.isArray(data) ? data : [],
          0,
          -1,
          [3],
          this.#one_of_decls
        );
        if (!Array.isArray(data) && typeof data == "object") {
          if ("player" in data && data.player != undefined) {
            this.player = data.player;
          }
          if ("code" in data && data.code != undefined) {
            this.code = data.code;
          }
          if ("positions" in data && data.positions != undefined) {
            this.positions = data.positions;
          }
        }
      }
      get player() {
        return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
      }
      set player(value: number) {
        pb_1.Message.setField(this, 1, value);
      }
      get code() {
        return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
      }
      set code(value: number) {
        pb_1.Message.setField(this, 2, value);
      }
      get positions() {
        return pb_1.Message.getRepeatedWrapperField(
          this,
          StocGameMessage.MsgSelectPosition.SelectAblePosition,
          3
        ) as StocGameMessage.MsgSelectPosition.SelectAblePosition[];
      }
      set positions(
        value: StocGameMessage.MsgSelectPosition.SelectAblePosition[]
      ) {
        pb_1.Message.setRepeatedWrapperField(this, 3, value);
      }
      static fromObject(data: {
        player?: number;
        code?: number;
        positions?: ReturnType<
          typeof StocGameMessage.MsgSelectPosition.SelectAblePosition.prototype.toObject
        >[];
      }): MsgSelectPosition {
        const message = new MsgSelectPosition({});
        if (data.player != null) {
          message.player = data.player;
        }
        if (data.code != null) {
          message.code = data.code;
        }
        if (data.positions != null) {
          message.positions = data.positions.map((item) =>
            StocGameMessage.MsgSelectPosition.SelectAblePosition.fromObject(
              item
            )
          );
        }
        return message;
      }
      toObject() {
        const data: {
          player?: number;
          code?: number;
          positions?: ReturnType<
            typeof StocGameMessage.MsgSelectPosition.SelectAblePosition.prototype.toObject
          >[];
        } = {};
        if (this.player != null) {
          data.player = this.player;
        }
        if (this.code != null) {
          data.code = this.code;
        }
        if (this.positions != null) {
          data.positions = this.positions.map(
            (item: StocGameMessage.MsgSelectPosition.SelectAblePosition) =>
              item.toObject()
          );
        }
        return data;
      }
      serialize(): Uint8Array;
      serialize(w: pb_1.BinaryWriter): void;
      serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.player != 0) writer.writeInt32(1, this.player);
        if (this.code != 0) writer.writeInt32(2, this.code);
        if (this.positions.length)
          writer.writeRepeatedMessage(
            3,
            this.positions,
            (item: StocGameMessage.MsgSelectPosition.SelectAblePosition) =>
              item.serialize(writer)
          );
        if (!w) return writer.getResultBuffer();
      }
      static deserialize(
        bytes: Uint8Array | pb_1.BinaryReader
      ): MsgSelectPosition {
        const reader =
            bytes instanceof pb_1.BinaryReader
              ? bytes
              : new pb_1.BinaryReader(bytes),
          message = new MsgSelectPosition();
        while (reader.nextField()) {
          if (reader.isEndGroup()) break;
          switch (reader.getFieldNumber()) {
            case 1:
              message.player = reader.readInt32();
              break;
            case 2:
              message.code = reader.readInt32();
              break;
            case 3:
              reader.readMessage(message.positions, () =>
                pb_1.Message.addToRepeatedWrapperField(
                  message,
                  3,
                  StocGameMessage.MsgSelectPosition.SelectAblePosition.deserialize(
                    reader
                  ),
                  StocGameMessage.MsgSelectPosition.SelectAblePosition
                )
              );
              break;
            default:
              reader.skipField();
          }
        }
        return message;
      }
      serializeBinary(): Uint8Array {
        return this.serialize();
      }
      static deserializeBinary(bytes: Uint8Array): MsgSelectPosition {
        return MsgSelectPosition.deserialize(bytes);
      }
    }
    export namespace MsgSelectPosition {
      export class SelectAblePosition extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(
          data?:
            | any[]
            | {
                position?: CardPosition;
              }
        ) {
          super();
          pb_1.Message.initialize(
            this,
            Array.isArray(data) ? data : [],
            0,
            -1,
            [],
            this.#one_of_decls
          );
          if (!Array.isArray(data) && typeof data == "object") {
            if ("position" in data && data.position != undefined) {
              this.position = data.position;
            }
          }
        }
        get position() {
          return pb_1.Message.getFieldWithDefault(
            this,
            1,
            CardPosition.FACEUP_ATTACK
          ) as CardPosition;
        }
        set position(value: CardPosition) {
          pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
          position?: CardPosition;
        }): SelectAblePosition {
          const message = new SelectAblePosition({});
          if (data.position != null) {
            message.position = data.position;
          }
          return message;
        }
        toObject() {
          const data: {
            position?: CardPosition;
          } = {};
          if (this.position != null) {
            data.position = this.position;
          }
          return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
          const writer = w || new pb_1.BinaryWriter();
          if (this.position != CardPosition.FACEUP_ATTACK)
            writer.writeEnum(1, this.position);
          if (!w) return writer.getResultBuffer();
        }
        static deserialize(
          bytes: Uint8Array | pb_1.BinaryReader
        ): SelectAblePosition {
          const reader =
              bytes instanceof pb_1.BinaryReader
                ? bytes
                : new pb_1.BinaryReader(bytes),
            message = new SelectAblePosition();
          while (reader.nextField()) {
            if (reader.isEndGroup()) break;
            switch (reader.getFieldNumber()) {
              case 1:
                message.position = reader.readEnum();
                break;
              default:
                reader.skipField();
            }
          }
          return message;
        }
        serializeBinary(): Uint8Array {
          return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): SelectAblePosition {
          return SelectAblePosition.deserialize(bytes);
        }
      }
    }
    export class MsgSelectOption extends pb_1.Message {
      #one_of_decls: number[][] = [];
      constructor(
        data?:
          | any[]
          | {
              player?: number;
              options?: StocGameMessage.MsgSelectOption.Option[];
            }
      ) {
        super();
        pb_1.Message.initialize(
          this,
          Array.isArray(data) ? data : [],
          0,
          -1,
          [2],
          this.#one_of_decls
        );
        if (!Array.isArray(data) && typeof data == "object") {
          if ("player" in data && data.player != undefined) {
            this.player = data.player;
          }
          if ("options" in data && data.options != undefined) {
            this.options = data.options;
          }
        }
      }
      get player() {
        return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
      }
      set player(value: number) {
        pb_1.Message.setField(this, 1, value);
      }
      get options() {
        return pb_1.Message.getRepeatedWrapperField(
          this,
          StocGameMessage.MsgSelectOption.Option,
          2
        ) as StocGameMessage.MsgSelectOption.Option[];
      }
      set options(value: StocGameMessage.MsgSelectOption.Option[]) {
        pb_1.Message.setRepeatedWrapperField(this, 2, value);
      }
      static fromObject(data: {
        player?: number;
        options?: ReturnType<
          typeof StocGameMessage.MsgSelectOption.Option.prototype.toObject
        >[];
      }): MsgSelectOption {
        const message = new MsgSelectOption({});
        if (data.player != null) {
          message.player = data.player;
        }
        if (data.options != null) {
          message.options = data.options.map((item) =>
            StocGameMessage.MsgSelectOption.Option.fromObject(item)
          );
        }
        return message;
      }
      toObject() {
        const data: {
          player?: number;
          options?: ReturnType<
            typeof StocGameMessage.MsgSelectOption.Option.prototype.toObject
          >[];
        } = {};
        if (this.player != null) {
          data.player = this.player;
        }
        if (this.options != null) {
          data.options = this.options.map(
            (item: StocGameMessage.MsgSelectOption.Option) => item.toObject()
          );
        }
        return data;
      }
      serialize(): Uint8Array;
      serialize(w: pb_1.BinaryWriter): void;
      serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.player != 0) writer.writeInt32(1, this.player);
        if (this.options.length)
          writer.writeRepeatedMessage(
            2,
            this.options,
            (item: StocGameMessage.MsgSelectOption.Option) =>
              item.serialize(writer)
          );
        if (!w) return writer.getResultBuffer();
      }
      static deserialize(
        bytes: Uint8Array | pb_1.BinaryReader
      ): MsgSelectOption {
        const reader =
            bytes instanceof pb_1.BinaryReader
              ? bytes
              : new pb_1.BinaryReader(bytes),
          message = new MsgSelectOption();
        while (reader.nextField()) {
          if (reader.isEndGroup()) break;
          switch (reader.getFieldNumber()) {
            case 1:
              message.player = reader.readInt32();
              break;
            case 2:
              reader.readMessage(message.options, () =>
                pb_1.Message.addToRepeatedWrapperField(
                  message,
                  2,
                  StocGameMessage.MsgSelectOption.Option.deserialize(reader),
                  StocGameMessage.MsgSelectOption.Option
                )
              );
              break;
            default:
              reader.skipField();
          }
        }
        return message;
      }
      serializeBinary(): Uint8Array {
        return this.serialize();
      }
      static deserializeBinary(bytes: Uint8Array): MsgSelectOption {
        return MsgSelectOption.deserialize(bytes);
      }
    }
    export namespace MsgSelectOption {
      export class Option extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(
          data?:
            | any[]
            | {
                code?: number;
                response?: number;
              }
        ) {
          super();
          pb_1.Message.initialize(
            this,
            Array.isArray(data) ? data : [],
            0,
            -1,
            [],
            this.#one_of_decls
          );
          if (!Array.isArray(data) && typeof data == "object") {
            if ("code" in data && data.code != undefined) {
              this.code = data.code;
            }
            if ("response" in data && data.response != undefined) {
              this.response = data.response;
            }
          }
        }
        get code() {
          return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set code(value: number) {
          pb_1.Message.setField(this, 1, value);
        }
        get response() {
          return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set response(value: number) {
          pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: { code?: number; response?: number }): Option {
          const message = new Option({});
          if (data.code != null) {
            message.code = data.code;
          }
          if (data.response != null) {
            message.response = data.response;
          }
          return message;
        }
        toObject() {
          const data: {
            code?: number;
            response?: number;
          } = {};
          if (this.code != null) {
            data.code = this.code;
          }
          if (this.response != null) {
            data.response = this.response;
          }
          return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
          const writer = w || new pb_1.BinaryWriter();
          if (this.code != 0) writer.writeInt32(1, this.code);
          if (this.response != 0) writer.writeInt32(2, this.response);
          if (!w) return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Option {
          const reader =
              bytes instanceof pb_1.BinaryReader
                ? bytes
                : new pb_1.BinaryReader(bytes),
            message = new Option();
          while (reader.nextField()) {
            if (reader.isEndGroup()) break;
            switch (reader.getFieldNumber()) {
              case 1:
                message.code = reader.readInt32();
                break;
              case 2:
                message.response = reader.readInt32();
                break;
              default:
                reader.skipField();
            }
          }
          return message;
        }
        serializeBinary(): Uint8Array {
          return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Option {
          return Option.deserialize(bytes);
        }
      }
    }
    export class MsgShuffleHand extends pb_1.Message {
      #one_of_decls: number[][] = [];
      constructor(
        data?:
          | any[]
          | {
              player?: number;
              hands?: number[];
            }
      ) {
        super();
        pb_1.Message.initialize(
          this,
          Array.isArray(data) ? data : [],
          0,
          -1,
          [2],
          this.#one_of_decls
        );
        if (!Array.isArray(data) && typeof data == "object") {
          if ("player" in data && data.player != undefined) {
            this.player = data.player;
          }
          if ("hands" in data && data.hands != undefined) {
            this.hands = data.hands;
          }
        }
      }
      get player() {
        return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
      }
      set player(value: number) {
        pb_1.Message.setField(this, 1, value);
      }
      get hands() {
        return pb_1.Message.getFieldWithDefault(this, 2, []) as number[];
      }
      set hands(value: number[]) {
        pb_1.Message.setField(this, 2, value);
      }
      static fromObject(data: {
        player?: number;
        hands?: number[];
      }): MsgShuffleHand {
        const message = new MsgShuffleHand({});
        if (data.player != null) {
          message.player = data.player;
        }
        if (data.hands != null) {
          message.hands = data.hands;
        }
        return message;
      }
      toObject() {
        const data: {
          player?: number;
          hands?: number[];
        } = {};
        if (this.player != null) {
          data.player = this.player;
        }
        if (this.hands != null) {
          data.hands = this.hands;
        }
        return data;
      }
      serialize(): Uint8Array;
      serialize(w: pb_1.BinaryWriter): void;
      serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.player != 0) writer.writeInt32(1, this.player);
        if (this.hands.length) writer.writePackedInt32(2, this.hands);
        if (!w) return writer.getResultBuffer();
      }
      static deserialize(
        bytes: Uint8Array | pb_1.BinaryReader
      ): MsgShuffleHand {
        const reader =
            bytes instanceof pb_1.BinaryReader
              ? bytes
              : new pb_1.BinaryReader(bytes),
          message = new MsgShuffleHand();
        while (reader.nextField()) {
          if (reader.isEndGroup()) break;
          switch (reader.getFieldNumber()) {
            case 1:
              message.player = reader.readInt32();
              break;
            case 2:
              message.hands = reader.readPackedInt32();
              break;
            default:
              reader.skipField();
          }
        }
        return message;
      }
      serializeBinary(): Uint8Array {
        return this.serialize();
      }
      static deserializeBinary(bytes: Uint8Array): MsgShuffleHand {
        return MsgShuffleHand.deserialize(bytes);
      }
    }
    export class MsgSelectBattleCmd extends pb_1.Message {
      #one_of_decls: number[][] = [];
      constructor(
        data?:
          | any[]
          | {
              player?: number;
              battle_cmds?: StocGameMessage.MsgSelectBattleCmd.BattleCmd[];
              enable_m2?: boolean;
              enable_ep?: boolean;
            }
      ) {
        super();
        pb_1.Message.initialize(
          this,
          Array.isArray(data) ? data : [],
          0,
          -1,
          [2],
          this.#one_of_decls
        );
        if (!Array.isArray(data) && typeof data == "object") {
          if ("player" in data && data.player != undefined) {
            this.player = data.player;
          }
          if ("battle_cmds" in data && data.battle_cmds != undefined) {
            this.battle_cmds = data.battle_cmds;
          }
          if ("enable_m2" in data && data.enable_m2 != undefined) {
            this.enable_m2 = data.enable_m2;
          }
          if ("enable_ep" in data && data.enable_ep != undefined) {
            this.enable_ep = data.enable_ep;
          }
        }
      }
      get player() {
        return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
      }
      set player(value: number) {
        pb_1.Message.setField(this, 1, value);
      }
      get battle_cmds() {
        return pb_1.Message.getRepeatedWrapperField(
          this,
          StocGameMessage.MsgSelectBattleCmd.BattleCmd,
          2
        ) as StocGameMessage.MsgSelectBattleCmd.BattleCmd[];
      }
      set battle_cmds(value: StocGameMessage.MsgSelectBattleCmd.BattleCmd[]) {
        pb_1.Message.setRepeatedWrapperField(this, 2, value);
      }
      get enable_m2() {
        return pb_1.Message.getFieldWithDefault(this, 3, false) as boolean;
      }
      set enable_m2(value: boolean) {
        pb_1.Message.setField(this, 3, value);
      }
      get enable_ep() {
        return pb_1.Message.getFieldWithDefault(this, 4, false) as boolean;
      }
      set enable_ep(value: boolean) {
        pb_1.Message.setField(this, 4, value);
      }
      static fromObject(data: {
        player?: number;
        battle_cmds?: ReturnType<
          typeof StocGameMessage.MsgSelectBattleCmd.BattleCmd.prototype.toObject
        >[];
        enable_m2?: boolean;
        enable_ep?: boolean;
      }): MsgSelectBattleCmd {
        const message = new MsgSelectBattleCmd({});
        if (data.player != null) {
          message.player = data.player;
        }
        if (data.battle_cmds != null) {
          message.battle_cmds = data.battle_cmds.map((item) =>
            StocGameMessage.MsgSelectBattleCmd.BattleCmd.fromObject(item)
          );
        }
        if (data.enable_m2 != null) {
          message.enable_m2 = data.enable_m2;
        }
        if (data.enable_ep != null) {
          message.enable_ep = data.enable_ep;
        }
        return message;
      }
      toObject() {
        const data: {
          player?: number;
          battle_cmds?: ReturnType<
            typeof StocGameMessage.MsgSelectBattleCmd.BattleCmd.prototype.toObject
          >[];
          enable_m2?: boolean;
          enable_ep?: boolean;
        } = {};
        if (this.player != null) {
          data.player = this.player;
        }
        if (this.battle_cmds != null) {
          data.battle_cmds = this.battle_cmds.map(
            (item: StocGameMessage.MsgSelectBattleCmd.BattleCmd) =>
              item.toObject()
          );
        }
        if (this.enable_m2 != null) {
          data.enable_m2 = this.enable_m2;
        }
        if (this.enable_ep != null) {
          data.enable_ep = this.enable_ep;
        }
        return data;
      }
      serialize(): Uint8Array;
      serialize(w: pb_1.BinaryWriter): void;
      serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.player != 0) writer.writeInt32(1, this.player);
        if (this.battle_cmds.length)
          writer.writeRepeatedMessage(
            2,
            this.battle_cmds,
            (item: StocGameMessage.MsgSelectBattleCmd.BattleCmd) =>
              item.serialize(writer)
          );
        if (this.enable_m2 != false) writer.writeBool(3, this.enable_m2);
        if (this.enable_ep != false) writer.writeBool(4, this.enable_ep);
        if (!w) return writer.getResultBuffer();
      }
      static deserialize(
        bytes: Uint8Array | pb_1.BinaryReader
      ): MsgSelectBattleCmd {
        const reader =
            bytes instanceof pb_1.BinaryReader
              ? bytes
              : new pb_1.BinaryReader(bytes),
          message = new MsgSelectBattleCmd();
        while (reader.nextField()) {
          if (reader.isEndGroup()) break;
          switch (reader.getFieldNumber()) {
            case 1:
              message.player = reader.readInt32();
              break;
            case 2:
              reader.readMessage(message.battle_cmds, () =>
                pb_1.Message.addToRepeatedWrapperField(
                  message,
                  2,
                  StocGameMessage.MsgSelectBattleCmd.BattleCmd.deserialize(
                    reader
                  ),
                  StocGameMessage.MsgSelectBattleCmd.BattleCmd
                )
              );
              break;
            case 3:
              message.enable_m2 = reader.readBool();
              break;
            case 4:
              message.enable_ep = reader.readBool();
              break;
            default:
              reader.skipField();
          }
        }
        return message;
      }
      serializeBinary(): Uint8Array {
        return this.serialize();
      }
      static deserializeBinary(bytes: Uint8Array): MsgSelectBattleCmd {
        return MsgSelectBattleCmd.deserialize(bytes);
      }
    }
    export namespace MsgSelectBattleCmd {
      export class BattleCmd extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(
          data?:
            | any[]
            | {
                battle_type?: StocGameMessage.MsgSelectBattleCmd.BattleCmd.BattleType;
                battle_datas?: StocGameMessage.MsgSelectBattleCmd.BattleCmd.BattleData[];
              }
        ) {
          super();
          pb_1.Message.initialize(
            this,
            Array.isArray(data) ? data : [],
            0,
            -1,
            [2],
            this.#one_of_decls
          );
          if (!Array.isArray(data) && typeof data == "object") {
            if ("battle_type" in data && data.battle_type != undefined) {
              this.battle_type = data.battle_type;
            }
            if ("battle_datas" in data && data.battle_datas != undefined) {
              this.battle_datas = data.battle_datas;
            }
          }
        }
        get battle_type() {
          return pb_1.Message.getFieldWithDefault(
            this,
            1,
            StocGameMessage.MsgSelectBattleCmd.BattleCmd.BattleType.UNKNOWN
          ) as StocGameMessage.MsgSelectBattleCmd.BattleCmd.BattleType;
        }
        set battle_type(
          value: StocGameMessage.MsgSelectBattleCmd.BattleCmd.BattleType
        ) {
          pb_1.Message.setField(this, 1, value);
        }
        get battle_datas() {
          return pb_1.Message.getRepeatedWrapperField(
            this,
            StocGameMessage.MsgSelectBattleCmd.BattleCmd.BattleData,
            2
          ) as StocGameMessage.MsgSelectBattleCmd.BattleCmd.BattleData[];
        }
        set battle_datas(
          value: StocGameMessage.MsgSelectBattleCmd.BattleCmd.BattleData[]
        ) {
          pb_1.Message.setRepeatedWrapperField(this, 2, value);
        }
        static fromObject(data: {
          battle_type?: StocGameMessage.MsgSelectBattleCmd.BattleCmd.BattleType;
          battle_datas?: ReturnType<
            typeof StocGameMessage.MsgSelectBattleCmd.BattleCmd.BattleData.prototype.toObject
          >[];
        }): BattleCmd {
          const message = new BattleCmd({});
          if (data.battle_type != null) {
            message.battle_type = data.battle_type;
          }
          if (data.battle_datas != null) {
            message.battle_datas = data.battle_datas.map((item) =>
              StocGameMessage.MsgSelectBattleCmd.BattleCmd.BattleData.fromObject(
                item
              )
            );
          }
          return message;
        }
        toObject() {
          const data: {
            battle_type?: StocGameMessage.MsgSelectBattleCmd.BattleCmd.BattleType;
            battle_datas?: ReturnType<
              typeof StocGameMessage.MsgSelectBattleCmd.BattleCmd.BattleData.prototype.toObject
            >[];
          } = {};
          if (this.battle_type != null) {
            data.battle_type = this.battle_type;
          }
          if (this.battle_datas != null) {
            data.battle_datas = this.battle_datas.map(
              (item: StocGameMessage.MsgSelectBattleCmd.BattleCmd.BattleData) =>
                item.toObject()
            );
          }
          return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
          const writer = w || new pb_1.BinaryWriter();
          if (
            this.battle_type !=
            StocGameMessage.MsgSelectBattleCmd.BattleCmd.BattleType.UNKNOWN
          )
            writer.writeEnum(1, this.battle_type);
          if (this.battle_datas.length)
            writer.writeRepeatedMessage(
              2,
              this.battle_datas,
              (item: StocGameMessage.MsgSelectBattleCmd.BattleCmd.BattleData) =>
                item.serialize(writer)
            );
          if (!w) return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): BattleCmd {
          const reader =
              bytes instanceof pb_1.BinaryReader
                ? bytes
                : new pb_1.BinaryReader(bytes),
            message = new BattleCmd();
          while (reader.nextField()) {
            if (reader.isEndGroup()) break;
            switch (reader.getFieldNumber()) {
              case 1:
                message.battle_type = reader.readEnum();
                break;
              case 2:
                reader.readMessage(message.battle_datas, () =>
                  pb_1.Message.addToRepeatedWrapperField(
                    message,
                    2,
                    StocGameMessage.MsgSelectBattleCmd.BattleCmd.BattleData.deserialize(
                      reader
                    ),
                    StocGameMessage.MsgSelectBattleCmd.BattleCmd.BattleData
                  )
                );
                break;
              default:
                reader.skipField();
            }
          }
          return message;
        }
        serializeBinary(): Uint8Array {
          return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): BattleCmd {
          return BattleCmd.deserialize(bytes);
        }
      }
      export namespace BattleCmd {
        export enum BattleType {
          UNKNOWN = 0,
          ACTIVATE = 1,
          ATTACK = 2,
        }
        export class BattleData extends pb_1.Message {
          #one_of_decls: number[][] = [];
          constructor(
            data?:
              | any[]
              | {
                  card_info?: CardInfo;
                  effect_description?: number;
                  direct_attackable?: boolean;
                  response?: number;
                }
          ) {
            super();
            pb_1.Message.initialize(
              this,
              Array.isArray(data) ? data : [],
              0,
              -1,
              [],
              this.#one_of_decls
            );
            if (!Array.isArray(data) && typeof data == "object") {
              if ("card_info" in data && data.card_info != undefined) {
                this.card_info = data.card_info;
              }
              if (
                "effect_description" in data &&
                data.effect_description != undefined
              ) {
                this.effect_description = data.effect_description;
              }
              if (
                "direct_attackable" in data &&
                data.direct_attackable != undefined
              ) {
                this.direct_attackable = data.direct_attackable;
              }
              if ("response" in data && data.response != undefined) {
                this.response = data.response;
              }
            }
          }
          get card_info() {
            return pb_1.Message.getWrapperField(this, CardInfo, 1) as CardInfo;
          }
          set card_info(value: CardInfo) {
            pb_1.Message.setWrapperField(this, 1, value);
          }
          get has_card_info() {
            return pb_1.Message.getField(this, 1) != null;
          }
          get effect_description() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
          }
          set effect_description(value: number) {
            pb_1.Message.setField(this, 2, value);
          }
          get direct_attackable() {
            return pb_1.Message.getFieldWithDefault(this, 3, false) as boolean;
          }
          set direct_attackable(value: boolean) {
            pb_1.Message.setField(this, 3, value);
          }
          get response() {
            return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
          }
          set response(value: number) {
            pb_1.Message.setField(this, 4, value);
          }
          static fromObject(data: {
            card_info?: ReturnType<typeof CardInfo.prototype.toObject>;
            effect_description?: number;
            direct_attackable?: boolean;
            response?: number;
          }): BattleData {
            const message = new BattleData({});
            if (data.card_info != null) {
              message.card_info = CardInfo.fromObject(data.card_info);
            }
            if (data.effect_description != null) {
              message.effect_description = data.effect_description;
            }
            if (data.direct_attackable != null) {
              message.direct_attackable = data.direct_attackable;
            }
            if (data.response != null) {
              message.response = data.response;
            }
            return message;
          }
          toObject() {
            const data: {
              card_info?: ReturnType<typeof CardInfo.prototype.toObject>;
              effect_description?: number;
              direct_attackable?: boolean;
              response?: number;
            } = {};
            if (this.card_info != null) {
              data.card_info = this.card_info.toObject();
            }
            if (this.effect_description != null) {
              data.effect_description = this.effect_description;
            }
            if (this.direct_attackable != null) {
              data.direct_attackable = this.direct_attackable;
            }
            if (this.response != null) {
              data.response = this.response;
            }
            return data;
          }
          serialize(): Uint8Array;
          serialize(w: pb_1.BinaryWriter): void;
          serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_card_info)
              writer.writeMessage(1, this.card_info, () =>
                this.card_info.serialize(writer)
              );
            if (this.effect_description != 0)
              writer.writeInt32(2, this.effect_description);
            if (this.direct_attackable != false)
              writer.writeBool(3, this.direct_attackable);
            if (this.response != 0) writer.writeInt32(4, this.response);
            if (!w) return writer.getResultBuffer();
          }
          static deserialize(
            bytes: Uint8Array | pb_1.BinaryReader
          ): BattleData {
            const reader =
                bytes instanceof pb_1.BinaryReader
                  ? bytes
                  : new pb_1.BinaryReader(bytes),
              message = new BattleData();
            while (reader.nextField()) {
              if (reader.isEndGroup()) break;
              switch (reader.getFieldNumber()) {
                case 1:
                  reader.readMessage(
                    message.card_info,
                    () => (message.card_info = CardInfo.deserialize(reader))
                  );
                  break;
                case 2:
                  message.effect_description = reader.readInt32();
                  break;
                case 3:
                  message.direct_attackable = reader.readBool();
                  break;
                case 4:
                  message.response = reader.readInt32();
                  break;
                default:
                  reader.skipField();
              }
            }
            return message;
          }
          serializeBinary(): Uint8Array {
            return this.serialize();
          }
          static deserializeBinary(bytes: Uint8Array): BattleData {
            return BattleData.deserialize(bytes);
          }
        }
      }
    }
    export class MsgPosChange extends pb_1.Message {
      #one_of_decls: number[][] = [];
      constructor(
        data?:
          | any[]
          | {
              card_info?: CardInfo;
              pre_position?: CardPosition;
              cur_position?: CardPosition;
            }
      ) {
        super();
        pb_1.Message.initialize(
          this,
          Array.isArray(data) ? data : [],
          0,
          -1,
          [],
          this.#one_of_decls
        );
        if (!Array.isArray(data) && typeof data == "object") {
          if ("card_info" in data && data.card_info != undefined) {
            this.card_info = data.card_info;
          }
          if ("pre_position" in data && data.pre_position != undefined) {
            this.pre_position = data.pre_position;
          }
          if ("cur_position" in data && data.cur_position != undefined) {
            this.cur_position = data.cur_position;
          }
        }
      }
      get card_info() {
        return pb_1.Message.getWrapperField(this, CardInfo, 1) as CardInfo;
      }
      set card_info(value: CardInfo) {
        pb_1.Message.setWrapperField(this, 1, value);
      }
      get has_card_info() {
        return pb_1.Message.getField(this, 1) != null;
      }
      get pre_position() {
        return pb_1.Message.getFieldWithDefault(
          this,
          2,
          CardPosition.FACEUP_ATTACK
        ) as CardPosition;
      }
      set pre_position(value: CardPosition) {
        pb_1.Message.setField(this, 2, value);
      }
      get cur_position() {
        return pb_1.Message.getFieldWithDefault(
          this,
          3,
          CardPosition.FACEUP_ATTACK
        ) as CardPosition;
      }
      set cur_position(value: CardPosition) {
        pb_1.Message.setField(this, 3, value);
      }
      static fromObject(data: {
        card_info?: ReturnType<typeof CardInfo.prototype.toObject>;
        pre_position?: CardPosition;
        cur_position?: CardPosition;
      }): MsgPosChange {
        const message = new MsgPosChange({});
        if (data.card_info != null) {
          message.card_info = CardInfo.fromObject(data.card_info);
        }
        if (data.pre_position != null) {
          message.pre_position = data.pre_position;
        }
        if (data.cur_position != null) {
          message.cur_position = data.cur_position;
        }
        return message;
      }
      toObject() {
        const data: {
          card_info?: ReturnType<typeof CardInfo.prototype.toObject>;
          pre_position?: CardPosition;
          cur_position?: CardPosition;
        } = {};
        if (this.card_info != null) {
          data.card_info = this.card_info.toObject();
        }
        if (this.pre_position != null) {
          data.pre_position = this.pre_position;
        }
        if (this.cur_position != null) {
          data.cur_position = this.cur_position;
        }
        return data;
      }
      serialize(): Uint8Array;
      serialize(w: pb_1.BinaryWriter): void;
      serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.has_card_info)
          writer.writeMessage(1, this.card_info, () =>
            this.card_info.serialize(writer)
          );
        if (this.pre_position != CardPosition.FACEUP_ATTACK)
          writer.writeEnum(2, this.pre_position);
        if (this.cur_position != CardPosition.FACEUP_ATTACK)
          writer.writeEnum(3, this.cur_position);
        if (!w) return writer.getResultBuffer();
      }
      static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgPosChange {
        const reader =
            bytes instanceof pb_1.BinaryReader
              ? bytes
              : new pb_1.BinaryReader(bytes),
          message = new MsgPosChange();
        while (reader.nextField()) {
          if (reader.isEndGroup()) break;
          switch (reader.getFieldNumber()) {
            case 1:
              reader.readMessage(
                message.card_info,
                () => (message.card_info = CardInfo.deserialize(reader))
              );
              break;
            case 2:
              message.pre_position = reader.readEnum();
              break;
            case 3:
              message.cur_position = reader.readEnum();
              break;
            default:
              reader.skipField();
          }
        }
        return message;
      }
      serializeBinary(): Uint8Array {
        return this.serialize();
      }
      static deserializeBinary(bytes: Uint8Array): MsgPosChange {
        return MsgPosChange.deserialize(bytes);
      }
    }
    export class MsgSelectUnselectCard extends pb_1.Message {
      #one_of_decls: number[][] = [];
      constructor(
        data?:
          | any[]
          | {
              player?: number;
              finishable?: boolean;
              cancelable?: boolean;
              min?: number;
              max?: number;
              selectable_cards?: StocGameMessage.MsgSelectUnselectCard.Info[];
              selected_cards?: StocGameMessage.MsgSelectUnselectCard.Info[];
            }
      ) {
        super();
        pb_1.Message.initialize(
          this,
          Array.isArray(data) ? data : [],
          0,
          -1,
          [6, 7],
          this.#one_of_decls
        );
        if (!Array.isArray(data) && typeof data == "object") {
          if ("player" in data && data.player != undefined) {
            this.player = data.player;
          }
          if ("finishable" in data && data.finishable != undefined) {
            this.finishable = data.finishable;
          }
          if ("cancelable" in data && data.cancelable != undefined) {
            this.cancelable = data.cancelable;
          }
          if ("min" in data && data.min != undefined) {
            this.min = data.min;
          }
          if ("max" in data && data.max != undefined) {
            this.max = data.max;
          }
          if (
            "selectable_cards" in data &&
            data.selectable_cards != undefined
          ) {
            this.selectable_cards = data.selectable_cards;
          }
          if ("selected_cards" in data && data.selected_cards != undefined) {
            this.selected_cards = data.selected_cards;
          }
        }
      }
      get player() {
        return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
      }
      set player(value: number) {
        pb_1.Message.setField(this, 1, value);
      }
      get finishable() {
        return pb_1.Message.getFieldWithDefault(this, 2, false) as boolean;
      }
      set finishable(value: boolean) {
        pb_1.Message.setField(this, 2, value);
      }
      get cancelable() {
        return pb_1.Message.getFieldWithDefault(this, 3, false) as boolean;
      }
      set cancelable(value: boolean) {
        pb_1.Message.setField(this, 3, value);
      }
      get min() {
        return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
      }
      set min(value: number) {
        pb_1.Message.setField(this, 4, value);
      }
      get max() {
        return pb_1.Message.getFieldWithDefault(this, 5, 0) as number;
      }
      set max(value: number) {
        pb_1.Message.setField(this, 5, value);
      }
      get selectable_cards() {
        return pb_1.Message.getRepeatedWrapperField(
          this,
          StocGameMessage.MsgSelectUnselectCard.Info,
          6
        ) as StocGameMessage.MsgSelectUnselectCard.Info[];
      }
      set selectable_cards(
        value: StocGameMessage.MsgSelectUnselectCard.Info[]
      ) {
        pb_1.Message.setRepeatedWrapperField(this, 6, value);
      }
      get selected_cards() {
        return pb_1.Message.getRepeatedWrapperField(
          this,
          StocGameMessage.MsgSelectUnselectCard.Info,
          7
        ) as StocGameMessage.MsgSelectUnselectCard.Info[];
      }
      set selected_cards(value: StocGameMessage.MsgSelectUnselectCard.Info[]) {
        pb_1.Message.setRepeatedWrapperField(this, 7, value);
      }
      static fromObject(data: {
        player?: number;
        finishable?: boolean;
        cancelable?: boolean;
        min?: number;
        max?: number;
        selectable_cards?: ReturnType<
          typeof StocGameMessage.MsgSelectUnselectCard.Info.prototype.toObject
        >[];
        selected_cards?: ReturnType<
          typeof StocGameMessage.MsgSelectUnselectCard.Info.prototype.toObject
        >[];
      }): MsgSelectUnselectCard {
        const message = new MsgSelectUnselectCard({});
        if (data.player != null) {
          message.player = data.player;
        }
        if (data.finishable != null) {
          message.finishable = data.finishable;
        }
        if (data.cancelable != null) {
          message.cancelable = data.cancelable;
        }
        if (data.min != null) {
          message.min = data.min;
        }
        if (data.max != null) {
          message.max = data.max;
        }
        if (data.selectable_cards != null) {
          message.selectable_cards = data.selectable_cards.map((item) =>
            StocGameMessage.MsgSelectUnselectCard.Info.fromObject(item)
          );
        }
        if (data.selected_cards != null) {
          message.selected_cards = data.selected_cards.map((item) =>
            StocGameMessage.MsgSelectUnselectCard.Info.fromObject(item)
          );
        }
        return message;
      }
      toObject() {
        const data: {
          player?: number;
          finishable?: boolean;
          cancelable?: boolean;
          min?: number;
          max?: number;
          selectable_cards?: ReturnType<
            typeof StocGameMessage.MsgSelectUnselectCard.Info.prototype.toObject
          >[];
          selected_cards?: ReturnType<
            typeof StocGameMessage.MsgSelectUnselectCard.Info.prototype.toObject
          >[];
        } = {};
        if (this.player != null) {
          data.player = this.player;
        }
        if (this.finishable != null) {
          data.finishable = this.finishable;
        }
        if (this.cancelable != null) {
          data.cancelable = this.cancelable;
        }
        if (this.min != null) {
          data.min = this.min;
        }
        if (this.max != null) {
          data.max = this.max;
        }
        if (this.selectable_cards != null) {
          data.selectable_cards = this.selectable_cards.map(
            (item: StocGameMessage.MsgSelectUnselectCard.Info) =>
              item.toObject()
          );
        }
        if (this.selected_cards != null) {
          data.selected_cards = this.selected_cards.map(
            (item: StocGameMessage.MsgSelectUnselectCard.Info) =>
              item.toObject()
          );
        }
        return data;
      }
      serialize(): Uint8Array;
      serialize(w: pb_1.BinaryWriter): void;
      serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.player != 0) writer.writeInt32(1, this.player);
        if (this.finishable != false) writer.writeBool(2, this.finishable);
        if (this.cancelable != false) writer.writeBool(3, this.cancelable);
        if (this.min != 0) writer.writeInt32(4, this.min);
        if (this.max != 0) writer.writeInt32(5, this.max);
        if (this.selectable_cards.length)
          writer.writeRepeatedMessage(
            6,
            this.selectable_cards,
            (item: StocGameMessage.MsgSelectUnselectCard.Info) =>
              item.serialize(writer)
          );
        if (this.selected_cards.length)
          writer.writeRepeatedMessage(
            7,
            this.selected_cards,
            (item: StocGameMessage.MsgSelectUnselectCard.Info) =>
              item.serialize(writer)
          );
        if (!w) return writer.getResultBuffer();
      }
      static deserialize(
        bytes: Uint8Array | pb_1.BinaryReader
      ): MsgSelectUnselectCard {
        const reader =
            bytes instanceof pb_1.BinaryReader
              ? bytes
              : new pb_1.BinaryReader(bytes),
          message = new MsgSelectUnselectCard();
        while (reader.nextField()) {
          if (reader.isEndGroup()) break;
          switch (reader.getFieldNumber()) {
            case 1:
              message.player = reader.readInt32();
              break;
            case 2:
              message.finishable = reader.readBool();
              break;
            case 3:
              message.cancelable = reader.readBool();
              break;
            case 4:
              message.min = reader.readInt32();
              break;
            case 5:
              message.max = reader.readInt32();
              break;
            case 6:
              reader.readMessage(message.selectable_cards, () =>
                pb_1.Message.addToRepeatedWrapperField(
                  message,
                  6,
                  StocGameMessage.MsgSelectUnselectCard.Info.deserialize(
                    reader
                  ),
                  StocGameMessage.MsgSelectUnselectCard.Info
                )
              );
              break;
            case 7:
              reader.readMessage(message.selected_cards, () =>
                pb_1.Message.addToRepeatedWrapperField(
                  message,
                  7,
                  StocGameMessage.MsgSelectUnselectCard.Info.deserialize(
                    reader
                  ),
                  StocGameMessage.MsgSelectUnselectCard.Info
                )
              );
              break;
            default:
              reader.skipField();
          }
        }
        return message;
      }
      serializeBinary(): Uint8Array {
        return this.serialize();
      }
      static deserializeBinary(bytes: Uint8Array): MsgSelectUnselectCard {
        return MsgSelectUnselectCard.deserialize(bytes);
      }
    }
    export namespace MsgSelectUnselectCard {
      export class Info extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(
          data?:
            | any[]
            | {
                code?: number;
                location?: CardLocation;
                response?: number;
              }
        ) {
          super();
          pb_1.Message.initialize(
            this,
            Array.isArray(data) ? data : [],
            0,
            -1,
            [],
            this.#one_of_decls
          );
          if (!Array.isArray(data) && typeof data == "object") {
            if ("code" in data && data.code != undefined) {
              this.code = data.code;
            }
            if ("location" in data && data.location != undefined) {
              this.location = data.location;
            }
            if ("response" in data && data.response != undefined) {
              this.response = data.response;
            }
          }
        }
        get code() {
          return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set code(value: number) {
          pb_1.Message.setField(this, 1, value);
        }
        get location() {
          return pb_1.Message.getWrapperField(
            this,
            CardLocation,
            2
          ) as CardLocation;
        }
        set location(value: CardLocation) {
          pb_1.Message.setWrapperField(this, 2, value);
        }
        get has_location() {
          return pb_1.Message.getField(this, 2) != null;
        }
        get response() {
          return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
        }
        set response(value: number) {
          pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
          code?: number;
          location?: ReturnType<typeof CardLocation.prototype.toObject>;
          response?: number;
        }): Info {
          const message = new Info({});
          if (data.code != null) {
            message.code = data.code;
          }
          if (data.location != null) {
            message.location = CardLocation.fromObject(data.location);
          }
          if (data.response != null) {
            message.response = data.response;
          }
          return message;
        }
        toObject() {
          const data: {
            code?: number;
            location?: ReturnType<typeof CardLocation.prototype.toObject>;
            response?: number;
          } = {};
          if (this.code != null) {
            data.code = this.code;
          }
          if (this.location != null) {
            data.location = this.location.toObject();
          }
          if (this.response != null) {
            data.response = this.response;
          }
          return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
          const writer = w || new pb_1.BinaryWriter();
          if (this.code != 0) writer.writeInt32(1, this.code);
          if (this.has_location)
            writer.writeMessage(2, this.location, () =>
              this.location.serialize(writer)
            );
          if (this.response != 0) writer.writeInt32(3, this.response);
          if (!w) return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Info {
          const reader =
              bytes instanceof pb_1.BinaryReader
                ? bytes
                : new pb_1.BinaryReader(bytes),
            message = new Info();
          while (reader.nextField()) {
            if (reader.isEndGroup()) break;
            switch (reader.getFieldNumber()) {
              case 1:
                message.code = reader.readInt32();
                break;
              case 2:
                reader.readMessage(
                  message.location,
                  () => (message.location = CardLocation.deserialize(reader))
                );
                break;
              case 3:
                message.response = reader.readInt32();
                break;
              default:
                reader.skipField();
            }
          }
          return message;
        }
        serializeBinary(): Uint8Array {
          return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Info {
          return Info.deserialize(bytes);
        }
      }
    }
  }
}
